var Vue=function(exports){"use strict";function makeMap(str,expectsLowerCase){const map=Object.create(null),list=str.split(",");for(let i=0;i<list.length;i++)map[list[i]]=!0;return expectsLowerCase?val=>!!map[val.toLowerCase()]:val=>!!map[val]}function generateCodeFrame(source,start=0,end=source.length){let lines=source.split(/(\r?\n)/);const newlineSequences=lines.filter((_,idx)=>idx%2==1);lines=lines.filter((_,idx)=>idx%2==0);let count=0;const res=[];for(let i=0;i<lines.length;i++)if(count+=lines[i].length+(newlineSequences[i]&&newlineSequences[i].length||0),count>=start){for(let j=i-range;j<=i+range||end>count;j++){if(j<0||j>=lines.length)continue;const line=j+1;res.push(`${line}${" ".repeat(Math.max(3-String(line).length,0))}|  ${lines[j]}`);const lineLength=lines[j].length,newLineSeqLength=newlineSequences[j]&&newlineSequences[j].length||0;if(j===i){const pad=start-(count-(lineLength+newLineSeqLength)),length=Math.max(1,end>count?lineLength-pad:end-start);res.push("   |  "+" ".repeat(pad)+"^".repeat(length))}else if(j>i){if(end>count){const length=Math.max(Math.min(end-count,lineLength),1);res.push("   |  "+"^".repeat(length))}count+=lineLength+newLineSeqLength}}break}return res.join("\n")}function includeBooleanAttr(value){return!!value||""===value}function normalizeStyle(value){if(isArray(value)){const res={};for(let i=0;i<value.length;i++){const item=value[i],normalized=isString(item)?parseStringStyle(item):normalizeStyle(item);if(normalized)for(const key in normalized)res[key]=normalized[key]}return res}return isString(value)?value:isObject(value)?value:void 0}function parseStringStyle(cssText){const ret={};return cssText.split(listDelimiterRE).forEach(item=>{if(item){const tmp=item.split(propertyDelimiterRE);tmp.length>1&&(ret[tmp[0].trim()]=tmp[1].trim())}}),ret}function normalizeClass(value){let res="";if(isString(value))res=value;else if(isArray(value))for(let i=0;i<value.length;i++){const normalized=normalizeClass(value[i]);normalized&&(res+=normalized+" ")}else if(isObject(value))for(const name in value)value[name]&&(res+=name+" ");return res.trim()}function normalizeProps(props){if(!props)return null;let{class:klass,style:style}=props;return klass&&!isString(klass)&&(props.class=normalizeClass(klass)),style&&(props.style=normalizeStyle(style)),props}function looseCompareArrays(a,b){if(a.length!==b.length)return!1;let equal=!0;for(let i=0;equal&&i<a.length;i++)equal=looseEqual(a[i],b[i]);return equal}function looseEqual(a,b){if(a===b)return!0;let aValidType=isDate(a),bValidType=isDate(b);if(aValidType||bValidType)return!(!aValidType||!bValidType)&&a.getTime()===b.getTime();if(aValidType=isArray(a),bValidType=isArray(b),aValidType||bValidType)return!(!aValidType||!bValidType)&&looseCompareArrays(a,b);if(aValidType=isObject(a),bValidType=isObject(b),aValidType||bValidType){if(!aValidType||!bValidType)return!1;const aKeysCount=Object.keys(a).length,bKeysCount=Object.keys(b).length;if(aKeysCount!==bKeysCount)return!1;for(const key in a){const aHasKey=a.hasOwnProperty(key),bHasKey=b.hasOwnProperty(key);if(aHasKey&&!bHasKey||!aHasKey&&bHasKey||!looseEqual(a[key],b[key]))return!1}}return String(a)===String(b)}function looseIndexOf(arr,val){return arr.findIndex(item=>looseEqual(item,val))}function warn(msg,...args){console.warn(`[Vue warn] ${msg}`,...args)}function effectScope(detached){return new EffectScope(detached)}function recordEffectScope(effect,scope=activeEffectScope){scope&&scope.active&&scope.effects.push(effect)}function getCurrentScope(){return activeEffectScope}function onScopeDispose(fn){activeEffectScope?activeEffectScope.cleanups.push(fn):warn("onScopeDispose() is called when there is no active effect scope to be associated with.")}function cleanupEffect(effect){const{deps:deps}=effect;if(deps.length){for(let i=0;i<deps.length;i++)deps[i].delete(effect);deps.length=0}}function effect(fn,options){fn.effect&&(fn=fn.effect.fn);const _effect=new ReactiveEffect(fn);options&&(extend(_effect,options),options.scope&&recordEffectScope(_effect,options.scope)),options&&options.lazy||_effect.run();const runner=_effect.run.bind(_effect);return runner.effect=_effect,runner}function stop(runner){runner.effect.stop()}function pauseTracking(){trackStack.push(shouldTrack),shouldTrack=!1}function resetTracking(){const last=trackStack.pop();shouldTrack=void 0===last||last}function track(target,type,key){if(shouldTrack&&activeEffect){let depsMap=targetMap.get(target);depsMap||targetMap.set(target,depsMap=new Map);let dep=depsMap.get(key);dep||depsMap.set(key,dep=createDep());const eventInfo={effect:activeEffect,target:target,type:type,key:key};trackEffects(dep,eventInfo)}}function trackEffects(dep,debuggerEventExtraInfo){let shouldTrack=!1;effectTrackDepth<=maxMarkerBits?newTracked(dep)||(dep.n|=trackOpBit,shouldTrack=!wasTracked(dep)):shouldTrack=!dep.has(activeEffect),shouldTrack&&(dep.add(activeEffect),activeEffect.deps.push(dep),activeEffect.onTrack&&activeEffect.onTrack(Object.assign({effect:activeEffect},debuggerEventExtraInfo)))}function trigger(target,type,key,newValue,oldValue,oldTarget){const depsMap=targetMap.get(target);if(!depsMap)return;let deps=[];if("clear"===type)deps=[...depsMap.values()];else if("length"===key&&isArray(target))depsMap.forEach((dep,key)=>{("length"===key||key>=newValue)&&deps.push(dep)});else switch(void 0!==key&&deps.push(depsMap.get(key)),type){case"add":isArray(target)?isIntegerKey(key)&&deps.push(depsMap.get("length")):(deps.push(depsMap.get(ITERATE_KEY)),isMap(target)&&deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)));break;case"delete":isArray(target)||(deps.push(depsMap.get(ITERATE_KEY)),isMap(target)&&deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)));break;case"set":isMap(target)&&deps.push(depsMap.get(ITERATE_KEY))}const eventInfo={target:target,type:type,key:key,newValue:newValue,oldValue:oldValue,oldTarget:oldTarget};if(1===deps.length)deps[0]&&triggerEffects(deps[0],eventInfo);else{const effects=[];for(const dep of deps)dep&&effects.push(...dep);triggerEffects(createDep(effects),eventInfo)}}function triggerEffects(dep,debuggerEventExtraInfo){for(const effect of isArray(dep)?dep:[...dep])(effect!==activeEffect||effect.allowRecurse)&&(effect.onTrigger&&effect.onTrigger(extend({effect:effect},debuggerEventExtraInfo)),effect.scheduler?effect.scheduler():effect.run())}function createArrayInstrumentations(){const instrumentations={};return["includes","indexOf","lastIndexOf"].forEach(key=>{instrumentations[key]=function(...args){const arr=toRaw(this);for(let i=0,l=this.length;i<l;i++)track(arr,"get",i+"");const res=arr[key](...args);return-1===res||!1===res?arr[key](...args.map(toRaw)):res}}),["push","pop","shift","unshift","splice"].forEach(key=>{instrumentations[key]=function(...args){pauseTracking();const res=toRaw(this)[key].apply(this,args);return resetTracking(),res}}),instrumentations}function createGetter(isReadonly=!1,shallow=!1){return function(target,key,receiver){if("__v_isReactive"===key)return!isReadonly;if("__v_isReadonly"===key)return isReadonly;if("__v_isShallow"===key)return shallow;if("__v_raw"===key&&receiver===(isReadonly?shallow?shallowReadonlyMap:readonlyMap:shallow?shallowReactiveMap:reactiveMap).get(target))return target;const targetIsArray=isArray(target);if(!isReadonly&&targetIsArray&&hasOwn(arrayInstrumentations,key))return Reflect.get(arrayInstrumentations,key,receiver);const res=Reflect.get(target,key,receiver);if(isSymbol(key)?builtInSymbols.has(key):isNonTrackableKeys(key))return res;if(isReadonly||track(target,"get",key),shallow)return res;if(isRef(res)){const shouldUnwrap=!targetIsArray||!isIntegerKey(key);return shouldUnwrap?res.value:res}return isObject(res)?isReadonly?readonly(res):reactive(res):res}}function createSetter(shallow=!1){return function(target,key,value,receiver){let oldValue=target[key];if(isReadonly(oldValue)&&isRef(oldValue)&&!isRef(value))return!1;if(!shallow&&!isReadonly(value)&&(isShallow(value)||(value=toRaw(value),oldValue=toRaw(oldValue)),!isArray(target)&&isRef(oldValue)&&!isRef(value)))return oldValue.value=value,!0;const hadKey=isArray(target)&&isIntegerKey(key)?Number(key)<target.length:hasOwn(target,key),result=Reflect.set(target,key,value,receiver);return target===toRaw(receiver)&&(hadKey?hasChanged(value,oldValue)&&trigger(target,"set",key,value,oldValue):trigger(target,"add",key,value)),result}}function deleteProperty(target,key){const hadKey=hasOwn(target,key),oldValue=target[key],result=Reflect.deleteProperty(target,key);return result&&hadKey&&trigger(target,"delete",key,void 0,oldValue),result}function has(target,key){const result=Reflect.has(target,key);return isSymbol(key)&&builtInSymbols.has(key)||track(target,"has",key),result}function ownKeys(target){return track(target,"iterate",isArray(target)?"length":ITERATE_KEY),Reflect.ownKeys(target)}function get$1(target,key,isReadonly=!1,isShallow=!1){target=target.__v_raw;const rawTarget=toRaw(target),rawKey=toRaw(key);key!==rawKey&&!isReadonly&&track(rawTarget,"get",key),!isReadonly&&track(rawTarget,"get",rawKey);const{has:has}=getProto(rawTarget),wrap=isShallow?toShallow:isReadonly?toReadonly:toReactive;return has.call(rawTarget,key)?wrap(target.get(key)):has.call(rawTarget,rawKey)?wrap(target.get(rawKey)):void(target!==rawTarget&&target.get(key))}function has$1(key,isReadonly=!1){const target=this.__v_raw,rawTarget=toRaw(target),rawKey=toRaw(key);return key!==rawKey&&!isReadonly&&track(rawTarget,"has",key),!isReadonly&&track(rawTarget,"has",rawKey),key===rawKey?target.has(key):target.has(key)||target.has(rawKey)}function size(target,isReadonly=!1){return target=target.__v_raw,!isReadonly&&track(toRaw(target),"iterate",ITERATE_KEY),Reflect.get(target,"size",target)}function add(value){value=toRaw(value);const target=toRaw(this),proto=getProto(target),hadKey=proto.has.call(target,value);return hadKey||(target.add(value),trigger(target,"add",value,value)),this}function set$1(key,value){value=toRaw(value);const target=toRaw(this),{has:has,get:get}=getProto(target);let hadKey=has.call(target,key);hadKey?checkIdentityKeys(target,has,key):(key=toRaw(key),hadKey=has.call(target,key));const oldValue=get.call(target,key);return target.set(key,value),hadKey?hasChanged(value,oldValue)&&trigger(target,"set",key,value,oldValue):trigger(target,"add",key,value),this}function deleteEntry(key){const target=toRaw(this),{has:has,get:get}=getProto(target);let hadKey=has.call(target,key);hadKey?checkIdentityKeys(target,has,key):(key=toRaw(key),hadKey=has.call(target,key));const oldValue=get?get.call(target,key):void 0,result=target.delete(key);return hadKey&&trigger(target,"delete",key,void 0,oldValue),result}function clear(){const target=toRaw(this),hadItems=0!==target.size,oldTarget=isMap(target)?new Map(target):new Set(target),result=target.clear();return hadItems&&trigger(target,"clear",void 0,void 0,oldTarget),result}function createForEach(isReadonly,isShallow){return function(callback,thisArg){const observed=this,target=observed.__v_raw,rawTarget=toRaw(target),wrap=isShallow?toShallow:isReadonly?toReadonly:toReactive;return!isReadonly&&track(rawTarget,"iterate",ITERATE_KEY),target.forEach((value,key)=>callback.call(thisArg,wrap(value),wrap(key),observed))}}function createIterableMethod(method,isReadonly,isShallow){return function(...args){const target=this.__v_raw,rawTarget=toRaw(target),targetIsMap=isMap(rawTarget),isPair="entries"===method||method===Symbol.iterator&&targetIsMap,isKeyOnly="keys"===method&&targetIsMap,innerIterator=target[method](...args),wrap=isShallow?toShallow:isReadonly?toReadonly:toReactive;return!isReadonly&&track(rawTarget,"iterate",isKeyOnly?MAP_KEY_ITERATE_KEY:ITERATE_KEY),{next(){const{value:value,done:done}=innerIterator.next();return done?{value:value,done:done}:{value:isPair?[wrap(value[0]),wrap(value[1])]:wrap(value),done:done}},[Symbol.iterator](){return this}}}}function createReadonlyMethod(type){return function(...args){{const key=args[0]?`on key "${args[0]}" `:"";console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`,toRaw(this))}return"delete"!==type&&this}}function createInstrumentations(){const mutableInstrumentations={get(key){return get$1(this,key)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(!1,!1)},shallowInstrumentations={get(key){return get$1(this,key,!1,!0)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(!1,!0)},readonlyInstrumentations={get(key){return get$1(this,key,!0)},get size(){return size(this,!0)},has(key){return has$1.call(this,key,!0)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(!0,!1)},shallowReadonlyInstrumentations={get(key){return get$1(this,key,!0,!0)},get size(){return size(this,!0)},has(key){return has$1.call(this,key,!0)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(!0,!0)},iteratorMethods=["keys","values","entries",Symbol.iterator];return iteratorMethods.forEach(method=>{mutableInstrumentations[method]=createIterableMethod(method,!1,!1),readonlyInstrumentations[method]=createIterableMethod(method,!0,!1),shallowInstrumentations[method]=createIterableMethod(method,!1,!0),shallowReadonlyInstrumentations[method]=createIterableMethod(method,!0,!0)}),[mutableInstrumentations,readonlyInstrumentations,shallowInstrumentations,shallowReadonlyInstrumentations]}function createInstrumentationGetter(isReadonly,shallow){const instrumentations=shallow?isReadonly?shallowReadonlyInstrumentations:shallowInstrumentations:isReadonly?readonlyInstrumentations:mutableInstrumentations;return(target,key,receiver)=>"__v_isReactive"===key?!isReadonly:"__v_isReadonly"===key?isReadonly:"__v_raw"===key?target:Reflect.get(hasOwn(instrumentations,key)&&key in target?instrumentations:target,key,receiver)}function checkIdentityKeys(target,has,key){const rawKey=toRaw(key);if(rawKey!==key&&has.call(target,rawKey)){const type=toRawType(target);console.warn(`Reactive ${type} contains both the raw and reactive `+`versions of the same object${"Map"===type?" as keys":""}, `+"which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.")}}function targetTypeMap(rawType){switch(rawType){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function getTargetType(value){return value.__v_skip||!Object.isExtensible(value)?0:targetTypeMap(toRawType(value))}function reactive(target){return isReadonly(target)?target:createReactiveObject(target,!1,mutableHandlers,mutableCollectionHandlers,reactiveMap)}function shallowReactive(target){return createReactiveObject(target,!1,shallowReactiveHandlers,shallowCollectionHandlers,shallowReactiveMap)}function readonly(target){return createReactiveObject(target,!0,readonlyHandlers,readonlyCollectionHandlers,readonlyMap)}function shallowReadonly(target){return createReactiveObject(target,!0,shallowReadonlyHandlers,shallowReadonlyCollectionHandlers,shallowReadonlyMap)}function createReactiveObject(target,isReadonly,baseHandlers,collectionHandlers,proxyMap){if(!isObject(target))return console.warn(`value cannot be made reactive: ${String(target)}`),target;if(target.__v_raw&&(!isReadonly||!target.__v_isReactive))return target;const existingProxy=proxyMap.get(target);if(existingProxy)return existingProxy;const targetType=getTargetType(target);if(0===targetType)return target;const proxy=new Proxy(target,2===targetType?collectionHandlers:baseHandlers);return proxyMap.set(target,proxy),proxy}function isReactive(value){return isReadonly(value)?isReactive(value.__v_raw):!(!value||!value.__v_isReactive)}function isReadonly(value){return!(!value||!value.__v_isReadonly)}function isShallow(value){return!(!value||!value.__v_isShallow)}function isProxy(value){return isReactive(value)||isReadonly(value)}function toRaw(observed){const raw=observed&&observed.__v_raw;return raw?toRaw(raw):observed}function markRaw(value){return def(value,"__v_skip",!0),value}function trackRefValue(ref){shouldTrack&&activeEffect&&(ref=toRaw(ref),trackEffects(ref.dep||(ref.dep=createDep()),{target:ref,type:"get",key:"value"}))}function triggerRefValue(ref,newVal){ref=toRaw(ref),ref.dep&&triggerEffects(ref.dep,{target:ref,type:"set",key:"value",newValue:newVal})}function isRef(r){return!(!r||!0!==r.__v_isRef)}function ref(value){return createRef(value,!1)}function shallowRef(value){return createRef(value,!0)}function createRef(rawValue,shallow){return isRef(rawValue)?rawValue:new RefImpl(rawValue,shallow)}function triggerRef(ref){triggerRefValue(ref,ref.value)}function unref(ref){return isRef(ref)?ref.value:ref}function proxyRefs(objectWithRefs){return isReactive(objectWithRefs)?objectWithRefs:new Proxy(objectWithRefs,shallowUnwrapHandlers)}function customRef(factory){return new CustomRefImpl(factory)}function toRefs(object){isProxy(object)||console.warn("toRefs() expects a reactive object but received a plain one.");const ret=isArray(object)?new Array(object.length):{};for(const key in object)ret[key]=toRef(object,key);return ret}function toRef(object,key,defaultValue){const val=object[key];return isRef(val)?val:new ObjectRefImpl(object,key,defaultValue)}function computed(getterOrOptions,debugOptions,isSSR=!1){let getter,setter;const onlyGetter=isFunction(getterOrOptions);onlyGetter?(getter=getterOrOptions,setter=(()=>{console.warn("Write operation failed: computed value is readonly")})):(getter=getterOrOptions.get,setter=getterOrOptions.set);const cRef=new ComputedRefImpl(getter,setter,onlyGetter||!setter,isSSR);return debugOptions&&!isSSR&&(cRef.effect.onTrack=debugOptions.onTrack,cRef.effect.onTrigger=debugOptions.onTrigger),cRef}function pushWarningContext(vnode){stack.push(vnode)}function popWarningContext(){stack.pop()}function warn$1(msg,...args){pauseTracking();const instance=stack.length?stack[stack.length-1].component:null,appWarnHandler=instance&&instance.appContext.config.warnHandler,trace=getComponentTrace();if(appWarnHandler)callWithErrorHandling(appWarnHandler,instance,11,[msg+args.join(""),instance&&instance.proxy,trace.map(({vnode:vnode})=>`at <${formatComponentName(instance,vnode.type)}>`).join("\n"),trace]);else{const warnArgs=[`[Vue warn]: ${msg}`,...args];trace.length&&warnArgs.push("\n",...formatTrace(trace)),console.warn(...warnArgs)}resetTracking()}function getComponentTrace(){let currentVNode=stack[stack.length-1];if(!currentVNode)return[];const normalizedStack=[];for(;currentVNode;){const last=normalizedStack[0];last&&last.vnode===currentVNode?last.recurseCount++:normalizedStack.push({vnode:currentVNode,recurseCount:0});const parentInstance=currentVNode.component&&currentVNode.component.parent;currentVNode=parentInstance&&parentInstance.vnode}return normalizedStack}function formatTrace(trace){const logs=[];return trace.forEach((entry,i)=>{logs.push(...0===i?[]:["\n"],...formatTraceEntry(entry))}),logs}function formatTraceEntry({vnode:vnode,recurseCount:recurseCount}){const postfix=recurseCount>0?`... (${recurseCount} recursive calls)`:"",isRoot=!!vnode.component&&null==vnode.component.parent,open=` at <${formatComponentName(vnode.component,vnode.type,isRoot)}`,close=">"+postfix;return vnode.props?[open,...formatProps(vnode.props),close]:[open+close]}function formatProps(props){const res=[],keys=Object.keys(props);return keys.slice(0,3).forEach(key=>{res.push(...formatProp(key,props[key]))}),keys.length>3&&res.push(" ..."),res}function formatProp(key,value,raw){return isString(value)?(value=JSON.stringify(value),raw?value:[`${key}=${value}`]):"number"==typeof value||"boolean"==typeof value||null==value?raw?value:[`${key}=${value}`]:isRef(value)?(value=formatProp(key,toRaw(value.value),!0),raw?value:[`${key}=Ref<`,value,">"]):isFunction(value)?[`${key}=fn${value.name?`<${value.name}>`:""}`]:(value=toRaw(value),raw?value:[`${key}=`,value])}function callWithErrorHandling(fn,instance,type,args){let res;try{res=args?fn(...args):fn()}catch(err){handleError(err,instance,type)}return res}function callWithAsyncErrorHandling(fn,instance,type,args){if(isFunction(fn)){const res=callWithErrorHandling(fn,instance,type,args);return res&&isPromise(res)&&res.catch(err=>{handleError(err,instance,type)}),res}const values=[];for(let i=0;i<fn.length;i++)values.push(callWithAsyncErrorHandling(fn[i],instance,type,args));return values}function handleError(err,instance,type,throwInDev=!0){const contextVNode=instance?instance.vnode:null;if(instance){let cur=instance.parent;const exposedInstance=instance.proxy,errorInfo=ErrorTypeStrings[type];for(;cur;){const errorCapturedHooks=cur.ec;if(errorCapturedHooks)for(let i=0;i<errorCapturedHooks.length;i++)if(!1===errorCapturedHooks[i](err,exposedInstance,errorInfo))return;cur=cur.parent}const appErrorHandler=instance.appContext.config.errorHandler;if(appErrorHandler)return void callWithErrorHandling(appErrorHandler,null,10,[err,exposedInstance,errorInfo])}logError(err,type,contextVNode,throwInDev)}function logError(err,type,contextVNode,throwInDev=!0){{const info=ErrorTypeStrings[type];if(contextVNode&&pushWarningContext(contextVNode),warn$1(`Unhandled error${info?` during execution of ${info}`:""}`),contextVNode&&popWarningContext(),throwInDev)throw err;console.error(err)}}function nextTick(fn){const p=currentFlushPromise||resolvedPromise;return fn?p.then(this?fn.bind(this):fn):p}function findInsertionIndex(id){let start=flushIndex+1,end=queue.length;for(;start<end;){const middle=start+end>>>1,middleJobId=getId(queue[middle]);middleJobId<id?start=middle+1:end=middle}return start}function queueJob(job){queue.length&&queue.includes(job,isFlushing&&job.allowRecurse?flushIndex+1:flushIndex)||job===currentPreFlushParentJob||(null==job.id?queue.push(job):queue.splice(findInsertionIndex(job.id),0,job),queueFlush())}function queueFlush(){isFlushing||isFlushPending||(isFlushPending=!0,currentFlushPromise=resolvedPromise.then(flushJobs))}function invalidateJob(job){const i=queue.indexOf(job);i>flushIndex&&queue.splice(i,1)}function queueCb(cb,activeQueue,pendingQueue,index){isArray(cb)?pendingQueue.push(...cb):activeQueue&&activeQueue.includes(cb,cb.allowRecurse?index+1:index)||pendingQueue.push(cb),queueFlush()}function queuePreFlushCb(cb){queueCb(cb,activePreFlushCbs,pendingPreFlushCbs,preFlushIndex)}function queuePostFlushCb(cb){queueCb(cb,activePostFlushCbs,pendingPostFlushCbs,postFlushIndex)}function flushPreFlushCbs(seen,parentJob=null){if(pendingPreFlushCbs.length){for(currentPreFlushParentJob=parentJob,activePreFlushCbs=[...new Set(pendingPreFlushCbs)],pendingPreFlushCbs.length=0,seen=seen||new Map,preFlushIndex=0;preFlushIndex<activePreFlushCbs.length;preFlushIndex++)checkRecursiveUpdates(seen,activePreFlushCbs[preFlushIndex])||activePreFlushCbs[preFlushIndex]();activePreFlushCbs=null,preFlushIndex=0,currentPreFlushParentJob=null,flushPreFlushCbs(seen,parentJob)}}function flushPostFlushCbs(seen){if(pendingPostFlushCbs.length){const deduped=[...new Set(pendingPostFlushCbs)];if(pendingPostFlushCbs.length=0,activePostFlushCbs)return void activePostFlushCbs.push(...deduped);for(activePostFlushCbs=deduped,seen=seen||new Map,activePostFlushCbs.sort((a,b)=>getId(a)-getId(b)),postFlushIndex=0;postFlushIndex<activePostFlushCbs.length;postFlushIndex++)checkRecursiveUpdates(seen,activePostFlushCbs[postFlushIndex])||activePostFlushCbs[postFlushIndex]();activePostFlushCbs=null,postFlushIndex=0}}function flushJobs(seen){isFlushPending=!1,isFlushing=!0,seen=seen||new Map,flushPreFlushCbs(seen),queue.sort((a,b)=>getId(a)-getId(b));const check=job=>checkRecursiveUpdates(seen,job);try{for(flushIndex=0;flushIndex<queue.length;flushIndex++){const job=queue[flushIndex];if(job&&!1!==job.active){if(check(job))continue;callWithErrorHandling(job,null,14)}}}finally{flushIndex=0,queue.length=0,flushPostFlushCbs(seen),isFlushing=!1,currentFlushPromise=null,(queue.length||pendingPreFlushCbs.length||pendingPostFlushCbs.length)&&flushJobs(seen)}}function checkRecursiveUpdates(seen,fn){if(seen.has(fn)){const count=seen.get(fn);if(count>RECURSION_LIMIT){const instance=fn.ownerInstance,componentName=instance&&getComponentName(instance.type);return warn$1(`Maximum recursive updates exceeded${componentName?` in component <${componentName}>`:""}. `+"This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function."),!0}seen.set(fn,count+1)}else seen.set(fn,1)}function registerHMR(instance){const id=instance.type.__hmrId;let record=map.get(id);record||(createRecord(id,instance.type),record=map.get(id)),record.instances.add(instance)}function unregisterHMR(instance){map.get(instance.type.__hmrId).instances.delete(instance)}function createRecord(id,initialDef){return!map.has(id)&&(map.set(id,{initialDef:normalizeClassComponent(initialDef),instances:new Set}),!0)}function normalizeClassComponent(component){return isClassComponent(component)?component.__vccOpts:component}function rerender(id,newRender){const record=map.get(id);record&&(record.initialDef.render=newRender,[...record.instances].forEach(instance=>{newRender&&(instance.render=newRender,normalizeClassComponent(instance.type).render=newRender),instance.renderCache=[],isHmrUpdating=!0,instance.update(),isHmrUpdating=!1}))}function reload(id,newComp){const record=map.get(id);if(!record)return;newComp=normalizeClassComponent(newComp),updateComponentDef(record.initialDef,newComp);const instances=[...record.instances];for(const instance of instances){const oldComp=normalizeClassComponent(instance.type);hmrDirtyComponents.has(oldComp)||(oldComp!==record.initialDef&&updateComponentDef(oldComp,newComp),hmrDirtyComponents.add(oldComp)),instance.appContext.optionsCache.delete(instance.type),instance.ceReload?(hmrDirtyComponents.add(oldComp),instance.ceReload(newComp.styles),hmrDirtyComponents.delete(oldComp)):instance.parent?(queueJob(instance.parent.update),instance.parent.type.__asyncLoader&&instance.parent.ceReload&&instance.parent.ceReload(newComp.styles)):instance.appContext.reload?instance.appContext.reload():"undefined"!=typeof window?window.location.reload():console.warn("[HMR] Root or manually mounted instance modified. Full reload required.")}queuePostFlushCb(()=>{for(const instance of instances)hmrDirtyComponents.delete(normalizeClassComponent(instance.type))})}function updateComponentDef(oldComp,newComp){extend(oldComp,newComp);for(const key in oldComp)"__file"===key||key in newComp||delete oldComp[key]}function tryWrap(fn){return(id,arg)=>{try{return fn(id,arg)}catch(e){console.error(e),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}}function emit(event,...args){exports.devtools?exports.devtools.emit(event,...args):devtoolsNotInstalled||buffer.push({event:event,args:args})}function setDevtoolsHook(hook,target){var _a,_b;if(exports.devtools=hook,exports.devtools)exports.devtools.enabled=!0,buffer.forEach(({event:event,args:args})=>exports.devtools.emit(event,...args)),buffer=[];else if("undefined"!=typeof window&&window.HTMLElement&&!(null===(_b=null===(_a=window.navigator)||void 0===_a?void 0:_a.userAgent)||void 0===_b?void 0:_b.includes("jsdom"))){const replay=target.__VUE_DEVTOOLS_HOOK_REPLAY__=target.__VUE_DEVTOOLS_HOOK_REPLAY__||[];replay.push(newHook=>{setDevtoolsHook(newHook,target)}),setTimeout(()=>{exports.devtools||(target.__VUE_DEVTOOLS_HOOK_REPLAY__=null,devtoolsNotInstalled=!0,buffer=[])},3e3)}else devtoolsNotInstalled=!0,buffer=[]}function devtoolsInitApp(app,version){emit("app:init",app,version,{Fragment:Fragment,Text:Text,Comment:Comment,Static:Static})}function devtoolsUnmountApp(app){emit("app:unmount",app)}function createDevtoolsComponentHook(hook){return component=>{emit(hook,component.appContext.app,component.uid,component.parent?component.parent.uid:void 0,component)}}function createDevtoolsPerformanceHook(hook){return(component,type,time)=>{emit(hook,component.appContext.app,component.uid,component,type,time)}}function devtoolsComponentEmit(component,event,params){emit("component:emit",component.appContext.app,component,event,params)}function emit$1(instance,event,...rawArgs){if(instance.isUnmounted)return;const props=instance.vnode.props||EMPTY_OBJ;{const{emitsOptions:emitsOptions,propsOptions:[propsOptions]}=instance;if(emitsOptions)if(event in emitsOptions){const validator=emitsOptions[event];if(isFunction(validator)){const isValid=validator(...rawArgs);isValid||warn$1(`Invalid event arguments: event validation failed for event "${event}".`)}}else propsOptions&&toHandlerKey(event)in propsOptions||warn$1(`Component emitted event "${event}" but it is neither declared in `+`the emits option nor as an "${toHandlerKey(event)}" prop.`)}let args=rawArgs;const isModelListener=event.startsWith("update:"),modelArg=isModelListener&&event.slice(7);if(modelArg&&modelArg in props){const modifiersKey=`${"modelValue"===modelArg?"model":modelArg}Modifiers`,{number:number,trim:trim}=props[modifiersKey]||EMPTY_OBJ;trim?args=rawArgs.map(a=>a.trim()):number&&(args=rawArgs.map(toNumber))}devtoolsComponentEmit(instance,event,args);{const lowerCaseEvent=event.toLowerCase();lowerCaseEvent!==event&&props[toHandlerKey(lowerCaseEvent)]&&warn$1(`Event "${lowerCaseEvent}" is emitted in component `+`${formatComponentName(instance,instance.type)} but the handler is registered for "${event}". `+"Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. "+`You should probably use "${hyphenate(event)}" instead of "${event}".`)}let handlerName,handler=props[handlerName=toHandlerKey(event)]||props[handlerName=toHandlerKey(camelize(event))];!handler&&isModelListener&&(handler=props[handlerName=toHandlerKey(hyphenate(event))]),handler&&callWithAsyncErrorHandling(handler,instance,6,args);const onceHandler=props[handlerName+"Once"];if(onceHandler){if(instance.emitted){if(instance.emitted[handlerName])return}else instance.emitted={};instance.emitted[handlerName]=!0,callWithAsyncErrorHandling(onceHandler,instance,6,args)}}function normalizeEmitsOptions(comp,appContext,asMixin=!1){const cache=appContext.emitsCache,cached=cache.get(comp);if(void 0!==cached)return cached;const raw=comp.emits;let normalized={},hasExtends=!1;if(!isFunction(comp)){const extendEmits=raw=>{const normalizedFromExtend=normalizeEmitsOptions(raw,appContext,!0);normalizedFromExtend&&(hasExtends=!0,extend(normalized,normalizedFromExtend))};!asMixin&&appContext.mixins.length&&appContext.mixins.forEach(extendEmits),comp.extends&&extendEmits(comp.extends),comp.mixins&&comp.mixins.forEach(extendEmits)}return raw||hasExtends?(isArray(raw)?raw.forEach(key=>normalized[key]=null):extend(normalized,raw),cache.set(comp,normalized),normalized):(cache.set(comp,null),null)}function isEmitListener(options,key){return!(!options||!isOn(key))&&(key=key.slice(2).replace(/Once$/,""),hasOwn(options,key[0].toLowerCase()+key.slice(1))||hasOwn(options,hyphenate(key))||hasOwn(options,key))}function setCurrentRenderingInstance(instance){const prev=currentRenderingInstance;return currentRenderingInstance=instance,currentScopeId=instance&&instance.type.__scopeId||null,prev}function pushScopeId(id){currentScopeId=id}function popScopeId(){currentScopeId=null}function withCtx(fn,ctx=currentRenderingInstance,isNonScopedSlot){if(!ctx)return fn;if(fn._n)return fn;const renderFnWithContext=(...args)=>{renderFnWithContext._d&&setBlockTracking(-1);const prevInstance=setCurrentRenderingInstance(ctx),res=fn(...args);return setCurrentRenderingInstance(prevInstance),renderFnWithContext._d&&setBlockTracking(1),devtoolsComponentUpdated(ctx),res}
;return renderFnWithContext._n=!0,renderFnWithContext._c=!0,renderFnWithContext._d=!0,renderFnWithContext}function markAttrsAccessed(){accessedAttrs=!0}function renderComponentRoot(instance){const{type:Component,vnode:vnode,proxy:proxy,withProxy:withProxy,props:props,propsOptions:[propsOptions],slots:slots,attrs:attrs,emit:emit,render:render,renderCache:renderCache,data:data,setupState:setupState,ctx:ctx,inheritAttrs:inheritAttrs}=instance;let result,fallthroughAttrs;const prev=setCurrentRenderingInstance(instance);accessedAttrs=!1;try{if(4&vnode.shapeFlag){const proxyToUse=withProxy||proxy;result=normalizeVNode(render.call(proxyToUse,proxyToUse,renderCache,props,setupState,data,ctx)),fallthroughAttrs=attrs}else{const render=Component;attrs===props&&markAttrsAccessed(),result=normalizeVNode(render.length>1?render(props,{get attrs(){return markAttrsAccessed(),attrs},slots:slots,emit:emit}):render(props,null)),fallthroughAttrs=Component.props?attrs:getFunctionalFallthrough(attrs)}}catch(err){blockStack.length=0,handleError(err,instance,1),result=createVNode(Comment)}let root=result,setRoot=void 0;if(result.patchFlag>0&&2048&result.patchFlag&&([root,setRoot]=getChildRoot(result)),fallthroughAttrs&&!1!==inheritAttrs){const keys=Object.keys(fallthroughAttrs),{shapeFlag:shapeFlag}=root;if(keys.length)if(7&shapeFlag)propsOptions&&keys.some(isModelListener)&&(fallthroughAttrs=filterModelListeners(fallthroughAttrs,propsOptions)),root=cloneVNode(root,fallthroughAttrs);else if(!accessedAttrs&&root.type!==Comment){const allAttrs=Object.keys(attrs),eventAttrs=[],extraAttrs=[];for(let i=0,l=allAttrs.length;i<l;i++){const key=allAttrs[i];isOn(key)?isModelListener(key)||eventAttrs.push(key[2].toLowerCase()+key.slice(3)):extraAttrs.push(key)}extraAttrs.length&&warn$1("Extraneous non-props attributes ("+`${extraAttrs.join(", ")}) `+"were passed to component but could not be automatically inherited because component renders fragment or text root nodes."),eventAttrs.length&&warn$1("Extraneous non-emits event listeners ("+`${eventAttrs.join(", ")}) `+'were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.')}}return vnode.dirs&&(isElementRoot(root)||warn$1("Runtime directive used on component with non-element root node. The directives will not function as intended."),root.dirs=root.dirs?root.dirs.concat(vnode.dirs):vnode.dirs),vnode.transition&&(isElementRoot(root)||warn$1("Component inside <Transition> renders non-element root node that cannot be animated."),root.transition=vnode.transition),setRoot?setRoot(root):result=root,setCurrentRenderingInstance(prev),result}function filterSingleRoot(children){let singleRoot;for(let i=0;i<children.length;i++){const child=children[i];if(!isVNode(child))return;if(child.type!==Comment||"v-if"===child.children){if(singleRoot)return;singleRoot=child}}return singleRoot}function shouldUpdateComponent(prevVNode,nextVNode,optimized){const{props:prevProps,children:prevChildren,component:component}=prevVNode,{props:nextProps,children:nextChildren,patchFlag:patchFlag}=nextVNode,emits=component.emitsOptions;if((prevChildren||nextChildren)&&isHmrUpdating)return!0;if(nextVNode.dirs||nextVNode.transition)return!0;if(!(optimized&&patchFlag>=0))return!(!prevChildren&&!nextChildren||nextChildren&&nextChildren.$stable)||prevProps!==nextProps&&(prevProps?!nextProps||hasPropsChanged(prevProps,nextProps,emits):!!nextProps);if(1024&patchFlag)return!0;if(16&patchFlag)return prevProps?hasPropsChanged(prevProps,nextProps,emits):!!nextProps;if(8&patchFlag){const dynamicProps=nextVNode.dynamicProps;for(let i=0;i<dynamicProps.length;i++){const key=dynamicProps[i];if(nextProps[key]!==prevProps[key]&&!isEmitListener(emits,key))return!0}}return!1}function hasPropsChanged(prevProps,nextProps,emitsOptions){const nextKeys=Object.keys(nextProps);if(nextKeys.length!==Object.keys(prevProps).length)return!0;for(let i=0;i<nextKeys.length;i++){const key=nextKeys[i];if(nextProps[key]!==prevProps[key]&&!isEmitListener(emitsOptions,key))return!0}return!1}function updateHOCHostEl({vnode:vnode,parent:parent},el){for(;parent&&parent.subTree===vnode;)(vnode=parent.vnode).el=el,parent=parent.parent}function triggerEvent(vnode,name){const eventListener=vnode.props&&vnode.props[name];isFunction(eventListener)&&eventListener()}function mountSuspense(vnode,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,rendererInternals){const{p:patch,o:{createElement:createElement}}=rendererInternals,hiddenContainer=createElement("div"),suspense=vnode.suspense=createSuspenseBoundary(vnode,parentSuspense,parentComponent,container,hiddenContainer,anchor,isSVG,slotScopeIds,optimized,rendererInternals);patch(null,suspense.pendingBranch=vnode.ssContent,hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds),suspense.deps>0?(triggerEvent(vnode,"onPending"),triggerEvent(vnode,"onFallback"),patch(null,vnode.ssFallback,container,anchor,parentComponent,null,isSVG,slotScopeIds),setActiveBranch(suspense,vnode.ssFallback)):suspense.resolve()}function patchSuspense(n1,n2,container,anchor,parentComponent,isSVG,slotScopeIds,optimized,{p:patch,um:unmount,o:{createElement:createElement}}){const suspense=n2.suspense=n1.suspense;suspense.vnode=n2,n2.el=n1.el;const newBranch=n2.ssContent,newFallback=n2.ssFallback,{activeBranch:activeBranch,pendingBranch:pendingBranch,isInFallback:isInFallback,isHydrating:isHydrating}=suspense;if(pendingBranch)suspense.pendingBranch=newBranch,isSameVNodeType(newBranch,pendingBranch)?(patch(pendingBranch,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized),suspense.deps<=0?suspense.resolve():isInFallback&&(patch(activeBranch,newFallback,container,anchor,parentComponent,null,isSVG,slotScopeIds,optimized),setActiveBranch(suspense,newFallback))):(suspense.pendingId++,isHydrating?(suspense.isHydrating=!1,suspense.activeBranch=pendingBranch):unmount(pendingBranch,parentComponent,suspense),suspense.deps=0,suspense.effects.length=0,suspense.hiddenContainer=createElement("div"),isInFallback?(patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized),suspense.deps<=0?suspense.resolve():(patch(activeBranch,newFallback,container,anchor,parentComponent,null,isSVG,slotScopeIds,optimized),setActiveBranch(suspense,newFallback))):activeBranch&&isSameVNodeType(newBranch,activeBranch)?(patch(activeBranch,newBranch,container,anchor,parentComponent,suspense,isSVG,slotScopeIds,optimized),suspense.resolve(!0)):(patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized),suspense.deps<=0&&suspense.resolve()));else if(activeBranch&&isSameVNodeType(newBranch,activeBranch))patch(activeBranch,newBranch,container,anchor,parentComponent,suspense,isSVG,slotScopeIds,optimized),setActiveBranch(suspense,newBranch);else if(triggerEvent(n2,"onPending"),suspense.pendingBranch=newBranch,suspense.pendingId++,patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized),suspense.deps<=0)suspense.resolve();else{const{timeout:timeout,pendingId:pendingId}=suspense;timeout>0?setTimeout(()=>{suspense.pendingId===pendingId&&suspense.fallback(newFallback)},timeout):0===timeout&&suspense.fallback(newFallback)}}function createSuspenseBoundary(vnode,parent,parentComponent,container,hiddenContainer,anchor,isSVG,slotScopeIds,optimized,rendererInternals,isHydrating=!1){hasWarned||(hasWarned=!0,console[console.info?"info":"log"]("<Suspense> is an experimental feature and its API will likely change."));const{p:patch,m:move,um:unmount,n:next,o:{parentNode:parentNode,remove:remove}}=rendererInternals,timeout=toNumber(vnode.props&&vnode.props.timeout),suspense={vnode:vnode,parent:parent,parentComponent:parentComponent,isSVG:isSVG,container:container,hiddenContainer:hiddenContainer,anchor:anchor,deps:0,pendingId:0,timeout:"number"==typeof timeout?timeout:-1,activeBranch:null,pendingBranch:null,isInFallback:!0,isHydrating:isHydrating,isUnmounted:!1,effects:[],resolve(resume=!1){if(!resume&&!suspense.pendingBranch)throw new Error("suspense.resolve() is called without a pending branch.");if(suspense.isUnmounted)throw new Error("suspense.resolve() is called on an already unmounted suspense boundary.");const{vnode:vnode,activeBranch:activeBranch,pendingBranch:pendingBranch,pendingId:pendingId,effects:effects,parentComponent:parentComponent,container:container}=suspense;if(suspense.isHydrating)suspense.isHydrating=!1;else if(!resume){const delayEnter=activeBranch&&pendingBranch.transition&&"out-in"===pendingBranch.transition.mode;delayEnter&&(activeBranch.transition.afterLeave=(()=>{pendingId===suspense.pendingId&&move(pendingBranch,container,anchor,0)}));let{anchor:anchor}=suspense;activeBranch&&(anchor=next(activeBranch),unmount(activeBranch,parentComponent,suspense,!0)),delayEnter||move(pendingBranch,container,anchor,0)}setActiveBranch(suspense,pendingBranch),suspense.pendingBranch=null,suspense.isInFallback=!1;let parent=suspense.parent,hasUnresolvedAncestor=!1;for(;parent;){if(parent.pendingBranch){parent.effects.push(...effects),hasUnresolvedAncestor=!0;break}parent=parent.parent}hasUnresolvedAncestor||queuePostFlushCb(effects),suspense.effects=[],triggerEvent(vnode,"onResolve")},fallback(fallbackVNode){if(!suspense.pendingBranch)return;const{vnode:vnode,activeBranch:activeBranch,parentComponent:parentComponent,container:container,isSVG:isSVG}=suspense;triggerEvent(vnode,"onFallback");const anchor=next(activeBranch),mountFallback=()=>{suspense.isInFallback&&(patch(null,fallbackVNode,container,anchor,parentComponent,null,isSVG,slotScopeIds,optimized),setActiveBranch(suspense,fallbackVNode))},delayEnter=fallbackVNode.transition&&"out-in"===fallbackVNode.transition.mode;delayEnter&&(activeBranch.transition.afterLeave=mountFallback),suspense.isInFallback=!0,unmount(activeBranch,parentComponent,null,!0),delayEnter||mountFallback()},move(container,anchor,type){suspense.activeBranch&&move(suspense.activeBranch,container,anchor,type),suspense.container=container},next:()=>suspense.activeBranch&&next(suspense.activeBranch),registerDep(instance,setupRenderEffect){const isInPendingSuspense=!!suspense.pendingBranch;isInPendingSuspense&&suspense.deps++;const hydratedEl=instance.vnode.el;instance.asyncDep.catch(err=>{handleError(err,instance,0)}).then(asyncSetupResult=>{if(instance.isUnmounted||suspense.isUnmounted||suspense.pendingId!==instance.suspenseId)return;instance.asyncResolved=!0;const{vnode:vnode}=instance;pushWarningContext(vnode),handleSetupResult(instance,asyncSetupResult,!1),hydratedEl&&(vnode.el=hydratedEl);const placeholder=!hydratedEl&&instance.subTree.el;setupRenderEffect(instance,vnode,parentNode(hydratedEl||instance.subTree.el),hydratedEl?null:next(instance.subTree),suspense,isSVG,optimized),placeholder&&remove(placeholder),updateHOCHostEl(instance,vnode.el),popWarningContext(),isInPendingSuspense&&0==--suspense.deps&&suspense.resolve()})},unmount(parentSuspense,doRemove){suspense.isUnmounted=!0,suspense.activeBranch&&unmount(suspense.activeBranch,parentComponent,parentSuspense,doRemove),suspense.pendingBranch&&unmount(suspense.pendingBranch,parentComponent,parentSuspense,doRemove)}};return suspense}function hydrateSuspense(node,vnode,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,rendererInternals,hydrateNode){const suspense=vnode.suspense=createSuspenseBoundary(vnode,parentSuspense,parentComponent,node.parentNode,document.createElement("div"),null,isSVG,slotScopeIds,optimized,rendererInternals,!0),result=hydrateNode(node,suspense.pendingBranch=vnode.ssContent,parentComponent,suspense,slotScopeIds,optimized);return 0===suspense.deps&&suspense.resolve(),result}function normalizeSuspenseChildren(vnode){const{shapeFlag:shapeFlag,children:children}=vnode,isSlotChildren=32&shapeFlag;vnode.ssContent=normalizeSuspenseSlot(isSlotChildren?children.default:children),vnode.ssFallback=isSlotChildren?normalizeSuspenseSlot(children.fallback):createVNode(Comment)}function normalizeSuspenseSlot(s){let block;if(isFunction(s)){const trackBlock=isBlockTreeEnabled&&s._c;trackBlock&&(s._d=!1,openBlock()),s=s(),trackBlock&&(s._d=!0,block=currentBlock,closeBlock())}if(isArray(s)){const singleChild=filterSingleRoot(s);singleChild||warn$1("<Suspense> slots expect a single root node."),s=singleChild}return s=normalizeVNode(s),block&&!s.dynamicChildren&&(s.dynamicChildren=block.filter(c=>c!==s)),s}function queueEffectWithSuspense(fn,suspense){suspense&&suspense.pendingBranch?isArray(fn)?suspense.effects.push(...fn):suspense.effects.push(fn):queuePostFlushCb(fn)}function setActiveBranch(suspense,branch){suspense.activeBranch=branch;const{vnode:vnode,parentComponent:parentComponent}=suspense,el=vnode.el=branch.el;parentComponent&&parentComponent.subTree===vnode&&(parentComponent.vnode.el=el,updateHOCHostEl(parentComponent,el))}function provide(key,value){if(currentInstance){let provides=currentInstance.provides;const parentProvides=currentInstance.parent&&currentInstance.parent.provides;parentProvides===provides&&(provides=currentInstance.provides=Object.create(parentProvides)),provides[key]=value}else warn$1("provide() can only be used inside setup().")}function inject(key,defaultValue,treatDefaultAsFactory=!1){const instance=currentInstance||currentRenderingInstance;if(instance){const provides=null==instance.parent?instance.vnode.appContext&&instance.vnode.appContext.provides:instance.parent.provides;if(provides&&key in provides)return provides[key];if(arguments.length>1)return treatDefaultAsFactory&&isFunction(defaultValue)?defaultValue.call(instance.proxy):defaultValue;warn$1(`injection "${String(key)}" not found.`)}else warn$1("inject() can only be used inside setup() or functional components.")}function watchEffect(effect,options){return doWatch(effect,null,options)}function watchPostEffect(effect,options){return doWatch(effect,null,Object.assign(Object.assign({},options),{flush:"post"}))}function watchSyncEffect(effect,options){return doWatch(effect,null,Object.assign(Object.assign({},options),{flush:"sync"}))}function watch(source,cb,options){return isFunction(cb)||warn$1("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."),doWatch(source,cb,options)}function doWatch(source,cb,{immediate:immediate,deep:deep,flush:flush,onTrack:onTrack,onTrigger:onTrigger}=EMPTY_OBJ){cb||(void 0!==immediate&&warn$1('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'),void 0!==deep&&warn$1('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));const warnInvalidSource=s=>{warn$1("Invalid watch source: ",s,"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")},instance=currentInstance;let getter,cleanup,forceTrigger=!1,isMultiSource=!1;if(isRef(source)?(getter=(()=>source.value),forceTrigger=isShallow(source)):isReactive(source)?(getter=(()=>source),deep=!0):isArray(source)?(isMultiSource=!0,forceTrigger=source.some(isReactive),getter=(()=>source.map(s=>isRef(s)?s.value:isReactive(s)?traverse(s):isFunction(s)?callWithErrorHandling(s,instance,2):void warnInvalidSource(s)))):isFunction(source)?getter=cb?()=>callWithErrorHandling(source,instance,2):()=>{if(!instance||!instance.isUnmounted)return cleanup&&cleanup(),callWithAsyncErrorHandling(source,instance,3,[onCleanup])}:(getter=NOOP,warnInvalidSource(source)),cb&&deep){const baseGetter=getter;getter=(()=>traverse(baseGetter()))}let onCleanup=fn=>{cleanup=effect.onStop=(()=>{callWithErrorHandling(fn,instance,4)})},oldValue=isMultiSource?[]:INITIAL_WATCHER_VALUE;const job=()=>{if(effect.active)if(cb){const newValue=effect.run();(deep||forceTrigger||(isMultiSource?newValue.some((v,i)=>hasChanged(v,oldValue[i])):hasChanged(newValue,oldValue)))&&(cleanup&&cleanup(),callWithAsyncErrorHandling(cb,instance,3,[newValue,oldValue===INITIAL_WATCHER_VALUE?void 0:oldValue,onCleanup]),oldValue=newValue)}else effect.run()};let scheduler;job.allowRecurse=!!cb,scheduler="sync"===flush?job:"post"===flush?()=>queuePostRenderEffect(job,instance&&instance.suspense):()=>{!instance||instance.isMounted?queuePreFlushCb(job):job()};const effect=new ReactiveEffect(getter,scheduler);return effect.onTrack=onTrack,effect.onTrigger=onTrigger,cb?immediate?job():oldValue=effect.run():"post"===flush?queuePostRenderEffect(effect.run.bind(effect),instance&&instance.suspense):effect.run(),()=>{effect.stop(),instance&&instance.scope&&remove(instance.scope.effects,effect)}}function instanceWatch(source,value,options){const publicThis=this.proxy,getter=isString(source)?source.includes(".")?createPathGetter(publicThis,source):()=>publicThis[source]:source.bind(publicThis,publicThis);let cb;isFunction(value)?cb=value:(cb=value.handler,options=value);const cur=currentInstance;setCurrentInstance(this);const res=doWatch(getter,cb.bind(publicThis),options);return cur?setCurrentInstance(cur):unsetCurrentInstance(),res}function createPathGetter(ctx,path){const segments=path.split(".");return()=>{let cur=ctx;for(let i=0;i<segments.length&&cur;i++)cur=cur[segments[i]];return cur}}function traverse(value,seen){if(!isObject(value)||value.__v_skip)return value;if(seen=seen||new Set,seen.has(value))return value;if(seen.add(value),isRef(value))traverse(value.value,seen);else if(isArray(value))for(let i=0;i<value.length;i++)traverse(value[i],seen);else if(isSet(value)||isMap(value))value.forEach(v=>{traverse(v,seen)});else if(isPlainObject(value))for(const key in value)traverse(value[key],seen);return value}function useTransitionState(){const state={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return onMounted(()=>{state.isMounted=!0}),onBeforeUnmount(()=>{state.isUnmounting=!0}),state}function getLeavingNodesForType(state,vnode){const{leavingVNodes:leavingVNodes}=state;let leavingVNodesCache=leavingVNodes.get(vnode.type);return leavingVNodesCache||(leavingVNodesCache=Object.create(null),leavingVNodes.set(vnode.type,leavingVNodesCache)),leavingVNodesCache}function resolveTransitionHooks(vnode,props,state,instance){const{appear:appear,mode:mode,persisted:persisted=!1,onBeforeEnter:onBeforeEnter,onEnter:onEnter,onAfterEnter:onAfterEnter,onEnterCancelled:onEnterCancelled,onBeforeLeave:onBeforeLeave,onLeave:onLeave,onAfterLeave:onAfterLeave,onLeaveCancelled:onLeaveCancelled,onBeforeAppear:onBeforeAppear,onAppear:onAppear,onAfterAppear:onAfterAppear,onAppearCancelled:onAppearCancelled}=props,key=String(vnode.key),leavingVNodesCache=getLeavingNodesForType(state,vnode),callHook=(hook,args)=>{hook&&callWithAsyncErrorHandling(hook,instance,9,args)},hooks={mode:mode,persisted:persisted,beforeEnter(el){let hook=onBeforeEnter;if(!state.isMounted){if(!appear)return;hook=onBeforeAppear||onBeforeEnter}el._leaveCb&&el._leaveCb(!0);const leavingVNode=leavingVNodesCache[key];leavingVNode&&isSameVNodeType(vnode,leavingVNode)&&leavingVNode.el._leaveCb&&leavingVNode.el._leaveCb(),callHook(hook,[el])},enter(el){let hook=onEnter,afterHook=onAfterEnter,cancelHook=onEnterCancelled;if(!state.isMounted){if(!appear)return;hook=onAppear||onEnter,afterHook=onAfterAppear||onAfterEnter,cancelHook=onAppearCancelled||onEnterCancelled}let called=!1;const done=el._enterCb=(cancelled=>{called||(called=!0,callHook(cancelled?cancelHook:afterHook,[el]),hooks.delayedLeave&&hooks.delayedLeave(),el._enterCb=void 0)});hook?(hook(el,done),hook.length<=1&&done()):done()},leave(el,remove){const key=String(vnode.key);if(el._enterCb&&el._enterCb(!0),state.isUnmounting)return remove();callHook(onBeforeLeave,[el]);let called=!1;const done=el._leaveCb=(cancelled=>{called||(called=!0,remove(),callHook(cancelled?onLeaveCancelled:onAfterLeave,[el]),el._leaveCb=void 0,leavingVNodesCache[key]===vnode&&delete leavingVNodesCache[key])});leavingVNodesCache[key]=vnode,onLeave?(onLeave(el,done),onLeave.length<=1&&done()):done()},clone:vnode=>resolveTransitionHooks(vnode,props,state,instance)};return hooks}function emptyPlaceholder(vnode){if(isKeepAlive(vnode))return vnode=cloneVNode(vnode),vnode.children=null,vnode}function getKeepAliveChild(vnode){return isKeepAlive(vnode)?vnode.children?vnode.children[0]:void 0:vnode}function setTransitionHooks(vnode,hooks){6&vnode.shapeFlag&&vnode.component?setTransitionHooks(vnode.component.subTree,hooks):128&vnode.shapeFlag?(vnode.ssContent.transition=hooks.clone(vnode.ssContent),vnode.ssFallback.transition=hooks.clone(vnode.ssFallback)):vnode.transition=hooks}function getTransitionRawChildren(children,keepComment=!1,parentKey){let ret=[],keyedFragmentCount=0;for(let i=0;i<children.length;i++){let child=children[i];const key=null==parentKey?child.key:String(parentKey)+String(null!=child.key?child.key:i);child.type===Fragment?(128&child.patchFlag&&keyedFragmentCount++,ret=ret.concat(getTransitionRawChildren(child.children,keepComment,key))):(keepComment||child.type!==Comment)&&ret.push(null!=key?cloneVNode(child,{key:key}):child)}if(keyedFragmentCount>1)for(let i=0;i<ret.length;i++)ret[i].patchFlag=-2;return ret}function defineComponent(options){return isFunction(options)?{setup:options,name:options.name}:options}function defineAsyncComponent(source){isFunction(source)&&(source={loader:source});const{loader:loader,loadingComponent:loadingComponent,errorComponent:errorComponent,delay:delay=200,timeout:timeout,suspensible:suspensible=!0,onError:userOnError}=source;let resolvedComp,pendingRequest=null,retries=0;const retry=()=>(retries++,pendingRequest=null,load()),load=()=>{let thisRequest;return pendingRequest||(thisRequest=pendingRequest=loader().catch(err=>{if(err=err instanceof Error?err:new Error(String(err)),userOnError)return new Promise((resolve,reject)=>{const userRetry=()=>resolve(retry()),userFail=()=>reject(err);userOnError(err,userRetry,userFail,retries+1)});throw err}).then(comp=>{if(thisRequest!==pendingRequest&&pendingRequest)return pendingRequest;if(comp||warn$1("Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."),comp&&(comp.__esModule||"Module"===comp[Symbol.toStringTag])&&(comp=comp.default),comp&&!isObject(comp)&&!isFunction(comp))throw new Error(`Invalid async component load result: ${comp}`);return resolvedComp=comp,comp}))};return defineComponent({name:"AsyncComponentWrapper",__asyncLoader:load,get __asyncResolved(){return resolvedComp},setup(){const instance=currentInstance;if(resolvedComp)return()=>createInnerComp(resolvedComp,instance);const onError=err=>{pendingRequest=null,handleError(err,instance,13,!errorComponent)};if(suspensible&&instance.suspense)return load().then(comp=>()=>createInnerComp(comp,instance)).catch(err=>(onError(err),()=>errorComponent?createVNode(errorComponent,{error:err}):null));const loaded=ref(!1),error=ref(),delayed=ref(!!delay);return delay&&setTimeout(()=>{delayed.value=!1},delay),null!=timeout&&setTimeout(()=>{if(!loaded.value&&!error.value){const err=new Error(`Async component timed out after ${timeout}ms.`);onError(err),error.value=err}},timeout),load().then(()=>{loaded.value=!0,instance.parent&&isKeepAlive(instance.parent.vnode)&&queueJob(instance.parent.update)}).catch(err=>{onError(err),error.value=err}),()=>loaded.value&&resolvedComp?createInnerComp(resolvedComp,instance):error.value&&errorComponent?createVNode(errorComponent,{error:error.value}):loadingComponent&&!delayed.value?createVNode(loadingComponent):void 0}})}function createInnerComp(comp,{vnode:{ref:ref,props:props,children:children}}){const vnode=createVNode(comp,props,children);return vnode.ref=ref,vnode}function matches(pattern,name){return isArray(pattern)?pattern.some(p=>matches(p,name)):isString(pattern)?pattern.split(",").includes(name):!!pattern.test&&pattern.test(name)}function onActivated(hook,target){registerKeepAliveHook(hook,"a",target)}function onDeactivated(hook,target){registerKeepAliveHook(hook,"da",target)}function registerKeepAliveHook(hook,type,target=currentInstance){const wrappedHook=hook.__wdc||(hook.__wdc=(()=>{let current=target;for(;current;){if(current.isDeactivated)return;current=current.parent}return hook()}));if(injectHook(type,wrappedHook,target),target){let current=target.parent;for(;current&&current.parent;)isKeepAlive(current.parent.vnode)&&injectToKeepAliveRoot(wrappedHook,type,target,current),current=current.parent}}function injectToKeepAliveRoot(hook,type,target,keepAliveRoot){const injected=injectHook(type,hook,keepAliveRoot,!0);onUnmounted(()=>{remove(keepAliveRoot[type],injected)},target)}function resetShapeFlag(vnode){let shapeFlag=vnode.shapeFlag;256&shapeFlag&&(shapeFlag-=256),512&shapeFlag&&(shapeFlag-=512),vnode.shapeFlag=shapeFlag}function getInnerChild(vnode){return 128&vnode.shapeFlag?vnode.ssContent:vnode}function injectHook(type,hook,target=currentInstance,prepend=!1){if(target){const hooks=target[type]||(target[type]=[]),wrappedHook=hook.__weh||(hook.__weh=((...args)=>{if(target.isUnmounted)return;pauseTracking(),setCurrentInstance(target);const res=callWithAsyncErrorHandling(hook,target,type,args);return unsetCurrentInstance(),resetTracking(),res}));return prepend?hooks.unshift(wrappedHook):hooks.push(wrappedHook),wrappedHook}{const apiName=toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/,""));warn$1(`${apiName} is called when there is no active component instance to be `+"associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.")}}function onErrorCaptured(hook,target=currentInstance){injectHook("ec",hook,target)}function createDuplicateChecker(){const cache=Object.create(null);return(type,key)=>{cache[key]?warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`):cache[key]=type}}function applyOptions(instance){function registerLifecycleHook(register,hook){isArray(hook)?hook.forEach(_hook=>register(_hook.bind(publicThis))):hook&&register(hook.bind(publicThis))}const options=resolveMergedOptions(instance),publicThis=instance.proxy,ctx=instance.ctx;shouldCacheAccess=!1,options.beforeCreate&&callHook(options.beforeCreate,instance,"bc");const{data:dataOptions,computed:computedOptions,methods:methods,watch:watchOptions,provide:provideOptions,inject:injectOptions,created:created,beforeMount:beforeMount,mounted:mounted,beforeUpdate:beforeUpdate,updated:updated,activated:activated,deactivated:deactivated,beforeDestroy:beforeDestroy,beforeUnmount:beforeUnmount,destroyed:destroyed,unmounted:unmounted,render:render,renderTracked:renderTracked,renderTriggered:renderTriggered,errorCaptured:errorCaptured,serverPrefetch:serverPrefetch,expose:expose,inheritAttrs:inheritAttrs,components:components,directives:directives,filters:filters}=options,checkDuplicateProperties=createDuplicateChecker();{const[propsOptions]=instance.propsOptions;if(propsOptions)for(const key in propsOptions)checkDuplicateProperties("Props",key)}if(injectOptions&&resolveInjections(injectOptions,ctx,checkDuplicateProperties,instance.appContext.config.unwrapInjectedRef),methods)for(const key in methods){const methodHandler=methods[key];isFunction(methodHandler)?(Object.defineProperty(ctx,key,{value:methodHandler.bind(publicThis),configurable:!0,enumerable:!0,writable:!0}),checkDuplicateProperties("Methods",key)):warn$1(`Method "${key}" has type "${typeof methodHandler}" in the component definition. `+"Did you reference the function correctly?")}if(dataOptions){isFunction(dataOptions)||warn$1("The data option must be a function. Plain object usage is no longer supported.");const data=dataOptions.call(publicThis,publicThis);if(isPromise(data)&&warn$1("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."),isObject(data)){instance.data=reactive(data);for(const key in data)checkDuplicateProperties("Data",key),"$"!==key[0]&&"_"!==key[0]&&Object.defineProperty(ctx,key,{configurable:!0,enumerable:!0,get:()=>data[key],set:NOOP})}else warn$1("data() should return an object.")}if(shouldCacheAccess=!0,computedOptions)for(const key in computedOptions){const opt=computedOptions[key],get=isFunction(opt)?opt.bind(publicThis,publicThis):isFunction(opt.get)?opt.get.bind(publicThis,publicThis):NOOP;get===NOOP&&warn$1(`Computed property "${key}" has no getter.`);const set=!isFunction(opt)&&isFunction(opt.set)?opt.set.bind(publicThis):()=>{warn$1(`Write operation failed: computed property "${key}" is readonly.`)},c=computed$1({get:get,set:set});Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,get:()=>c.value,set:v=>c.value=v}),checkDuplicateProperties("Computed",key)}if(watchOptions)for(const key in watchOptions)createWatcher(watchOptions[key],ctx,publicThis,key);if(provideOptions){const provides=isFunction(provideOptions)?provideOptions.call(publicThis):provideOptions;Reflect.ownKeys(provides).forEach(key=>{provide(key,provides[key])})}if(created&&callHook(created,instance,"c"),registerLifecycleHook(onBeforeMount,beforeMount),registerLifecycleHook(onMounted,mounted),registerLifecycleHook(onBeforeUpdate,beforeUpdate),registerLifecycleHook(onUpdated,updated),registerLifecycleHook(onActivated,activated),registerLifecycleHook(onDeactivated,deactivated),registerLifecycleHook(onErrorCaptured,errorCaptured),registerLifecycleHook(onRenderTracked,renderTracked),registerLifecycleHook(onRenderTriggered,renderTriggered),registerLifecycleHook(onBeforeUnmount,beforeUnmount),registerLifecycleHook(onUnmounted,unmounted),registerLifecycleHook(onServerPrefetch,serverPrefetch),isArray(expose))if(expose.length){const exposed=instance.exposed||(instance.exposed={});expose.forEach(key=>{Object.defineProperty(exposed,key,{get:()=>publicThis[key],set:val=>publicThis[key]=val})})}else instance.exposed||(instance.exposed={});render&&instance.render===NOOP&&(instance.render=render),null!=inheritAttrs&&(instance.inheritAttrs=inheritAttrs),components&&(instance.components=components),directives&&(instance.directives=directives)}function resolveInjections(injectOptions,ctx,checkDuplicateProperties=NOOP,unwrapRef=!1){isArray(injectOptions)&&(injectOptions=normalizeInject(injectOptions));for(const key in injectOptions){const opt=injectOptions[key];let injected;injected=isObject(opt)?"default"in opt?inject(opt.from||key,opt.default,!0):inject(opt.from||key):inject(opt),isRef(injected)?unwrapRef?Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,get:()=>injected.value,set:v=>injected.value=v}):(warn$1(`injected property "${key}" is a ref and will be auto-unwrapped `+"and no longer needs `.value` in the next minor release. To opt-in to the new behavior now, set `app.config.unwrapInjectedRef = true` (this config is temporary and will not be needed in the future.)"),ctx[key]=injected):ctx[key]=injected,checkDuplicateProperties("Inject",key)}}function callHook(hook,instance,type){callWithAsyncErrorHandling(isArray(hook)?hook.map(h=>h.bind(instance.proxy)):hook.bind(instance.proxy),instance,type)}function createWatcher(raw,ctx,publicThis,key){const getter=key.includes(".")?createPathGetter(publicThis,key):()=>publicThis[key];if(isString(raw)){const handler=ctx[raw];isFunction(handler)?watch(getter,handler):warn$1(`Invalid watch handler specified by key "${raw}"`,handler)}else if(isFunction(raw))watch(getter,raw.bind(publicThis));else if(isObject(raw))if(isArray(raw))raw.forEach(r=>createWatcher(r,ctx,publicThis,key));else{const handler=isFunction(raw.handler)?raw.handler.bind(publicThis):ctx[raw.handler];isFunction(handler)?watch(getter,handler,raw):warn$1(`Invalid watch handler specified by key "${raw.handler}"`,handler)
}else warn$1(`Invalid watch option: "${key}"`,raw)}function resolveMergedOptions(instance){const base=instance.type,{mixins:mixins,extends:extendsOptions}=base,{mixins:globalMixins,optionsCache:cache,config:{optionMergeStrategies:optionMergeStrategies}}=instance.appContext,cached=cache.get(base);let resolved;return cached?resolved=cached:globalMixins.length||mixins||extendsOptions?(resolved={},globalMixins.length&&globalMixins.forEach(m=>mergeOptions(resolved,m,optionMergeStrategies,!0)),mergeOptions(resolved,base,optionMergeStrategies)):resolved=base,cache.set(base,resolved),resolved}function mergeOptions(to,from,strats,asMixin=!1){const{mixins:mixins,extends:extendsOptions}=from;extendsOptions&&mergeOptions(to,extendsOptions,strats,!0),mixins&&mixins.forEach(m=>mergeOptions(to,m,strats,!0));for(const key in from)if(asMixin&&"expose"===key)warn$1('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');else{const strat=internalOptionMergeStrats[key]||strats&&strats[key];to[key]=strat?strat(to[key],from[key]):from[key]}return to}function mergeDataFn(to,from){return from?to?function(){return extend(isFunction(to)?to.call(this,this):to,isFunction(from)?from.call(this,this):from)}:from:to}function mergeInject(to,from){return mergeObjectOptions(normalizeInject(to),normalizeInject(from))}function normalizeInject(raw){if(isArray(raw)){const res={};for(let i=0;i<raw.length;i++)res[raw[i]]=raw[i];return res}return raw}function mergeAsArray(to,from){return to?[...new Set([].concat(to,from))]:from}function mergeObjectOptions(to,from){return to?extend(extend(Object.create(null),to),from):from}function mergeWatchOptions(to,from){if(!to)return from;if(!from)return to;const merged=extend(Object.create(null),to);for(const key in from)merged[key]=mergeAsArray(to[key],from[key]);return merged}function initProps(instance,rawProps,isStateful,isSSR=!1){const props={},attrs={};def(attrs,InternalObjectKey,1),instance.propsDefaults=Object.create(null),setFullProps(instance,rawProps,props,attrs);for(const key in instance.propsOptions[0])key in props||(props[key]=void 0);validateProps(rawProps||{},props,instance),isStateful?instance.props=isSSR?props:shallowReactive(props):instance.type.props?instance.props=props:instance.props=attrs,instance.attrs=attrs}function updateProps(instance,rawProps,rawPrevProps,optimized){const{props:props,attrs:attrs,vnode:{patchFlag:patchFlag}}=instance,rawCurrentProps=toRaw(props),[options]=instance.propsOptions;let hasAttrsChanged=!1;if(instance.type.__hmrId||instance.parent&&instance.parent.type.__hmrId||!(optimized||patchFlag>0)||16&patchFlag){let kebabKey;setFullProps(instance,rawProps,props,attrs)&&(hasAttrsChanged=!0);for(const key in rawCurrentProps)rawProps&&(hasOwn(rawProps,key)||(kebabKey=hyphenate(key))!==key&&hasOwn(rawProps,kebabKey))||(options?!rawPrevProps||void 0===rawPrevProps[key]&&void 0===rawPrevProps[kebabKey]||(props[key]=resolvePropValue(options,rawCurrentProps,key,void 0,instance,!0)):delete props[key]);if(attrs!==rawCurrentProps)for(const key in attrs)rawProps&&hasOwn(rawProps,key)||(delete attrs[key],hasAttrsChanged=!0)}else if(8&patchFlag){const propsToUpdate=instance.vnode.dynamicProps;for(let i=0;i<propsToUpdate.length;i++){let key=propsToUpdate[i];if(isEmitListener(instance.emitsOptions,key))continue;const value=rawProps[key];if(options)if(hasOwn(attrs,key))value!==attrs[key]&&(attrs[key]=value,hasAttrsChanged=!0);else{const camelizedKey=camelize(key);props[camelizedKey]=resolvePropValue(options,rawCurrentProps,camelizedKey,value,instance,!1)}else value!==attrs[key]&&(attrs[key]=value,hasAttrsChanged=!0)}}hasAttrsChanged&&trigger(instance,"set","$attrs"),validateProps(rawProps||{},props,instance)}function setFullProps(instance,rawProps,props,attrs){const[options,needCastKeys]=instance.propsOptions;let rawCastValues,hasAttrsChanged=!1;if(rawProps)for(let key in rawProps){if(isReservedProp(key))continue;const value=rawProps[key];let camelKey;options&&hasOwn(options,camelKey=camelize(key))?needCastKeys&&needCastKeys.includes(camelKey)?(rawCastValues||(rawCastValues={}))[camelKey]=value:props[camelKey]=value:isEmitListener(instance.emitsOptions,key)||key in attrs&&value===attrs[key]||(attrs[key]=value,hasAttrsChanged=!0)}if(needCastKeys){const rawCurrentProps=toRaw(props),castValues=rawCastValues||EMPTY_OBJ;for(let i=0;i<needCastKeys.length;i++){const key=needCastKeys[i];props[key]=resolvePropValue(options,rawCurrentProps,key,castValues[key],instance,!hasOwn(castValues,key))}}return hasAttrsChanged}function resolvePropValue(options,props,key,value,instance,isAbsent){const opt=options[key];if(null!=opt){const hasDefault=hasOwn(opt,"default");if(hasDefault&&void 0===value){const defaultValue=opt.default;if(opt.type!==Function&&isFunction(defaultValue)){const{propsDefaults:propsDefaults}=instance;key in propsDefaults?value=propsDefaults[key]:(setCurrentInstance(instance),value=propsDefaults[key]=defaultValue.call(null,props),unsetCurrentInstance())}else value=defaultValue}opt[0]&&(isAbsent&&!hasDefault?value=!1:!opt[1]||""!==value&&value!==hyphenate(key)||(value=!0))}return value}function normalizePropsOptions(comp,appContext,asMixin=!1){const cache=appContext.propsCache,cached=cache.get(comp);if(cached)return cached;const raw=comp.props,normalized={},needCastKeys=[];let hasExtends=!1;if(!isFunction(comp)){const extendProps=raw=>{hasExtends=!0;const[props,keys]=normalizePropsOptions(raw,appContext,!0);extend(normalized,props),keys&&needCastKeys.push(...keys)};!asMixin&&appContext.mixins.length&&appContext.mixins.forEach(extendProps),comp.extends&&extendProps(comp.extends),comp.mixins&&comp.mixins.forEach(extendProps)}if(!raw&&!hasExtends)return cache.set(comp,EMPTY_ARR),EMPTY_ARR;if(isArray(raw))for(let i=0;i<raw.length;i++){isString(raw[i])||warn$1("props must be strings when using array syntax.",raw[i]);const normalizedKey=camelize(raw[i]);validatePropName(normalizedKey)&&(normalized[normalizedKey]=EMPTY_OBJ)}else if(raw){isObject(raw)||warn$1("invalid props options",raw);for(const key in raw){const normalizedKey=camelize(key);if(validatePropName(normalizedKey)){const opt=raw[key],prop=normalized[normalizedKey]=isArray(opt)||isFunction(opt)?{type:opt}:opt;if(prop){const booleanIndex=getTypeIndex(Boolean,prop.type),stringIndex=getTypeIndex(String,prop.type);prop[0]=booleanIndex>-1,prop[1]=stringIndex<0||booleanIndex<stringIndex,(booleanIndex>-1||hasOwn(prop,"default"))&&needCastKeys.push(normalizedKey)}}}}const res=[normalized,needCastKeys];return cache.set(comp,res),res}function validatePropName(key){return"$"!==key[0]||(warn$1(`Invalid prop name: "${key}" is a reserved property.`),!1)}function getType(ctor){const match=ctor&&ctor.toString().match(/^\s*function (\w+)/);return match?match[1]:null===ctor?"null":""}function isSameType(a,b){return getType(a)===getType(b)}function getTypeIndex(type,expectedTypes){return isArray(expectedTypes)?expectedTypes.findIndex(t=>isSameType(t,type)):isFunction(expectedTypes)&&isSameType(expectedTypes,type)?0:-1}function validateProps(rawProps,props,instance){const resolvedValues=toRaw(props),options=instance.propsOptions[0];for(const key in options){let opt=options[key];null!=opt&&validateProp(key,resolvedValues[key],opt,!hasOwn(rawProps,key)&&!hasOwn(rawProps,hyphenate(key)))}}function validateProp(name,value,prop,isAbsent){const{type:type,required:required,validator:validator}=prop;if(required&&isAbsent)warn$1('Missing required prop: "'+name+'"');else if(null!=value||prop.required){if(null!=type&&!0!==type){let isValid=!1;const types=isArray(type)?type:[type],expectedTypes=[];for(let i=0;i<types.length&&!isValid;i++){const{valid:valid,expectedType:expectedType}=assertType(value,types[i]);expectedTypes.push(expectedType||""),isValid=valid}if(!isValid)return void warn$1(getInvalidTypeMessage(name,value,expectedTypes))}validator&&!validator(value)&&warn$1('Invalid prop: custom validator check failed for prop "'+name+'".')}}function assertType(value,type){let valid;const expectedType=getType(type);if(isSimpleType(expectedType)){const t=typeof value;valid=t===expectedType.toLowerCase(),valid||"object"!==t||(valid=value instanceof type)}else valid="Object"===expectedType?isObject(value):"Array"===expectedType?isArray(value):"null"===expectedType?null===value:value instanceof type;return{valid:valid,expectedType:expectedType}}function getInvalidTypeMessage(name,value,expectedTypes){let message=`Invalid prop: type check failed for prop "${name}".`+` Expected ${expectedTypes.map(capitalize).join(" | ")}`;const expectedType=expectedTypes[0],receivedType=toRawType(value),expectedValue=styleValue(value,expectedType),receivedValue=styleValue(value,receivedType);return 1===expectedTypes.length&&isExplicable(expectedType)&&!isBoolean(expectedType,receivedType)&&(message+=` with value ${expectedValue}`),message+=`, got ${receivedType} `,isExplicable(receivedType)&&(message+=`with value ${receivedValue}.`),message}function styleValue(value,type){return"String"===type?`"${value}"`:"Number"===type?`${Number(value)}`:`${value}`}function isExplicable(type){const explicitTypes=["string","number","boolean"];return explicitTypes.some(elem=>type.toLowerCase()===elem)}function isBoolean(...args){return args.some(elem=>"boolean"===elem.toLowerCase())}function validateDirectiveName(name){isBuiltInDirective(name)&&warn$1("Do not use built-in directive ids as custom directive id: "+name)}function withDirectives(vnode,directives){const internalInstance=currentRenderingInstance;if(null===internalInstance)return warn$1("withDirectives can only be used inside render functions."),vnode;const instance=getExposeProxy(internalInstance)||internalInstance.proxy,bindings=vnode.dirs||(vnode.dirs=[]);for(let i=0;i<directives.length;i++){let[dir,value,arg,modifiers=EMPTY_OBJ]=directives[i];isFunction(dir)&&(dir={mounted:dir,updated:dir}),dir.deep&&traverse(value),bindings.push({dir:dir,instance:instance,value:value,oldValue:void 0,arg:arg,modifiers:modifiers})}return vnode}function invokeDirectiveHook(vnode,prevVNode,instance,name){const bindings=vnode.dirs,oldBindings=prevVNode&&prevVNode.dirs;for(let i=0;i<bindings.length;i++){const binding=bindings[i];oldBindings&&(binding.oldValue=oldBindings[i].value);let hook=binding.dir[name];hook&&(pauseTracking(),callWithAsyncErrorHandling(hook,instance,8,[vnode.el,binding,vnode,prevVNode]),resetTracking())}}function createAppContext(){return{app:null,config:{isNativeTag:NO,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}function createAppAPI(render,hydrate){return function(rootComponent,rootProps=null){isFunction(rootComponent)||(rootComponent=Object.assign({},rootComponent)),null==rootProps||isObject(rootProps)||(warn$1("root props passed to app.mount() must be an object."),rootProps=null);const context=createAppContext(),installedPlugins=new Set;let isMounted=!1;const app=context.app={_uid:uid++,_component:rootComponent,_props:rootProps,_container:null,_context:context,_instance:null,version:version,get config(){return context.config},set config(v){warn$1("app.config cannot be replaced. Modify individual options instead.")},use:(plugin,...options)=>(installedPlugins.has(plugin)?warn$1("Plugin has already been applied to target app."):plugin&&isFunction(plugin.install)?(installedPlugins.add(plugin),plugin.install(app,...options)):isFunction(plugin)?(installedPlugins.add(plugin),plugin(app,...options)):warn$1('A plugin must either be a function or an object with an "install" function.'),app),mixin:mixin=>(context.mixins.includes(mixin)?warn$1("Mixin has already been applied to target app"+(mixin.name?`: ${mixin.name}`:"")):context.mixins.push(mixin),app),component:(name,component)=>(validateComponentName(name,context.config),component?(context.components[name]&&warn$1(`Component "${name}" has already been registered in target app.`),context.components[name]=component,app):context.components[name]),directive:(name,directive)=>(validateDirectiveName(name),directive?(context.directives[name]&&warn$1(`Directive "${name}" has already been registered in target app.`),context.directives[name]=directive,app):context.directives[name]),mount(rootContainer,isHydrate,isSVG){if(!isMounted){const vnode=createVNode(rootComponent,rootProps);return vnode.appContext=context,context.reload=(()=>{render(cloneVNode(vnode),rootContainer,isSVG)}),isHydrate&&hydrate?hydrate(vnode,rootContainer):render(vnode,rootContainer,isSVG),isMounted=!0,app._container=rootContainer,rootContainer.__vue_app__=app,app._instance=vnode.component,devtoolsInitApp(app,version),getExposeProxy(vnode.component)||vnode.component.proxy}warn$1("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`")},unmount(){isMounted?(render(null,app._container),app._instance=null,devtoolsUnmountApp(app),delete app._container.__vue_app__):warn$1("Cannot unmount an app that is not mounted.")},provide:(key,value)=>(key in context.provides&&warn$1(`App already provides property with key "${String(key)}". `+"It will be overwritten with the new value."),context.provides[key]=value,app)};return app}}function setRef(rawRef,oldRawRef,parentSuspense,vnode,isUnmount=!1){if(isArray(rawRef))return void rawRef.forEach((r,i)=>setRef(r,oldRawRef&&(isArray(oldRawRef)?oldRawRef[i]:oldRawRef),parentSuspense,vnode,isUnmount));if(isAsyncWrapper(vnode)&&!isUnmount)return;const refValue=4&vnode.shapeFlag?getExposeProxy(vnode.component)||vnode.component.proxy:vnode.el,value=isUnmount?null:refValue,{i:owner,r:ref}=rawRef;if(!owner)return void warn$1("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");const oldRef=oldRawRef&&oldRawRef.r,refs=owner.refs===EMPTY_OBJ?owner.refs={}:owner.refs,setupState=owner.setupState;if(null!=oldRef&&oldRef!==ref&&(isString(oldRef)?(refs[oldRef]=null,hasOwn(setupState,oldRef)&&(setupState[oldRef]=null)):isRef(oldRef)&&(oldRef.value=null)),isFunction(ref))callWithErrorHandling(ref,owner,12,[value,refs]);else{const _isString=isString(ref),_isRef=isRef(ref);if(_isString||_isRef){const doSet=()=>{if(rawRef.f){const existing=_isString?refs[ref]:ref.value;isUnmount?isArray(existing)&&remove(existing,refValue):isArray(existing)?existing.includes(refValue)||existing.push(refValue):_isString?(refs[ref]=[refValue],hasOwn(setupState,ref)&&(setupState[ref]=refs[ref])):(ref.value=[refValue],rawRef.k&&(refs[rawRef.k]=ref.value))}else _isString?(refs[ref]=value,hasOwn(setupState,ref)&&(setupState[ref]=value)):isRef(ref)?(ref.value=value,rawRef.k&&(refs[rawRef.k]=value)):warn$1("Invalid template ref type:",ref,`(${typeof ref})`)};value?(doSet.id=-1,queuePostRenderEffect(doSet,parentSuspense)):doSet()}else warn$1("Invalid template ref type:",ref,`(${typeof ref})`)}}function createHydrationFunctions(rendererInternals){const{mt:mountComponent,p:patch,o:{patchProp:patchProp,nextSibling:nextSibling,parentNode:parentNode,remove:remove,insert:insert,createComment:createComment}}=rendererInternals,hydrate=(vnode,container)=>{if(!container.hasChildNodes())return warn$1("Attempting to hydrate existing markup but container is empty. Performing full mount instead."),patch(null,vnode,container),void flushPostFlushCbs();hasMismatch=!1,hydrateNode(container.firstChild,vnode,null,null,null),flushPostFlushCbs(),hasMismatch&&console.error("Hydration completed but contains mismatches.")},hydrateNode=(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized=!1)=>{const isFragmentStart=isComment(node)&&"["===node.data,onMismatch=()=>handleMismatch(node,vnode,parentComponent,parentSuspense,slotScopeIds,isFragmentStart),{type:type,ref:ref,shapeFlag:shapeFlag}=vnode,domType=node.nodeType;vnode.el=node;let nextNode=null;switch(type){case Text:3!==domType?nextNode=onMismatch():(node.data!==vnode.children&&(hasMismatch=!0,warn$1("Hydration text mismatch:"+`\n- Client: ${JSON.stringify(node.data)}`+`\n- Server: ${JSON.stringify(vnode.children)}`),node.data=vnode.children),nextNode=nextSibling(node));break;case Comment:nextNode=8!==domType||isFragmentStart?onMismatch():nextSibling(node);break;case Static:if(1===domType){nextNode=node;const needToAdoptContent=!vnode.children.length;for(let i=0;i<vnode.staticCount;i++)needToAdoptContent&&(vnode.children+=nextNode.outerHTML),i===vnode.staticCount-1&&(vnode.anchor=nextNode),nextNode=nextSibling(nextNode);return nextNode}nextNode=onMismatch();break;case Fragment:nextNode=isFragmentStart?hydrateFragment(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized):onMismatch();break;default:if(1&shapeFlag)nextNode=1!==domType||vnode.type.toLowerCase()!==node.tagName.toLowerCase()?onMismatch():hydrateElement(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized);else if(6&shapeFlag){vnode.slotScopeIds=slotScopeIds;const container=parentNode(node);if(mountComponent(vnode,container,null,parentComponent,parentSuspense,isSVGContainer(container),optimized),nextNode=isFragmentStart?locateClosingAsyncAnchor(node):nextSibling(node),isAsyncWrapper(vnode)){let subTree;isFragmentStart?(subTree=createVNode(Fragment),subTree.anchor=nextNode?nextNode.previousSibling:container.lastChild):subTree=3===node.nodeType?createTextVNode(""):createVNode("div"),subTree.el=node,vnode.component.subTree=subTree}}else 64&shapeFlag?nextNode=8!==domType?onMismatch():vnode.type.hydrate(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized,rendererInternals,hydrateChildren):128&shapeFlag?nextNode=vnode.type.hydrate(node,vnode,parentComponent,parentSuspense,isSVGContainer(parentNode(node)),slotScopeIds,optimized,rendererInternals,hydrateNode):warn$1("Invalid HostVNode type:",type,`(${typeof type})`)}return null!=ref&&setRef(ref,null,parentSuspense,vnode),nextNode},hydrateElement=(el,vnode,parentComponent,parentSuspense,slotScopeIds,optimized)=>{optimized=optimized||!!vnode.dynamicChildren;const{type:type,props:props,patchFlag:patchFlag,shapeFlag:shapeFlag,dirs:dirs}=vnode,forcePatchValue="input"===type&&dirs||"option"===type;{if(dirs&&invokeDirectiveHook(vnode,null,parentComponent,"created"),props)if(forcePatchValue||!optimized||48&patchFlag)for(const key in props)(forcePatchValue&&key.endsWith("value")||isOn(key)&&!isReservedProp(key))&&patchProp(el,key,null,props[key],!1,void 0,parentComponent);else props.onClick&&patchProp(el,"onClick",null,props.onClick,!1,void 0,parentComponent);let vnodeHooks;if((vnodeHooks=props&&props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHooks,parentComponent,vnode),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeMount"),((vnodeHooks=props&&props.onVnodeMounted)||dirs)&&queueEffectWithSuspense(()=>{vnodeHooks&&invokeVNodeHook(vnodeHooks,parentComponent,vnode),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"mounted")},parentSuspense),16&shapeFlag&&(!props||!props.innerHTML&&!props.textContent)){let next=hydrateChildren(el.firstChild,vnode,el,parentComponent,parentSuspense,slotScopeIds,optimized),hasWarned=!1;for(;next;){hasMismatch=!0,hasWarned||(warn$1(`Hydration children mismatch in <${vnode.type}>: `+"server rendered element contains more child nodes than client vdom."),hasWarned=!0);const cur=next;next=next.nextSibling,remove(cur)}}else 8&shapeFlag&&el.textContent!==vnode.children&&(hasMismatch=!0,warn$1(`Hydration text content mismatch in <${vnode.type}>:\n`+`- Client: ${el.textContent}\n`+`- Server: ${vnode.children}`),el.textContent=vnode.children)}return el.nextSibling},hydrateChildren=(node,parentVNode,container,parentComponent,parentSuspense,slotScopeIds,optimized)=>{optimized=optimized||!!parentVNode.dynamicChildren;const children=parentVNode.children,l=children.length;let hasWarned=!1;for(let i=0;i<l;i++){const vnode=optimized?children[i]:children[i]=normalizeVNode(children[i]);if(node)node=hydrateNode(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized);else{if(vnode.type===Text&&!vnode.children)continue;hasMismatch=!0,hasWarned||(warn$1(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: `+"server rendered element contains fewer child nodes than client vdom."),hasWarned=!0),patch(null,vnode,container,null,parentComponent,parentSuspense,isSVGContainer(container),slotScopeIds)}}return node},hydrateFragment=(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized)=>{const{slotScopeIds:fragmentSlotScopeIds}=vnode;fragmentSlotScopeIds&&(slotScopeIds=slotScopeIds?slotScopeIds.concat(fragmentSlotScopeIds):fragmentSlotScopeIds);const container=parentNode(node),next=hydrateChildren(nextSibling(node),vnode,container,parentComponent,parentSuspense,slotScopeIds,optimized);return next&&isComment(next)&&"]"===next.data?nextSibling(vnode.anchor=next):(hasMismatch=!0,insert(vnode.anchor=createComment("]"),container,next),next)},handleMismatch=(node,vnode,parentComponent,parentSuspense,slotScopeIds,isFragment)=>{if(hasMismatch=!0,warn$1("Hydration node mismatch:\n- Client vnode:",vnode.type,"\n- Server rendered DOM:",node,3===node.nodeType?"(text)":isComment(node)&&"["===node.data?"(start of fragment)":""),vnode.el=null,isFragment){const end=locateClosingAsyncAnchor(node);for(;;){const next=nextSibling(node);if(!next||next===end)break;remove(next)}}const next=nextSibling(node),container=parentNode(node);return remove(node),patch(null,vnode,container,next,parentComponent,parentSuspense,isSVGContainer(container),slotScopeIds),next},locateClosingAsyncAnchor=node=>{let match=0;for(;node;)if(node=nextSibling(node),node&&isComment(node)&&("["===node.data&&match++,"]"===node.data)){if(0===match)return nextSibling(node);match--}return node};return[hydrate,hydrateNode]}function startMeasure(instance,type){instance.appContext.config.performance&&isSupported()&&perf.mark(`vue-${type}-${instance.uid}`),devtoolsPerfStart(instance,type,isSupported()?perf.now():Date.now())}function endMeasure(instance,type){if(instance.appContext.config.performance&&isSupported()){const startTag=`vue-${type}-${instance.uid}`,endTag=startTag+":end";perf.mark(endTag),perf.measure(`<${formatComponentName(instance,instance.type)}> ${type}`,startTag,endTag),perf.clearMarks(startTag),perf.clearMarks(endTag)}devtoolsPerfEnd(instance,type,isSupported()?perf.now():Date.now())}function isSupported(){return void 0!==supported?supported:("undefined"!=typeof window&&window.performance?(supported=!0,perf=window.performance):supported=!1,supported)}function createRenderer(options){return baseCreateRenderer(options)}function createHydrationRenderer(options){return baseCreateRenderer(options,createHydrationFunctions)}function baseCreateRenderer(options,createHydrationFns){const target=getGlobalThis();target.__VUE__=!0,setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__,target);const{insert:hostInsert,remove:hostRemove,patchProp:hostPatchProp,createElement:hostCreateElement,createText:hostCreateText,createComment:hostCreateComment,setText:hostSetText,setElementText:hostSetElementText,parentNode:hostParentNode,nextSibling:hostNextSibling,setScopeId:hostSetScopeId=NOOP,cloneNode:hostCloneNode,insertStaticContent:hostInsertStaticContent}=options,patch=(n1,n2,container,anchor=null,parentComponent=null,parentSuspense=null,isSVG=!1,slotScopeIds=null,optimized=!isHmrUpdating&&!!n2.dynamicChildren)=>{if(n1===n2)return;n1&&!isSameVNodeType(n1,n2)&&(anchor=getNextHostNode(n1),unmount(n1,parentComponent,parentSuspense,!0),n1=null),-2===n2.patchFlag&&(optimized=!1,n2.dynamicChildren=null);const{type:type,ref:ref,shapeFlag:shapeFlag}=n2;switch(type){case Text:processText(n1,n2,container,anchor);break;case Comment:processCommentNode(n1,n2,container,anchor);break;case Static:null==n1?mountStaticNode(n2,container,anchor,isSVG):patchStaticNode(n1,n2,container,isSVG);break;case Fragment:processFragment(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);break;default:1&shapeFlag?processElement(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized):6&shapeFlag?processComponent(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized):64&shapeFlag?type.process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,internals):128&shapeFlag?type.process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,internals):warn$1("Invalid VNode type:",type,`(${typeof type})`)}null!=ref&&parentComponent&&setRef(ref,n1&&n1.ref,parentSuspense,n2||n1,!n2)},processText=(n1,n2,container,anchor)=>{if(null==n1)hostInsert(n2.el=hostCreateText(n2.children),container,anchor);else{const el=n2.el=n1.el;n2.children!==n1.children&&hostSetText(el,n2.children)}},processCommentNode=(n1,n2,container,anchor)=>{null==n1?hostInsert(n2.el=hostCreateComment(n2.children||""),container,anchor):n2.el=n1.el},mountStaticNode=(n2,container,anchor,isSVG)=>{[n2.el,n2.anchor]=hostInsertStaticContent(n2.children,container,anchor,isSVG,n2.el,n2.anchor)},patchStaticNode=(n1,n2,container,isSVG)=>{if(n2.children!==n1.children){const anchor=hostNextSibling(n1.anchor);removeStaticNode(n1),[n2.el,n2.anchor]=hostInsertStaticContent(n2.children,container,anchor,isSVG)}else n2.el=n1.el,n2.anchor=n1.anchor},moveStaticNode=({el:el,anchor:anchor},container,nextSibling)=>{let next;for(;el&&el!==anchor;)next=hostNextSibling(el),hostInsert(el,container,nextSibling),el=next;hostInsert(anchor,container,nextSibling)},removeStaticNode=({el:el,anchor:anchor})=>{let next;for(;el&&el!==anchor;)next=hostNextSibling(el),hostRemove(el),el=next;hostRemove(anchor)},processElement=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{isSVG=isSVG||"svg"===n2.type,null==n1?mountElement(n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized):patchElement(n1,n2,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)},mountElement=(vnode,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{let el,vnodeHook;const{type:type,props:props,shapeFlag:shapeFlag,transition:transition,patchFlag:patchFlag,dirs:dirs}=vnode;if(el=vnode.el=hostCreateElement(vnode.type,isSVG,props&&props.is,props),8&shapeFlag?hostSetElementText(el,vnode.children):16&shapeFlag&&mountChildren(vnode.children,el,null,parentComponent,parentSuspense,isSVG&&"foreignObject"!==type,slotScopeIds,optimized),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"created"),props){for(const key in props)"value"===key||isReservedProp(key)||hostPatchProp(el,key,null,props[key],isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren);"value"in props&&hostPatchProp(el,"value",null,props.value),(vnodeHook=props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHook,parentComponent,vnode)}setScopeId(el,vnode,vnode.scopeId,slotScopeIds,parentComponent),Object.defineProperty(el,"__vnode",{value:vnode,enumerable:!1}),Object.defineProperty(el,"__vueParentComponent",{value:parentComponent,enumerable:!1}),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeMount");const needCallTransitionHooks=(!parentSuspense||parentSuspense&&!parentSuspense.pendingBranch)&&transition&&!transition.persisted;needCallTransitionHooks&&transition.beforeEnter(el),hostInsert(el,container,anchor),((vnodeHook=props&&props.onVnodeMounted)||needCallTransitionHooks||dirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,vnode),needCallTransitionHooks&&transition.enter(el),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"mounted")},parentSuspense)},setScopeId=(el,vnode,scopeId,slotScopeIds,parentComponent)=>{if(scopeId&&hostSetScopeId(el,scopeId),slotScopeIds)for(let i=0;i<slotScopeIds.length;i++)hostSetScopeId(el,slotScopeIds[i]);if(parentComponent){let subTree=parentComponent.subTree;if(subTree.patchFlag>0&&2048&subTree.patchFlag&&(subTree=filterSingleRoot(subTree.children)||subTree),vnode===subTree){const parentVNode=parentComponent.vnode;setScopeId(el,parentVNode,parentVNode.scopeId,parentVNode.slotScopeIds,parentComponent.parent)}}},mountChildren=(children,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,start=0)=>{for(let i=start;i<children.length;i++){const child=children[i]=optimized?cloneIfMounted(children[i]):normalizeVNode(children[i]);patch(null,child,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)}},patchElement=(n1,n2,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{const el=n2.el=n1.el;let{patchFlag:patchFlag,dynamicChildren:dynamicChildren,dirs:dirs}=n2;patchFlag|=16&n1.patchFlag;const oldProps=n1.props||EMPTY_OBJ,newProps=n2.props||EMPTY_OBJ;let vnodeHook;parentComponent&&toggleRecurse(parentComponent,!1),(vnodeHook=newProps.onVnodeBeforeUpdate)&&invokeVNodeHook(vnodeHook,parentComponent,n2,n1),dirs&&invokeDirectiveHook(n2,n1,parentComponent,"beforeUpdate"),parentComponent&&toggleRecurse(parentComponent,!0),isHmrUpdating&&(patchFlag=0,optimized=!1,dynamicChildren=null);const areChildrenSVG=isSVG&&"foreignObject"!==n2.type;if(dynamicChildren?(patchBlockChildren(n1.dynamicChildren,dynamicChildren,el,parentComponent,parentSuspense,areChildrenSVG,slotScopeIds),parentComponent&&parentComponent.type.__hmrId&&traverseStaticChildren(n1,n2)):optimized||patchChildren(n1,n2,el,null,parentComponent,parentSuspense,areChildrenSVG,slotScopeIds,!1),patchFlag>0){if(16&patchFlag)patchProps(el,n2,oldProps,newProps,parentComponent,parentSuspense,isSVG);else if(2&patchFlag&&oldProps.class!==newProps.class&&hostPatchProp(el,"class",null,newProps.class,isSVG),4&patchFlag&&hostPatchProp(el,"style",oldProps.style,newProps.style,isSVG),8&patchFlag){const propsToUpdate=n2.dynamicProps;for(let i=0;i<propsToUpdate.length;i++){const key=propsToUpdate[i],prev=oldProps[key],next=newProps[key];next===prev&&"value"!==key||hostPatchProp(el,key,prev,next,isSVG,n1.children,parentComponent,parentSuspense,unmountChildren)}}1&patchFlag&&n1.children!==n2.children&&hostSetElementText(el,n2.children)}else optimized||null!=dynamicChildren||patchProps(el,n2,oldProps,newProps,parentComponent,parentSuspense,isSVG);((vnodeHook=newProps.onVnodeUpdated)||dirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,n2,n1),dirs&&invokeDirectiveHook(n2,n1,parentComponent,"updated")},parentSuspense)},patchBlockChildren=(oldChildren,newChildren,fallbackContainer,parentComponent,parentSuspense,isSVG,slotScopeIds)=>{for(let i=0;i<newChildren.length;i++){const oldVNode=oldChildren[i],newVNode=newChildren[i],container=oldVNode.el&&(oldVNode.type===Fragment||!isSameVNodeType(oldVNode,newVNode)||70&oldVNode.shapeFlag)?hostParentNode(oldVNode.el):fallbackContainer;patch(oldVNode,newVNode,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,!0)}},patchProps=(el,vnode,oldProps,newProps,parentComponent,parentSuspense,isSVG)=>{if(oldProps!==newProps){for(const key in newProps){if(isReservedProp(key))continue;const next=newProps[key],prev=oldProps[key];next!==prev&&"value"!==key&&hostPatchProp(el,key,prev,next,isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren)}if(oldProps!==EMPTY_OBJ)for(const key in oldProps)isReservedProp(key)||key in newProps||hostPatchProp(el,key,oldProps[key],null,isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren);"value"in newProps&&hostPatchProp(el,"value",oldProps.value,newProps.value)}},processFragment=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{const fragmentStartAnchor=n2.el=n1?n1.el:hostCreateText(""),fragmentEndAnchor=n2.anchor=n1?n1.anchor:hostCreateText("");let{patchFlag:patchFlag,dynamicChildren:dynamicChildren,slotScopeIds:fragmentSlotScopeIds}=n2
;isHmrUpdating&&(patchFlag=0,optimized=!1,dynamicChildren=null),fragmentSlotScopeIds&&(slotScopeIds=slotScopeIds?slotScopeIds.concat(fragmentSlotScopeIds):fragmentSlotScopeIds),null==n1?(hostInsert(fragmentStartAnchor,container,anchor),hostInsert(fragmentEndAnchor,container,anchor),mountChildren(n2.children,container,fragmentEndAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)):patchFlag>0&&64&patchFlag&&dynamicChildren&&n1.dynamicChildren?(patchBlockChildren(n1.dynamicChildren,dynamicChildren,container,parentComponent,parentSuspense,isSVG,slotScopeIds),parentComponent&&parentComponent.type.__hmrId?traverseStaticChildren(n1,n2):(null!=n2.key||parentComponent&&n2===parentComponent.subTree)&&traverseStaticChildren(n1,n2,!0)):patchChildren(n1,n2,container,fragmentEndAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)},processComponent=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{n2.slotScopeIds=slotScopeIds,null==n1?512&n2.shapeFlag?parentComponent.ctx.activate(n2,container,anchor,isSVG,optimized):mountComponent(n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized):updateComponent(n1,n2,optimized)},mountComponent=(initialVNode,container,anchor,parentComponent,parentSuspense,isSVG,optimized)=>{const instance=initialVNode.component=createComponentInstance(initialVNode,parentComponent,parentSuspense);if(instance.type.__hmrId&&registerHMR(instance),pushWarningContext(initialVNode),startMeasure(instance,"mount"),isKeepAlive(initialVNode)&&(instance.ctx.renderer=internals),startMeasure(instance,"init"),setupComponent(instance),endMeasure(instance,"init"),instance.asyncDep){if(parentSuspense&&parentSuspense.registerDep(instance,setupRenderEffect),!initialVNode.el){const placeholder=instance.subTree=createVNode(Comment);processCommentNode(null,placeholder,container,anchor)}}else setupRenderEffect(instance,initialVNode,container,anchor,parentSuspense,isSVG,optimized),popWarningContext(),endMeasure(instance,"mount")},updateComponent=(n1,n2,optimized)=>{const instance=n2.component=n1.component;if(shouldUpdateComponent(n1,n2,optimized)){if(instance.asyncDep&&!instance.asyncResolved)return pushWarningContext(n2),updateComponentPreRender(instance,n2,optimized),void popWarningContext();instance.next=n2,invalidateJob(instance.update),instance.update()}else n2.component=n1.component,n2.el=n1.el,instance.vnode=n2},setupRenderEffect=(instance,initialVNode,container,anchor,parentSuspense,isSVG,optimized)=>{const componentUpdateFn=()=>{if(instance.isMounted){let vnodeHook,{next:next,bu:bu,u:u,parent:parent,vnode:vnode}=instance,originNext=next;pushWarningContext(next||instance.vnode),toggleRecurse(instance,!1),next?(next.el=vnode.el,updateComponentPreRender(instance,next,optimized)):next=vnode,bu&&invokeArrayFns(bu),(vnodeHook=next.props&&next.props.onVnodeBeforeUpdate)&&invokeVNodeHook(vnodeHook,parent,next,vnode),toggleRecurse(instance,!0),startMeasure(instance,"render");const nextTree=renderComponentRoot(instance);endMeasure(instance,"render");const prevTree=instance.subTree;instance.subTree=nextTree,startMeasure(instance,"patch"),patch(prevTree,nextTree,hostParentNode(prevTree.el),getNextHostNode(prevTree),instance,parentSuspense,isSVG),endMeasure(instance,"patch"),next.el=nextTree.el,null===originNext&&updateHOCHostEl(instance,nextTree.el),u&&queuePostRenderEffect(u,parentSuspense),(vnodeHook=next.props&&next.props.onVnodeUpdated)&&queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook,parent,next,vnode),parentSuspense),devtoolsComponentUpdated(instance),popWarningContext()}else{let vnodeHook;const{el:el,props:props}=initialVNode,{bm:bm,m:m,parent:parent}=instance,isAsyncWrapperVNode=isAsyncWrapper(initialVNode);if(toggleRecurse(instance,!1),bm&&invokeArrayFns(bm),!isAsyncWrapperVNode&&(vnodeHook=props&&props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHook,parent,initialVNode),toggleRecurse(instance,!0),el&&hydrateNode){const hydrateSubTree=()=>{startMeasure(instance,"render"),instance.subTree=renderComponentRoot(instance),endMeasure(instance,"render"),startMeasure(instance,"hydrate"),hydrateNode(el,instance.subTree,instance,parentSuspense,null),endMeasure(instance,"hydrate")};isAsyncWrapperVNode?initialVNode.type.__asyncLoader().then(()=>!instance.isUnmounted&&hydrateSubTree()):hydrateSubTree()}else{startMeasure(instance,"render");const subTree=instance.subTree=renderComponentRoot(instance);endMeasure(instance,"render"),startMeasure(instance,"patch"),patch(null,subTree,container,anchor,instance,parentSuspense,isSVG),endMeasure(instance,"patch"),initialVNode.el=subTree.el}if(m&&queuePostRenderEffect(m,parentSuspense),!isAsyncWrapperVNode&&(vnodeHook=props&&props.onVnodeMounted)){const scopedInitialVNode=initialVNode;queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook,parent,scopedInitialVNode),parentSuspense)}256&initialVNode.shapeFlag&&instance.a&&queuePostRenderEffect(instance.a,parentSuspense),instance.isMounted=!0,devtoolsComponentAdded(instance),initialVNode=container=anchor=null}},effect=instance.effect=new ReactiveEffect(componentUpdateFn,()=>queueJob(instance.update),instance.scope),update=instance.update=effect.run.bind(effect);update.id=instance.uid,toggleRecurse(instance,!0),effect.onTrack=instance.rtc?e=>invokeArrayFns(instance.rtc,e):void 0,effect.onTrigger=instance.rtg?e=>invokeArrayFns(instance.rtg,e):void 0,update.ownerInstance=instance,update()},updateComponentPreRender=(instance,nextVNode,optimized)=>{nextVNode.component=instance;const prevProps=instance.vnode.props;instance.vnode=nextVNode,instance.next=null,updateProps(instance,nextVNode.props,prevProps,optimized),updateSlots(instance,nextVNode.children,optimized),pauseTracking(),flushPreFlushCbs(void 0,instance.update),resetTracking()},patchChildren=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized=!1)=>{const c1=n1&&n1.children,prevShapeFlag=n1?n1.shapeFlag:0,c2=n2.children,{patchFlag:patchFlag,shapeFlag:shapeFlag}=n2;if(patchFlag>0){if(128&patchFlag)return void patchKeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);if(256&patchFlag)return void patchUnkeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)}8&shapeFlag?(16&prevShapeFlag&&unmountChildren(c1,parentComponent,parentSuspense),c2!==c1&&hostSetElementText(container,c2)):16&prevShapeFlag?16&shapeFlag?patchKeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized):unmountChildren(c1,parentComponent,parentSuspense,!0):(8&prevShapeFlag&&hostSetElementText(container,""),16&shapeFlag&&mountChildren(c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized))},patchUnkeyedChildren=(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{c1=c1||EMPTY_ARR,c2=c2||EMPTY_ARR;const oldLength=c1.length,newLength=c2.length,commonLength=Math.min(oldLength,newLength);let i;for(i=0;i<commonLength;i++){const nextChild=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);patch(c1[i],nextChild,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)}oldLength>newLength?unmountChildren(c1,parentComponent,parentSuspense,!0,!1,commonLength):mountChildren(c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,commonLength)},patchKeyedChildren=(c1,c2,container,parentAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{let i=0;const l2=c2.length;let e1=c1.length-1,e2=l2-1;for(;i<=e1&&i<=e2;){const n1=c1[i],n2=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);if(!isSameVNodeType(n1,n2))break;patch(n1,n2,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized),i++}for(;i<=e1&&i<=e2;){const n1=c1[e1],n2=c2[e2]=optimized?cloneIfMounted(c2[e2]):normalizeVNode(c2[e2]);if(!isSameVNodeType(n1,n2))break;patch(n1,n2,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized),e1--,e2--}if(i>e1){if(i<=e2){const nextPos=e2+1,anchor=nextPos<l2?c2[nextPos].el:parentAnchor;for(;i<=e2;)patch(null,c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]),container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized),i++}}else if(i>e2)for(;i<=e1;)unmount(c1[i],parentComponent,parentSuspense,!0),i++;else{const s1=i,s2=i,keyToNewIndexMap=new Map;for(i=s2;i<=e2;i++){const nextChild=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);null!=nextChild.key&&(keyToNewIndexMap.has(nextChild.key)&&warn$1("Duplicate keys found during update:",JSON.stringify(nextChild.key),"Make sure keys are unique."),keyToNewIndexMap.set(nextChild.key,i))}let j,patched=0;const toBePatched=e2-s2+1;let moved=!1,maxNewIndexSoFar=0;const newIndexToOldIndexMap=new Array(toBePatched);for(i=0;i<toBePatched;i++)newIndexToOldIndexMap[i]=0;for(i=s1;i<=e1;i++){const prevChild=c1[i];if(patched>=toBePatched){unmount(prevChild,parentComponent,parentSuspense,!0);continue}let newIndex;if(null!=prevChild.key)newIndex=keyToNewIndexMap.get(prevChild.key);else for(j=s2;j<=e2;j++)if(0===newIndexToOldIndexMap[j-s2]&&isSameVNodeType(prevChild,c2[j])){newIndex=j;break}void 0===newIndex?unmount(prevChild,parentComponent,parentSuspense,!0):(newIndexToOldIndexMap[newIndex-s2]=i+1,newIndex>=maxNewIndexSoFar?maxNewIndexSoFar=newIndex:moved=!0,patch(prevChild,c2[newIndex],container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized),patched++)}const increasingNewIndexSequence=moved?getSequence(newIndexToOldIndexMap):EMPTY_ARR;for(j=increasingNewIndexSequence.length-1,i=toBePatched-1;i>=0;i--){const nextIndex=s2+i,nextChild=c2[nextIndex],anchor=nextIndex+1<l2?c2[nextIndex+1].el:parentAnchor;0===newIndexToOldIndexMap[i]?patch(null,nextChild,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized):moved&&(j<0||i!==increasingNewIndexSequence[j]?move(nextChild,container,anchor,2):j--)}}},move=(vnode,container,anchor,moveType,parentSuspense=null)=>{const{el:el,type:type,transition:transition,children:children,shapeFlag:shapeFlag}=vnode;if(6&shapeFlag)return void move(vnode.component.subTree,container,anchor,moveType);if(128&shapeFlag)return void vnode.suspense.move(container,anchor,moveType);if(64&shapeFlag)return void type.move(vnode,container,anchor,internals);if(type===Fragment){hostInsert(el,container,anchor);for(let i=0;i<children.length;i++)move(children[i],container,anchor,moveType);return void hostInsert(vnode.anchor,container,anchor)}if(type===Static)return void moveStaticNode(vnode,container,anchor);const needTransition=2!==moveType&&1&shapeFlag&&transition;if(needTransition)if(0===moveType)transition.beforeEnter(el),hostInsert(el,container,anchor),queuePostRenderEffect(()=>transition.enter(el),parentSuspense);else{const{leave:leave,delayLeave:delayLeave,afterLeave:afterLeave}=transition,remove=()=>hostInsert(el,container,anchor),performLeave=()=>{leave(el,()=>{remove(),afterLeave&&afterLeave()})};delayLeave?delayLeave(el,remove,performLeave):performLeave()}else hostInsert(el,container,anchor)},unmount=(vnode,parentComponent,parentSuspense,doRemove=!1,optimized=!1)=>{const{type:type,props:props,ref:ref,children:children,dynamicChildren:dynamicChildren,shapeFlag:shapeFlag,patchFlag:patchFlag,dirs:dirs}=vnode;if(null!=ref&&setRef(ref,null,parentSuspense,vnode,!0),256&shapeFlag)return void parentComponent.ctx.deactivate(vnode);const shouldInvokeDirs=1&shapeFlag&&dirs,shouldInvokeVnodeHook=!isAsyncWrapper(vnode);let vnodeHook;if(shouldInvokeVnodeHook&&(vnodeHook=props&&props.onVnodeBeforeUnmount)&&invokeVNodeHook(vnodeHook,parentComponent,vnode),6&shapeFlag)unmountComponent(vnode.component,parentSuspense,doRemove);else{if(128&shapeFlag)return void vnode.suspense.unmount(parentSuspense,doRemove);shouldInvokeDirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeUnmount"),64&shapeFlag?vnode.type.remove(vnode,parentComponent,parentSuspense,optimized,internals,doRemove):dynamicChildren&&(type!==Fragment||patchFlag>0&&64&patchFlag)?unmountChildren(dynamicChildren,parentComponent,parentSuspense,!1,!0):(type===Fragment&&384&patchFlag||!optimized&&16&shapeFlag)&&unmountChildren(children,parentComponent,parentSuspense),doRemove&&remove(vnode)}(shouldInvokeVnodeHook&&(vnodeHook=props&&props.onVnodeUnmounted)||shouldInvokeDirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,vnode),shouldInvokeDirs&&invokeDirectiveHook(vnode,null,parentComponent,"unmounted")},parentSuspense)},remove=vnode=>{const{type:type,el:el,anchor:anchor,transition:transition}=vnode;if(type===Fragment)return void(vnode.patchFlag>0&&2048&vnode.patchFlag&&transition&&!transition.persisted?vnode.children.forEach(child=>{child.type===Comment?hostRemove(child.el):remove(child)}):removeFragment(el,anchor));if(type===Static)return void removeStaticNode(vnode);const performRemove=()=>{hostRemove(el),transition&&!transition.persisted&&transition.afterLeave&&transition.afterLeave()};if(1&vnode.shapeFlag&&transition&&!transition.persisted){const{leave:leave,delayLeave:delayLeave}=transition,performLeave=()=>leave(el,performRemove);delayLeave?delayLeave(vnode.el,performRemove,performLeave):performLeave()}else performRemove()},removeFragment=(cur,end)=>{let next;for(;cur!==end;)next=hostNextSibling(cur),hostRemove(cur),cur=next;hostRemove(end)},unmountComponent=(instance,parentSuspense,doRemove)=>{instance.type.__hmrId&&unregisterHMR(instance);const{bum:bum,scope:scope,update:update,subTree:subTree,um:um}=instance;bum&&invokeArrayFns(bum),scope.stop(),update&&(update.active=!1,unmount(subTree,instance,parentSuspense,doRemove)),um&&queuePostRenderEffect(um,parentSuspense),queuePostRenderEffect(()=>{instance.isUnmounted=!0},parentSuspense),parentSuspense&&parentSuspense.pendingBranch&&!parentSuspense.isUnmounted&&instance.asyncDep&&!instance.asyncResolved&&instance.suspenseId===parentSuspense.pendingId&&(parentSuspense.deps--,0===parentSuspense.deps&&parentSuspense.resolve()),devtoolsComponentRemoved(instance)},unmountChildren=(children,parentComponent,parentSuspense,doRemove=!1,optimized=!1,start=0)=>{for(let i=start;i<children.length;i++)unmount(children[i],parentComponent,parentSuspense,doRemove,optimized)},getNextHostNode=vnode=>6&vnode.shapeFlag?getNextHostNode(vnode.component.subTree):128&vnode.shapeFlag?vnode.suspense.next():hostNextSibling(vnode.anchor||vnode.el),render=(vnode,container,isSVG)=>{null==vnode?container._vnode&&unmount(container._vnode,null,null,!0):patch(container._vnode||null,vnode,container,null,null,null,isSVG),flushPostFlushCbs(),container._vnode=vnode},internals={p:patch,um:unmount,m:move,r:remove,mt:mountComponent,mc:mountChildren,pc:patchChildren,pbc:patchBlockChildren,n:getNextHostNode,o:options};let hydrate,hydrateNode;return createHydrationFns&&([hydrate,hydrateNode]=createHydrationFns(internals)),{render:render,hydrate:hydrate,createApp:createAppAPI(render,hydrate)}}function toggleRecurse({effect:effect,update:update},allowed){effect.allowRecurse=update.allowRecurse=allowed}function traverseStaticChildren(n1,n2,shallow=!1){const ch1=n1.children,ch2=n2.children;if(isArray(ch1)&&isArray(ch2))for(let i=0;i<ch1.length;i++){const c1=ch1[i];let c2=ch2[i];1&c2.shapeFlag&&!c2.dynamicChildren&&((c2.patchFlag<=0||32===c2.patchFlag)&&(c2=ch2[i]=cloneIfMounted(ch2[i]),c2.el=c1.el),shallow||traverseStaticChildren(c1,c2)),c2.type!==Comment||c2.el||(c2.el=c1.el)}}function getSequence(arr){const p=arr.slice(),result=[0];let i,j,u,v,c;const len=arr.length;for(i=0;i<len;i++){const arrI=arr[i];if(0!==arrI){if(j=result[result.length-1],arr[j]<arrI){p[i]=j,result.push(i);continue}for(u=0,v=result.length-1;u<v;)c=u+v>>1,arr[result[c]]<arrI?u=c+1:v=c;arrI<arr[result[u]]&&(u>0&&(p[i]=result[u-1]),result[u]=i)}}for(u=result.length,v=result[u-1];u-- >0;)result[u]=v,v=p[v];return result}function moveTeleport(vnode,container,parentAnchor,{o:{insert:insert},m:move},moveType=2){0===moveType&&insert(vnode.targetAnchor,container,parentAnchor);const{el:el,anchor:anchor,shapeFlag:shapeFlag,children:children,props:props}=vnode,isReorder=2===moveType;if(isReorder&&insert(el,container,parentAnchor),(!isReorder||isTeleportDisabled(props))&&16&shapeFlag)for(let i=0;i<children.length;i++)move(children[i],container,parentAnchor,2);isReorder&&insert(anchor,container,parentAnchor)}function hydrateTeleport(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized,{o:{nextSibling:nextSibling,parentNode:parentNode,querySelector:querySelector}},hydrateChildren){const target=vnode.target=resolveTarget(vnode.props,querySelector);if(target){const targetNode=target._lpa||target.firstChild;16&vnode.shapeFlag&&(isTeleportDisabled(vnode.props)?(vnode.anchor=hydrateChildren(nextSibling(node),vnode,parentNode(node),parentComponent,parentSuspense,slotScopeIds,optimized),vnode.targetAnchor=targetNode):(vnode.anchor=nextSibling(node),vnode.targetAnchor=hydrateChildren(targetNode,vnode,target,parentComponent,parentSuspense,slotScopeIds,optimized)),target._lpa=vnode.targetAnchor&&nextSibling(vnode.targetAnchor))}return vnode.anchor&&nextSibling(vnode.anchor)}function resolveComponent(name,maybeSelfReference){return resolveAsset(COMPONENTS,name,!0,maybeSelfReference)||name}function resolveDynamicComponent(component){return isString(component)?resolveAsset(COMPONENTS,component,!1)||component:component||NULL_DYNAMIC_COMPONENT}function resolveDirective(name){return resolveAsset(DIRECTIVES,name)}function resolveAsset(type,name,warnMissing=!0,maybeSelfReference=!1){const instance=currentRenderingInstance||currentInstance;if(instance){const Component=instance.type;if(type===COMPONENTS){const selfName=getComponentName(Component);if(selfName&&(selfName===name||selfName===camelize(name)||selfName===capitalize(camelize(name))))return Component}const res=resolve(instance[type]||Component[type],name)||resolve(instance.appContext[type],name);if(!res&&maybeSelfReference)return Component;if(warnMissing&&!res){const extra=type===COMPONENTS?"\nIf this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.":"";warn$1(`Failed to resolve ${type.slice(0,-1)}: ${name}${extra}`)}return res}warn$1(`resolve${capitalize(type.slice(0,-1))} `+"can only be used in render() or setup().")}function resolve(registry,name){return registry&&(registry[name]||registry[camelize(name)]||registry[capitalize(camelize(name))])}function openBlock(disableTracking=!1){blockStack.push(currentBlock=disableTracking?null:[])}function closeBlock(){blockStack.pop(),currentBlock=blockStack[blockStack.length-1]||null}function setBlockTracking(value){isBlockTreeEnabled+=value}function setupBlock(vnode){return vnode.dynamicChildren=isBlockTreeEnabled>0?currentBlock||EMPTY_ARR:null,closeBlock(),isBlockTreeEnabled>0&&currentBlock&&currentBlock.push(vnode),vnode}function createElementBlock(type,props,children,patchFlag,dynamicProps,shapeFlag){return setupBlock(createBaseVNode(type,props,children,patchFlag,dynamicProps,shapeFlag,!0))}function createBlock(type,props,children,patchFlag,dynamicProps){return setupBlock(createVNode(type,props,children,patchFlag,dynamicProps,!0))}function isVNode(value){return!!value&&!0===value.__v_isVNode}function isSameVNodeType(n1,n2){return!(6&n2.shapeFlag&&hmrDirtyComponents.has(n2.type))&&(n1.type===n2.type&&n1.key===n2.key)}function transformVNodeArgs(transformer){vnodeArgsTransformer=transformer}function createBaseVNode(type,props=null,children=null,patchFlag=0,dynamicProps=null,shapeFlag=(type===Fragment?0:1),isBlockNode=!1,needFullChildrenNormalization=!1){const vnode={__v_isVNode:!0,__v_skip:!0,type:type,props:props,key:props&&normalizeKey(props),ref:props&&normalizeRef(props),scopeId:currentScopeId,slotScopeIds:null,children:children,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:shapeFlag,patchFlag:patchFlag,dynamicProps:dynamicProps,dynamicChildren:null,appContext:null};return needFullChildrenNormalization?(normalizeChildren(vnode,children),128&shapeFlag&&type.normalize(vnode)):children&&(vnode.shapeFlag|=isString(children)?8:16),vnode.key!=vnode.key&&warn$1("VNode created with invalid key (NaN). VNode type:",vnode.type),isBlockTreeEnabled>0&&!isBlockNode&&currentBlock&&(vnode.patchFlag>0||6&shapeFlag)&&32!==vnode.patchFlag&&currentBlock.push(vnode),vnode}function _createVNode(type,props=null,children=null,patchFlag=0,dynamicProps=null,isBlockNode=!1){if(type&&type!==NULL_DYNAMIC_COMPONENT||(type||warn$1(`Invalid vnode type when creating vnode: ${type}.`),type=Comment),isVNode(type)){const cloned=cloneVNode(type,props,!0);return children&&normalizeChildren(cloned,children),cloned}if(isClassComponent(type)&&(type=type.__vccOpts),props){props=guardReactiveProps(props);let{class:klass,style:style}=props;klass&&!isString(klass)&&(props.class=normalizeClass(klass)),isObject(style)&&(isProxy(style)&&!isArray(style)&&(style=extend({},style)),props.style=normalizeStyle(style))}const shapeFlag=isString(type)?1:isSuspense(type)?128:isTeleport(type)?64:isObject(type)?4:isFunction(type)?2:0;return 4&shapeFlag&&isProxy(type)&&(type=toRaw(type),warn$1("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.","\nComponent that was made reactive: ",type)),createBaseVNode(type,props,children,patchFlag,dynamicProps,shapeFlag,isBlockNode,!0)}function guardReactiveProps(props){return props?isProxy(props)||InternalObjectKey in props?extend({},props):props:null}function cloneVNode(vnode,extraProps,mergeRef=!1){const{props:props,ref:ref,patchFlag:patchFlag,children:children}=vnode,mergedProps=extraProps?mergeProps(props||{},extraProps):props,cloned={__v_isVNode:!0,__v_skip:!0,type:vnode.type,props:mergedProps,key:mergedProps&&normalizeKey(mergedProps),ref:extraProps&&extraProps.ref?mergeRef&&ref?isArray(ref)?ref.concat(normalizeRef(extraProps)):[ref,normalizeRef(extraProps)]:normalizeRef(extraProps):ref,scopeId:vnode.scopeId,slotScopeIds:vnode.slotScopeIds,children:-1===patchFlag&&isArray(children)?children.map(deepCloneVNode):children,target:vnode.target,targetAnchor:vnode.targetAnchor,staticCount:vnode.staticCount,shapeFlag:vnode.shapeFlag,patchFlag:extraProps&&vnode.type!==Fragment?-1===patchFlag?16:16|patchFlag:patchFlag,dynamicProps:vnode.dynamicProps,dynamicChildren:vnode.dynamicChildren,appContext:vnode.appContext,dirs:vnode.dirs,transition:vnode.transition,component:vnode.component,suspense:vnode.suspense,ssContent:vnode.ssContent&&cloneVNode(vnode.ssContent),ssFallback:vnode.ssFallback&&cloneVNode(vnode.ssFallback),el:vnode.el,anchor:vnode.anchor};return cloned}function deepCloneVNode(vnode){const cloned=cloneVNode(vnode);return isArray(vnode.children)&&(cloned.children=vnode.children.map(deepCloneVNode)),cloned}function createTextVNode(text=" ",flag=0){return createVNode(Text,null,text,flag)}function createStaticVNode(content,numberOfNodes){const vnode=createVNode(Static,null,content);return vnode.staticCount=numberOfNodes,vnode}function createCommentVNode(text="",asBlock=!1){return asBlock?(openBlock(),createBlock(Comment,null,text)):createVNode(Comment,null,text)}function normalizeVNode(child){return null==child||"boolean"==typeof child?createVNode(Comment):isArray(child)?createVNode(Fragment,null,child.slice()):"object"==typeof child?cloneIfMounted(child):createVNode(Text,null,String(child))}function cloneIfMounted(child){return null===child.el||child.memo?child:cloneVNode(child)}function normalizeChildren(vnode,children){let type=0;const{shapeFlag:shapeFlag}=vnode;if(null==children)children=null;else if(isArray(children))type=16;else if("object"==typeof children){if(65&shapeFlag){const slot=children.default;return void(slot&&(slot._c&&(slot._d=!1),normalizeChildren(vnode,slot()),slot._c&&(slot._d=!0)))}{type=32;const slotFlag=children._;slotFlag||InternalObjectKey in children?3===slotFlag&&currentRenderingInstance&&(1===currentRenderingInstance.slots._?children._=1:(children._=2,vnode.patchFlag|=1024)):children._ctx=currentRenderingInstance}}else isFunction(children)?(children={default:children,_ctx:currentRenderingInstance},type=32):(children=String(children),64&shapeFlag?(type=16,children=[createTextVNode(children)]):type=8);vnode.children=children,vnode.shapeFlag|=type}function mergeProps(...args){const ret={};for(let i=0;i<args.length;i++){const toMerge=args[i];for(const key in toMerge)if("class"===key)ret.class!==toMerge.class&&(ret.class=normalizeClass([ret.class,toMerge.class]));else if("style"===key)ret.style=normalizeStyle([ret.style,toMerge.style]);else if(isOn(key)){const existing=ret[key],incoming=toMerge[key];!incoming||existing===incoming||isArray(existing)&&existing.includes(incoming)||(ret[key]=existing?[].concat(existing,incoming):incoming)}else""!==key&&(ret[key]=toMerge[key])}return ret}function invokeVNodeHook(hook,instance,vnode,prevVNode=null){callWithAsyncErrorHandling(hook,instance,7,[vnode,prevVNode])}function renderList(source,renderItem,cache,index){let ret;const cached=cache&&cache[index];if(isArray(source)||isString(source)){ret=new Array(source.length);for(let i=0,l=source.length;i<l;i++)ret[i]=renderItem(source[i],i,void 0,cached&&cached[i])}else if("number"==typeof source){if(!Number.isInteger(source))return warn$1(`The v-for range expect an integer value but got ${source}.`),[];ret=new Array(source);for(let i=0;i<source;i++)ret[i]=renderItem(i+1,i,void 0,cached&&cached[i])}else if(isObject(source))if(source[Symbol.iterator])ret=Array.from(source,(item,i)=>renderItem(item,i,void 0,cached&&cached[i]));else{const keys=Object.keys(source);ret=new Array(keys.length);for(let i=0,l=keys.length;i<l;i++){const key=keys[i];ret[i]=renderItem(source[key],key,i,cached&&cached[i])}}else ret=[];return cache&&(cache[index]=ret),ret}function createSlots(slots,dynamicSlots){for(let i=0;i<dynamicSlots.length;i++){const slot=dynamicSlots[i];if(isArray(slot))for(let j=0;j<slot.length;j++)slots[slot[j].name]=slot[j].fn;else slot&&(slots[slot.name]=slot.fn)}return slots}function renderSlot(slots,name,props={},fallback,noSlotted){if(currentRenderingInstance.isCE||currentRenderingInstance.parent&&isAsyncWrapper(currentRenderingInstance.parent)&&currentRenderingInstance.parent.isCE)return createVNode("slot","default"===name?null:{name:name},fallback&&fallback());let slot=slots[name];slot&&slot.length>1&&(warn$1("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."),slot=(()=>[])),slot&&slot._c&&(slot._d=!1),openBlock();const validSlotContent=slot&&ensureValidVNode(slot(props)),rendered=createBlock(Fragment,{key:props.key||`_${name}`},validSlotContent||(fallback?fallback():[]),validSlotContent&&1===slots._?64:-2);return!noSlotted&&rendered.scopeId&&(rendered.slotScopeIds=[rendered.scopeId+"-s"]),slot&&slot._c&&(slot._d=!0),rendered}function ensureValidVNode(vnodes){return vnodes.some(child=>!isVNode(child)||child.type!==Comment&&!(child.type===Fragment&&!ensureValidVNode(child.children)))?vnodes:null}function toHandlers(obj){const ret={};if(!isObject(obj))return warn$1("v-on with no argument expects an object value."),ret;for(const key in obj)ret[toHandlerKey(key)]=obj[key];return ret}function createDevRenderContext(instance){const target={};return Object.defineProperty(target,"_",{configurable:!0,enumerable:!1,get:()=>instance}),Object.keys(publicPropertiesMap).forEach(key=>{Object.defineProperty(target,key,{configurable:!0,enumerable:!1,get:()=>publicPropertiesMap[key](instance),set:NOOP})}),target}function exposePropsOnRenderContext(instance){const{ctx:ctx,propsOptions:[propsOptions]}=instance;propsOptions&&Object.keys(propsOptions).forEach(key=>{Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,get:()=>instance.props[key],set:NOOP})})}function exposeSetupStateOnRenderContext(instance){const{ctx:ctx,setupState:setupState}=instance;Object.keys(toRaw(setupState)).forEach(key=>{if(!setupState.__isScriptSetup){if("$"===key[0]||"_"===key[0])return void warn$1(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" `+"which are reserved prefixes for Vue internals.");Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,get:()=>setupState[key],set:NOOP})}})}function createComponentInstance(vnode,parent,suspense){const type=vnode.type,appContext=(parent?parent.appContext:vnode.appContext)||emptyAppContext,instance={uid:uid$1++,vnode:vnode,type:type,parent:parent,appContext:appContext,root:null,next:null,subTree:null,effect:null,update:null,scope:new EffectScope(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:parent?parent.provides:Object.create(appContext.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:normalizePropsOptions(type,appContext),emitsOptions:normalizeEmitsOptions(type,appContext),emit:null,emitted:null,propsDefaults:EMPTY_OBJ,inheritAttrs:type.inheritAttrs,ctx:EMPTY_OBJ,data:EMPTY_OBJ,props:EMPTY_OBJ,attrs:EMPTY_OBJ,slots:EMPTY_OBJ,refs:EMPTY_OBJ,setupState:EMPTY_OBJ,setupContext:null,suspense:suspense,suspenseId:suspense?suspense.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return instance.ctx=createDevRenderContext(instance),instance.root=parent?parent.root:instance,instance.emit=emit$1.bind(null,instance),vnode.ce&&vnode.ce(instance),instance}function validateComponentName(name,config){const appIsNativeTag=config.isNativeTag||NO;(isBuiltInTag(name)||appIsNativeTag(name))&&warn$1("Do not use built-in or reserved HTML elements as component id: "+name)}function isStatefulComponent(instance){return 4&instance.vnode.shapeFlag}function setupComponent(instance,isSSR=!1){isInSSRComponentSetup=isSSR;const{props:props,children:children}=instance.vnode,isStateful=isStatefulComponent(instance);initProps(instance,props,isStateful,isSSR),initSlots(instance,children);const setupResult=isStateful?setupStatefulComponent(instance,isSSR):void 0;return isInSSRComponentSetup=!1,setupResult}function setupStatefulComponent(instance,isSSR){var _a;const Component=instance.type;if(Component.name&&validateComponentName(Component.name,instance.appContext.config),Component.components){const names=Object.keys(Component.components);for(let i=0;i<names.length;i++)validateComponentName(names[i],instance.appContext.config)}if(Component.directives){const names=Object.keys(Component.directives);for(let i=0;i<names.length;i++)validateDirectiveName(names[i])}Component.compilerOptions&&isRuntimeOnly()&&warn$1('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'),instance.accessCache=Object.create(null),instance.proxy=markRaw(new Proxy(instance.ctx,PublicInstanceProxyHandlers)),exposePropsOnRenderContext(instance);const{setup:setup}=Component;if(setup){const setupContext=instance.setupContext=setup.length>1?createSetupContext(instance):null;setCurrentInstance(instance),pauseTracking();const setupResult=callWithErrorHandling(setup,instance,0,[shallowReadonly(instance.props),setupContext]);if(resetTracking(),unsetCurrentInstance(),isPromise(setupResult)){if(setupResult.then(unsetCurrentInstance,unsetCurrentInstance),isSSR)return setupResult.then(resolvedResult=>{handleSetupResult(instance,resolvedResult,isSSR)}).catch(e=>{handleError(e,instance,0)});if(instance.asyncDep=setupResult,!instance.suspense){const name=null!==(_a=Component.name)&&void 0!==_a?_a:"Anonymous"
;warn$1(`Component <${name}>: setup function returned a promise, but no `+"<Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.")}}else handleSetupResult(instance,setupResult,isSSR)}else finishComponentSetup(instance,isSSR)}function handleSetupResult(instance,setupResult,isSSR){isFunction(setupResult)?instance.render=setupResult:isObject(setupResult)?(isVNode(setupResult)&&warn$1("setup() should not return VNodes directly - return a render function instead."),instance.devtoolsRawSetupState=setupResult,instance.setupState=proxyRefs(setupResult),exposeSetupStateOnRenderContext(instance)):void 0!==setupResult&&warn$1(`setup() should return an object. Received: ${null===setupResult?"null":typeof setupResult}`),finishComponentSetup(instance,isSSR)}function registerRuntimeCompiler(_compile){compile=_compile,installWithProxy=(i=>{i.render._rc&&(i.withProxy=new Proxy(i.ctx,RuntimeCompiledPublicInstanceProxyHandlers))})}function finishComponentSetup(instance,isSSR,skipOptions){const Component=instance.type;if(!instance.render){if(!isSSR&&compile&&!Component.render){const template=Component.template;if(template){startMeasure(instance,"compile");const{isCustomElement:isCustomElement,compilerOptions:compilerOptions}=instance.appContext.config,{delimiters:delimiters,compilerOptions:componentCompilerOptions}=Component,finalCompilerOptions=extend(extend({isCustomElement:isCustomElement,delimiters:delimiters},compilerOptions),componentCompilerOptions);Component.render=compile(template,finalCompilerOptions),endMeasure(instance,"compile")}}instance.render=Component.render||NOOP,installWithProxy&&installWithProxy(instance)}setCurrentInstance(instance),pauseTracking(),applyOptions(instance),resetTracking(),unsetCurrentInstance(),Component.render||instance.render!==NOOP||isSSR||(!compile&&Component.template?warn$1('Component provided template option but runtime compilation is not supported in this build of Vue. Use "vue.global.js" instead.'):warn$1("Component is missing template or render function."))}function createAttrsProxy(instance){return new Proxy(instance.attrs,{get:(target,key)=>(markAttrsAccessed(),track(instance,"get","$attrs"),target[key]),set:()=>(warn$1("setupContext.attrs is readonly."),!1),deleteProperty:()=>(warn$1("setupContext.attrs is readonly."),!1)})}function createSetupContext(instance){const expose=exposed=>{instance.exposed&&warn$1("expose() should be called only once per setup()."),instance.exposed=exposed||{}};let attrs;return Object.freeze({get attrs(){return attrs||(attrs=createAttrsProxy(instance))},get slots(){return shallowReadonly(instance.slots)},get emit(){return(event,...args)=>instance.emit(event,...args)},expose:expose})}function getExposeProxy(instance){if(instance.exposed)return instance.exposeProxy||(instance.exposeProxy=new Proxy(proxyRefs(markRaw(instance.exposed)),{get:(target,key)=>key in target?target[key]:key in publicPropertiesMap?publicPropertiesMap[key](instance):void 0}))}function getComponentName(Component){return isFunction(Component)&&Component.displayName||Component.name}function formatComponentName(instance,Component,isRoot=!1){let name=getComponentName(Component);if(!name&&Component.__file){const match=Component.__file.match(/([^/\\]+)\.\w+$/);match&&(name=match[1])}if(!name&&instance&&instance.parent){const inferFromRegistry=registry=>{for(const key in registry)if(registry[key]===Component)return key};name=inferFromRegistry(instance.components||instance.parent.type.components)||inferFromRegistry(instance.appContext.components)}return name?classify(name):isRoot?"App":"Anonymous"}function isClassComponent(value){return isFunction(value)&&"__vccOpts"in value}function defineProps(){return warnRuntimeUsage("defineProps"),null}function defineEmits(){return warnRuntimeUsage("defineEmits"),null}function defineExpose(exposed){warnRuntimeUsage("defineExpose")}function withDefaults(props,defaults){return warnRuntimeUsage("withDefaults"),null}function useSlots(){return getContext().slots}function useAttrs(){return getContext().attrs}function getContext(){const i=getCurrentInstance();return i||warn$1("useContext() called without active instance."),i.setupContext||(i.setupContext=createSetupContext(i))}function mergeDefaults(raw,defaults){const props=isArray(raw)?raw.reduce((normalized,p)=>(normalized[p]={},normalized),{}):raw;for(const key in defaults){const opt=props[key];opt?isArray(opt)||isFunction(opt)?props[key]={type:opt,default:defaults[key]}:opt.default=defaults[key]:null===opt?props[key]={default:defaults[key]}:warn$1(`props default key "${key}" has no corresponding declaration.`)}return props}function createPropsRestProxy(props,excludedKeys){const ret={};for(const key in props)excludedKeys.includes(key)||Object.defineProperty(ret,key,{enumerable:!0,get:()=>props[key]});return ret}function withAsyncContext(getAwaitable){const ctx=getCurrentInstance();ctx||warn$1("withAsyncContext called without active current instance. This is likely a bug.");let awaitable=getAwaitable();return unsetCurrentInstance(),isPromise(awaitable)&&(awaitable=awaitable.catch(e=>{throw setCurrentInstance(ctx),e})),[awaitable,()=>setCurrentInstance(ctx)]}function h(type,propsOrChildren,children){const l=arguments.length;return 2===l?isObject(propsOrChildren)&&!isArray(propsOrChildren)?isVNode(propsOrChildren)?createVNode(type,null,[propsOrChildren]):createVNode(type,propsOrChildren):createVNode(type,null,propsOrChildren):(l>3?children=Array.prototype.slice.call(arguments,2):3===l&&isVNode(children)&&(children=[children]),createVNode(type,propsOrChildren,children))}function initCustomFormatter(){function formatInstance(instance){const blocks=[];instance.type.props&&instance.props&&blocks.push(createInstanceBlock("props",toRaw(instance.props))),instance.setupState!==EMPTY_OBJ&&blocks.push(createInstanceBlock("setup",instance.setupState)),instance.data!==EMPTY_OBJ&&blocks.push(createInstanceBlock("data",toRaw(instance.data)));const computed=extractKeys(instance,"computed");computed&&blocks.push(createInstanceBlock("computed",computed));const injected=extractKeys(instance,"inject");return injected&&blocks.push(createInstanceBlock("injected",injected)),blocks.push(["div",{},["span",{style:keywordStyle.style+";opacity:0.66"},"$ (internal): "],["object",{object:instance}]]),blocks}function createInstanceBlock(type,target){return target=extend({},target),Object.keys(target).length?["div",{style:"line-height:1.25em;margin-bottom:0.6em"},["div",{style:"color:#476582"},type],["div",{style:"padding-left:1.25em"},...Object.keys(target).map(key=>["div",{},["span",keywordStyle,key+": "],formatValue(target[key],!1)])]]:["span",{}]}function formatValue(v,asRaw=!0){return"number"==typeof v?["span",numberStyle,v]:"string"==typeof v?["span",stringStyle,JSON.stringify(v)]:"boolean"==typeof v?["span",keywordStyle,v]:isObject(v)?["object",{object:asRaw?toRaw(v):v}]:["span",stringStyle,String(v)]}function extractKeys(instance,type){const Comp=instance.type;if(isFunction(Comp))return;const extracted={};for(const key in instance.ctx)isKeyOfType(Comp,key,type)&&(extracted[key]=instance.ctx[key]);return extracted}function isKeyOfType(Comp,key,type){const opts=Comp[type];return!!(isArray(opts)&&opts.includes(key)||isObject(opts)&&key in opts)||(!(!Comp.extends||!isKeyOfType(Comp.extends,key,type))||(!(!Comp.mixins||!Comp.mixins.some(m=>isKeyOfType(m,key,type)))||void 0))}function genRefFlag(v){return isShallow(v)?"ShallowRef":v.effect?"ComputedRef":"Ref"}if("undefined"==typeof window)return;const vueStyle={style:"color:#3ba776"},numberStyle={style:"color:#0b1bc9"},stringStyle={style:"color:#b62e24"},keywordStyle={style:"color:#9d288c"},formatter={header:obj=>isObject(obj)?obj.__isVue?["div",vueStyle,"VueInstance"]:isRef(obj)?["div",{},["span",vueStyle,genRefFlag(obj)],"<",formatValue(obj.value),">"]:isReactive(obj)?["div",{},["span",vueStyle,isShallow(obj)?"ShallowReactive":"Reactive"],"<",formatValue(obj),`>${isReadonly(obj)?" (readonly)":""}`]:isReadonly(obj)?["div",{},["span",vueStyle,isShallow(obj)?"ShallowReadonly":"Readonly"],"<",formatValue(obj),">"]:null:null,hasBody:obj=>obj&&obj.__isVue,body(obj){if(obj&&obj.__isVue)return["div",{},...formatInstance(obj.$)]}};window.devtoolsFormatters?window.devtoolsFormatters.push(formatter):window.devtoolsFormatters=[formatter]}function withMemo(memo,render,cache,index){const cached=cache[index];if(cached&&isMemoSame(cached,memo))return cached;const ret=render();return ret.memo=memo.slice(),cache[index]=ret}function isMemoSame(cached,memo){const prev=cached.memo;if(prev.length!=memo.length)return!1;for(let i=0;i<prev.length;i++)if(prev[i]!==memo[i])return!1;return isBlockTreeEnabled>0&&currentBlock&&currentBlock.push(cached),!0}function patchClass(el,value,isSVG){const transitionClasses=el._vtc;transitionClasses&&(value=(value?[value,...transitionClasses]:[...transitionClasses]).join(" ")),null==value?el.removeAttribute("class"):isSVG?el.setAttribute("class",value):el.className=value}function patchStyle(el,prev,next){const style=el.style,isCssString=isString(next);if(next&&!isCssString){for(const key in next)setStyle(style,key,next[key]);if(prev&&!isString(prev))for(const key in prev)null==next[key]&&setStyle(style,key,"")}else{const currentDisplay=style.display;isCssString?prev!==next&&(style.cssText=next):prev&&el.removeAttribute("style"),"_vod"in el&&(style.display=currentDisplay)}}function setStyle(style,name,val){if(isArray(val))val.forEach(v=>setStyle(style,name,v));else if(null==val&&(val=""),name.startsWith("--"))style.setProperty(name,val);else{const prefixed=autoPrefix(style,name);importantRE.test(val)?style.setProperty(hyphenate(prefixed),val.replace(importantRE,""),"important"):style[prefixed]=val}}function autoPrefix(style,rawName){const cached=prefixCache[rawName];if(cached)return cached;let name=camelize(rawName);if("filter"!==name&&name in style)return prefixCache[rawName]=name;name=capitalize(name);for(let i=0;i<prefixes.length;i++){const prefixed=prefixes[i]+name;if(prefixed in style)return prefixCache[rawName]=prefixed}return rawName}function patchAttr(el,key,value,isSVG,instance){if(isSVG&&key.startsWith("xlink:"))null==value?el.removeAttributeNS(xlinkNS,key.slice(6,key.length)):el.setAttributeNS(xlinkNS,key,value);else{const isBoolean=isSpecialBooleanAttr(key);null==value||isBoolean&&!includeBooleanAttr(value)?el.removeAttribute(key):el.setAttribute(key,isBoolean?"":value)}}function patchDOMProp(el,key,value,prevChildren,parentComponent,parentSuspense,unmountChildren){if("innerHTML"===key||"textContent"===key)return prevChildren&&unmountChildren(prevChildren,parentComponent,parentSuspense),void(el[key]=null==value?"":value);if("value"===key&&"PROGRESS"!==el.tagName&&!el.tagName.includes("-")){el._value=value;const newValue=null==value?"":value;return el.value===newValue&&"OPTION"!==el.tagName||(el.value=newValue),void(null==value&&el.removeAttribute(key))}let needRemove=!1;if(""===value||null==value){const type=typeof el[key];"boolean"===type?value=includeBooleanAttr(value):null==value&&"string"===type?(value="",needRemove=!0):"number"===type&&(value=0,needRemove=!0)}try{el[key]=value}catch(e){warn$1(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: `+`value ${value} is invalid.`,e)}needRemove&&el.removeAttribute(key)}function addEventListener(el,event,handler,options){el.addEventListener(event,handler,options)}function removeEventListener(el,event,handler,options){el.removeEventListener(event,handler,options)}function patchEvent(el,rawName,prevValue,nextValue,instance=null){const invokers=el._vei||(el._vei={}),existingInvoker=invokers[rawName];if(nextValue&&existingInvoker)existingInvoker.value=nextValue;else{const[name,options]=parseName(rawName);if(nextValue){const invoker=invokers[rawName]=createInvoker(nextValue,instance);addEventListener(el,name,invoker,options)}else existingInvoker&&(removeEventListener(el,name,existingInvoker,options),invokers[rawName]=void 0)}}function parseName(name){let options;if(optionsModifierRE.test(name)){let m;for(options={};m=name.match(optionsModifierRE);)name=name.slice(0,name.length-m[0].length),options[m[0].toLowerCase()]=!0}return[hyphenate(name.slice(2)),options]}function createInvoker(initialValue,instance){const invoker=e=>{const timeStamp=e.timeStamp||_getNow();(skipTimestampCheck||timeStamp>=invoker.attached-1)&&callWithAsyncErrorHandling(patchStopImmediatePropagation(e,invoker.value),instance,5,[e])};return invoker.value=initialValue,invoker.attached=getNow(),invoker}function patchStopImmediatePropagation(e,value){if(isArray(value)){const originalStop=e.stopImmediatePropagation;return e.stopImmediatePropagation=(()=>{originalStop.call(e),e._stopped=!0}),value.map(fn=>e=>!e._stopped&&fn&&fn(e))}return value}function shouldSetAsProp(el,key,value,isSVG){return isSVG?"innerHTML"===key||"textContent"===key||!!(key in el&&nativeOnRE.test(key)&&isFunction(value)):"spellcheck"!==key&&"draggable"!==key&&"translate"!==key&&("form"!==key&&(("list"!==key||"INPUT"!==el.tagName)&&(("type"!==key||"TEXTAREA"!==el.tagName)&&((!nativeOnRE.test(key)||!isString(value))&&key in el))))}function defineCustomElement(options,hydate){const Comp=defineComponent(options);class VueCustomElement extends VueElement{constructor(initialProps){super(Comp,initialProps,hydate)}}return VueCustomElement.def=Comp,VueCustomElement}function useCssModule(name="$style"){return warn$1("useCssModule() is not supported in the global build."),EMPTY_OBJ}function useCssVars(getter){const instance=getCurrentInstance();if(!instance)return void warn$1("useCssVars is called without current active component instance.");const setVars=()=>setVarsOnVNode(instance.subTree,getter(instance.proxy));watchPostEffect(setVars),onMounted(()=>{const ob=new MutationObserver(setVars);ob.observe(instance.subTree.el.parentNode,{childList:!0}),onUnmounted(()=>ob.disconnect())})}function setVarsOnVNode(vnode,vars){if(128&vnode.shapeFlag){const suspense=vnode.suspense;vnode=suspense.activeBranch,suspense.pendingBranch&&!suspense.isHydrating&&suspense.effects.push(()=>{setVarsOnVNode(suspense.activeBranch,vars)})}for(;vnode.component;)vnode=vnode.component.subTree;if(1&vnode.shapeFlag&&vnode.el)setVarsOnNode(vnode.el,vars);else if(vnode.type===Fragment)vnode.children.forEach(c=>setVarsOnVNode(c,vars));else if(vnode.type===Static){let{el:el,anchor:anchor}=vnode;for(;el&&(setVarsOnNode(el,vars),el!==anchor);)el=el.nextSibling}}function setVarsOnNode(el,vars){if(1===el.nodeType){const style=el.style;for(const key in vars)style.setProperty(`--${key}`,vars[key])}}function resolveTransitionProps(rawProps){const baseProps={};for(const key in rawProps)key in DOMTransitionPropsValidators||(baseProps[key]=rawProps[key]);if(!1===rawProps.css)return baseProps;const{name:name="v",type:type,duration:duration,enterFromClass:enterFromClass=`${name}-enter-from`,enterActiveClass:enterActiveClass=`${name}-enter-active`,enterToClass:enterToClass=`${name}-enter-to`,appearFromClass:appearFromClass=enterFromClass,appearActiveClass:appearActiveClass=enterActiveClass,appearToClass:appearToClass=enterToClass,leaveFromClass:leaveFromClass=`${name}-leave-from`,leaveActiveClass:leaveActiveClass=`${name}-leave-active`,leaveToClass:leaveToClass=`${name}-leave-to`}=rawProps,durations=normalizeDuration(duration),enterDuration=durations&&durations[0],leaveDuration=durations&&durations[1],{onBeforeEnter:onBeforeEnter,onEnter:onEnter,onEnterCancelled:onEnterCancelled,onLeave:onLeave,onLeaveCancelled:onLeaveCancelled,onBeforeAppear:onBeforeAppear=onBeforeEnter,onAppear:onAppear=onEnter,onAppearCancelled:onAppearCancelled=onEnterCancelled}=baseProps,finishEnter=(el,isAppear,done)=>{removeTransitionClass(el,isAppear?appearToClass:enterToClass),removeTransitionClass(el,isAppear?appearActiveClass:enterActiveClass),done&&done()},finishLeave=(el,done)=>{removeTransitionClass(el,leaveToClass),removeTransitionClass(el,leaveActiveClass),done&&done()},makeEnterHook=isAppear=>(el,done)=>{const hook=isAppear?onAppear:onEnter,resolve=()=>finishEnter(el,isAppear,done);callHook$1(hook,[el,resolve]),nextFrame(()=>{removeTransitionClass(el,isAppear?appearFromClass:enterFromClass),addTransitionClass(el,isAppear?appearToClass:enterToClass),hasExplicitCallback(hook)||whenTransitionEnds(el,type,enterDuration,resolve)})};return extend(baseProps,{onBeforeEnter(el){callHook$1(onBeforeEnter,[el]),addTransitionClass(el,enterFromClass),addTransitionClass(el,enterActiveClass)},onBeforeAppear(el){callHook$1(onBeforeAppear,[el]),addTransitionClass(el,appearFromClass),addTransitionClass(el,appearActiveClass)},onEnter:makeEnterHook(!1),onAppear:makeEnterHook(!0),onLeave(el,done){const resolve=()=>finishLeave(el,done);addTransitionClass(el,leaveFromClass),forceReflow(),addTransitionClass(el,leaveActiveClass),nextFrame(()=>{removeTransitionClass(el,leaveFromClass),addTransitionClass(el,leaveToClass),hasExplicitCallback(onLeave)||whenTransitionEnds(el,type,leaveDuration,resolve)}),callHook$1(onLeave,[el,resolve])},onEnterCancelled(el){finishEnter(el,!1),callHook$1(onEnterCancelled,[el])},onAppearCancelled(el){finishEnter(el,!0),callHook$1(onAppearCancelled,[el])},onLeaveCancelled(el){finishLeave(el),callHook$1(onLeaveCancelled,[el])}})}function normalizeDuration(duration){if(null==duration)return null;if(isObject(duration))return[NumberOf(duration.enter),NumberOf(duration.leave)];{const n=NumberOf(duration);return[n,n]}}function NumberOf(val){const res=toNumber(val);return validateDuration(res),res}function validateDuration(val){"number"!=typeof val?warn$1("<transition> explicit duration is not a valid number - "+`got ${JSON.stringify(val)}.`):isNaN(val)&&warn$1("<transition> explicit duration is NaN - the duration expression might be incorrect.")}function addTransitionClass(el,cls){cls.split(/\s+/).forEach(c=>c&&el.classList.add(c)),(el._vtc||(el._vtc=new Set)).add(cls)}function removeTransitionClass(el,cls){cls.split(/\s+/).forEach(c=>c&&el.classList.remove(c));const{_vtc:_vtc}=el;_vtc&&(_vtc.delete(cls),_vtc.size||(el._vtc=void 0))}function nextFrame(cb){requestAnimationFrame(()=>{requestAnimationFrame(cb)})}function whenTransitionEnds(el,expectedType,explicitTimeout,resolve){const id=el._endId=++endId,resolveIfNotStale=()=>{id===el._endId&&resolve()};if(explicitTimeout)return setTimeout(resolveIfNotStale,explicitTimeout);const{type:type,timeout:timeout,propCount:propCount}=getTransitionInfo(el,expectedType);if(!type)return resolve();const endEvent=type+"end";let ended=0;const end=()=>{el.removeEventListener(endEvent,onEnd),resolveIfNotStale()},onEnd=e=>{e.target===el&&++ended>=propCount&&end()};setTimeout(()=>{ended<propCount&&end()},timeout+1),el.addEventListener(endEvent,onEnd)}function getTransitionInfo(el,expectedType){const styles=window.getComputedStyle(el),getStyleProperties=key=>(styles[key]||"").split(", "),transitionDelays=getStyleProperties(TRANSITION+"Delay"),transitionDurations=getStyleProperties(TRANSITION+"Duration"),transitionTimeout=getTimeout(transitionDelays,transitionDurations),animationDelays=getStyleProperties(ANIMATION+"Delay"),animationDurations=getStyleProperties(ANIMATION+"Duration"),animationTimeout=getTimeout(animationDelays,animationDurations);let type=null,timeout=0,propCount=0;expectedType===TRANSITION?transitionTimeout>0&&(type=TRANSITION,timeout=transitionTimeout,propCount=transitionDurations.length):expectedType===ANIMATION?animationTimeout>0&&(type=ANIMATION,timeout=animationTimeout,propCount=animationDurations.length):(timeout=Math.max(transitionTimeout,animationTimeout),type=timeout>0?transitionTimeout>animationTimeout?TRANSITION:ANIMATION:null,propCount=type?type===TRANSITION?transitionDurations.length:animationDurations.length:0);const hasTransform=type===TRANSITION&&/\b(transform|all)(,|$)/.test(styles[TRANSITION+"Property"]);return{type:type,timeout:timeout,propCount:propCount,hasTransform:hasTransform}}function getTimeout(delays,durations){for(;delays.length<durations.length;)delays=delays.concat(delays);return Math.max(...durations.map((d,i)=>toMs(d)+toMs(delays[i])))}function toMs(s){return 1e3*Number(s.slice(0,-1).replace(",","."))}function forceReflow(){return document.body.offsetHeight}function callPendingCbs(c){const el=c.el;el._moveCb&&el._moveCb(),el._enterCb&&el._enterCb()}function recordPosition(c){newPositionMap.set(c,c.el.getBoundingClientRect())}function applyTranslation(c){const oldPos=positionMap.get(c),newPos=newPositionMap.get(c),dx=oldPos.left-newPos.left,dy=oldPos.top-newPos.top;if(dx||dy){const s=c.el.style;return s.transform=s.webkitTransform=`translate(${dx}px,${dy}px)`,s.transitionDuration="0s",c}}function hasCSSTransform(el,root,moveClass){const clone=el.cloneNode();el._vtc&&el._vtc.forEach(cls=>{cls.split(/\s+/).forEach(c=>c&&clone.classList.remove(c))}),moveClass.split(/\s+/).forEach(c=>c&&clone.classList.add(c)),clone.style.display="none";const container=1===root.nodeType?root:root.parentNode;container.appendChild(clone);const{hasTransform:hasTransform}=getTransitionInfo(clone);return container.removeChild(clone),hasTransform}function onCompositionStart(e){e.target.composing=!0}function onCompositionEnd(e){const target=e.target;target.composing&&(target.composing=!1,trigger$1(target,"input"))}function trigger$1(el,type){const e=document.createEvent("HTMLEvents");e.initEvent(type,!0,!0),el.dispatchEvent(e)}function setChecked(el,{value:value,oldValue:oldValue},vnode){el._modelValue=value,isArray(value)?el.checked=looseIndexOf(value,vnode.props.value)>-1:isSet(value)?el.checked=value.has(vnode.props.value):value!==oldValue&&(el.checked=looseEqual(value,getCheckboxValue(el,!0)))}function setSelected(el,value){const isMultiple=el.multiple;if(!isMultiple||isArray(value)||isSet(value)){for(let i=0,l=el.options.length;i<l;i++){const option=el.options[i],optionValue=getValue(option);if(isMultiple)isArray(value)?option.selected=looseIndexOf(value,optionValue)>-1:option.selected=value.has(optionValue);else if(looseEqual(getValue(option),value))return void(el.selectedIndex!==i&&(el.selectedIndex=i))}isMultiple||-1===el.selectedIndex||(el.selectedIndex=-1)}else warn$1("<select multiple v-model> expects an Array or Set value for its binding, "+`but got ${Object.prototype.toString.call(value).slice(8,-1)}.`)}function getValue(el){return"_value"in el?el._value:el.value}function getCheckboxValue(el,checked){const key=checked?"_trueValue":"_falseValue";return key in el?el[key]:checked}function callModelHook(el,binding,vnode,prevVNode,hook){let modelToUse;switch(el.tagName){case"SELECT":modelToUse=vModelSelect;break;case"TEXTAREA":modelToUse=vModelText;break;default:switch(vnode.props&&vnode.props.type){case"checkbox":modelToUse=vModelCheckbox;break;case"radio":modelToUse=vModelRadio;break;default:modelToUse=vModelText}}const fn=modelToUse[hook];fn&&fn(el,binding,vnode,prevVNode)}function setDisplay(el,value){el.style.display=value?el._vod:"none"}function ensureRenderer(){return renderer||(renderer=createRenderer(rendererOptions))}function ensureHydrationRenderer(){return renderer=enabledHydration?renderer:createHydrationRenderer(rendererOptions),enabledHydration=!0,renderer}function injectNativeTagCheck(app){Object.defineProperty(app.config,"isNativeTag",{value:tag=>isHTMLTag(tag)||isSVGTag(tag),writable:!1})}function injectCompilerOptionsCheck(app){if(isRuntimeOnly()){const isCustomElement=app.config.isCustomElement;Object.defineProperty(app.config,"isCustomElement",{get:()=>isCustomElement,set(){warn$1("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.")}});const compilerOptions=app.config.compilerOptions,msg='The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom';Object.defineProperty(app.config,"compilerOptions",{get:()=>(warn$1(msg),compilerOptions),set(){warn$1(msg)}})}}function normalizeContainer(container){if(isString(container)){const res=document.querySelector(container);return res||warn$1(`Failed to mount app: mount target selector "${container}" returned null.`),res}return window.ShadowRoot&&container instanceof window.ShadowRoot&&"closed"===container.mode&&warn$1('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'),container}function initDev(){console.info("You are running a development build of Vue.\nMake sure to use the production build (*.prod.js) when deploying for production."),initCustomFormatter()}function defaultOnError(error){throw error}function defaultOnWarn(msg){console.warn(`[Vue warn] ${msg.message}`)}function createCompilerError(code,loc,messages,additionalMessage){const msg=(messages||errorMessages)[code]+(additionalMessage||""),error=new SyntaxError(String(msg));return error.code=code,error.loc=loc,error}function registerRuntimeHelpers(helpers){Object.getOwnPropertySymbols(helpers).forEach(s=>{helperNameMap[s]=helpers[s]})}function createRoot(children,loc=locStub){return{type:0,children:children,helpers:[],components:[],directives:[],hoists:[],imports:[],cached:0,temps:0,codegenNode:void 0,loc:loc}}function createVNodeCall(context,tag,props,children,patchFlag,dynamicProps,directives,isBlock=!1,disableTracking=!1,isComponent=!1,loc=locStub){return context&&(isBlock?(context.helper(OPEN_BLOCK),context.helper(getVNodeBlockHelper(context.inSSR,isComponent))):context.helper(getVNodeHelper(context.inSSR,isComponent)),directives&&context.helper(WITH_DIRECTIVES)),{type:13,tag:tag,props:props,children:children,patchFlag:patchFlag,dynamicProps:dynamicProps,directives:directives,isBlock:isBlock,disableTracking:disableTracking,isComponent:isComponent,loc:loc}}function createArrayExpression(elements,loc=locStub){return{type:17,loc:loc,elements:elements}}function createObjectExpression(properties,loc=locStub){return{type:15,loc:loc,properties:properties}}function createObjectProperty(key,value){return{type:16,loc:locStub,key:isString(key)?createSimpleExpression(key,!0):key,value:value}}function createSimpleExpression(content,isStatic=!1,loc=locStub,constType=0){return{type:4,loc:loc,content:content,isStatic:isStatic,constType:isStatic?3:constType}}function createCompoundExpression(children,loc=locStub){return{type:8,loc:loc,children:children}}function createCallExpression(callee,args=[],loc=locStub){return{type:14,loc:loc,callee:callee,arguments:args}}function createFunctionExpression(params,returns,newline=!1,isSlot=!1,loc=locStub){return{type:18,params:params,returns:returns,newline:newline,isSlot:isSlot,loc:loc}}function createConditionalExpression(test,consequent,alternate,newline=!0){return{type:19,test:test,consequent:consequent,alternate:alternate,newline:newline,loc:locStub}}function createCacheExpression(index,value,isVNode=!1){return{type:20,index:index,value:value,isVNode:isVNode,loc:locStub}}function createBlockStatement(body){return{type:21,body:body,loc:locStub}}function isCoreComponent(tag){return isBuiltInType(tag,"Teleport")?TELEPORT:isBuiltInType(tag,"Suspense")?SUSPENSE:isBuiltInType(tag,"KeepAlive")?KEEP_ALIVE:isBuiltInType(tag,"BaseTransition")?BASE_TRANSITION:void 0}function getInnerRange(loc,offset,length){const source=loc.source.slice(offset,offset+length),newLoc={source:source,start:advancePositionWithClone(loc.start,loc.source,offset),end:loc.end};return null!=length&&(newLoc.end=advancePositionWithClone(loc.start,loc.source,offset+length)),newLoc}function advancePositionWithClone(pos,source,numberOfCharacters=source.length){return advancePositionWithMutation(extend({},pos),source,numberOfCharacters)}function advancePositionWithMutation(pos,source,numberOfCharacters=source.length){let linesCount=0,lastNewLinePos=-1;for(let i=0;i<numberOfCharacters;i++)10===source.charCodeAt(i)&&(linesCount++,lastNewLinePos=i);return pos.offset+=numberOfCharacters,pos.line+=linesCount,pos.column=-1===lastNewLinePos?pos.column+numberOfCharacters:numberOfCharacters-lastNewLinePos,pos}function assert(condition,msg){if(!condition)throw new Error(msg||"unexpected compiler condition")}function findDir(node,name,allowEmpty=!1){for(let i=0;i<node.props.length;i++){const p=node.props[i];if(7===p.type&&(allowEmpty||p.exp)&&(isString(name)?p.name===name:name.test(p.name)))return p}}function findProp(node,name,dynamicOnly=!1,allowEmpty=!1){for(let i=0;i<node.props.length;i++){const p=node.props[i];if(6===p.type){if(dynamicOnly)continue;if(p.name===name&&(p.value||allowEmpty))return p}else if("bind"===p.name&&(p.exp||allowEmpty)&&isStaticArgOf(p.arg,name))return p}}function isStaticArgOf(arg,name){return!(!arg||!isStaticExp(arg)||arg.content!==name)}function hasDynamicKeyVBind(node){return node.props.some(p=>!(7!==p.type||"bind"!==p.name||p.arg&&4===p.arg.type&&p.arg.isStatic))}function isText(node){return 5===node.type||2===node.type}function isVSlot(p){return 7===p.type&&"slot"===p.name}function isTemplateNode(node){return 1===node.type&&3===node.tagType}function isSlotOutlet(node){return 1===node.type&&2===node.tagType}function getVNodeHelper(ssr,isComponent){return ssr||isComponent?CREATE_VNODE:CREATE_ELEMENT_VNODE}function getVNodeBlockHelper(ssr,isComponent){return ssr||isComponent?CREATE_BLOCK:CREATE_ELEMENT_BLOCK}function getUnnormalizedProps(props,callPath=[]){if(props&&!isString(props)&&14===props.type){const callee=props.callee;if(!isString(callee)&&propsHelperSet.has(callee))return getUnnormalizedProps(props.arguments[0],callPath.concat(props))}return[props,callPath]}function injectProp(node,prop,context){let propsWithInjection,parentCall,props=13===node.type?node.props:node.arguments[2],callPath=[];if(props&&!isString(props)&&14===props.type){const ret=getUnnormalizedProps(props);props=ret[0],callPath=ret[1],parentCall=callPath[callPath.length-1]}if(null==props||isString(props))propsWithInjection=createObjectExpression([prop]);else if(14===props.type){const first=props.arguments[0];isString(first)||15!==first.type?props.callee===TO_HANDLERS?propsWithInjection=createCallExpression(context.helper(MERGE_PROPS),[createObjectExpression([prop]),props]):props.arguments.unshift(createObjectExpression([prop])):first.properties.unshift(prop),!propsWithInjection&&(propsWithInjection=props)}else if(15===props.type){let alreadyExists=!1;if(4===prop.key.type){const propKeyName=prop.key.content;alreadyExists=props.properties.some(p=>4===p.key.type&&p.key.content===propKeyName)}alreadyExists||props.properties.unshift(prop),propsWithInjection=props}else propsWithInjection=createCallExpression(context.helper(MERGE_PROPS),[createObjectExpression([prop]),props]),parentCall&&parentCall.callee===GUARD_REACTIVE_PROPS&&(parentCall=callPath[callPath.length-2]);13===node.type?parentCall?parentCall.arguments[0]=propsWithInjection:node.props=propsWithInjection:parentCall?parentCall.arguments[0]=propsWithInjection:node.arguments[2]=propsWithInjection}function toValidAssetId(name,type){return`_${type}_${name.replace(/[^\w]/g,(searchValue,replaceValue)=>"-"===searchValue?"_":name.charCodeAt(replaceValue).toString())}`}function getMemoedVNodeCall(node){return 14===node.type&&node.callee===WITH_MEMO?node.arguments[1].returns:node}function makeBlock(node,{helper:helper,removeHelper:removeHelper,inSSR:inSSR}){node.isBlock||(node.isBlock=!0,removeHelper(getVNodeHelper(inSSR,node.isComponent)),helper(OPEN_BLOCK),helper(getVNodeBlockHelper(inSSR,node.isComponent)))}function baseParse(content,options={}){const context=createParserContext(content,options),start=getCursor(context)
;return createRoot(parseChildren(context,0,[]),getSelection(context,start))}function createParserContext(content,rawOptions){const options=extend({},defaultParserOptions);let key;for(key in rawOptions)options[key]=void 0===rawOptions[key]?defaultParserOptions[key]:rawOptions[key];return{options:options,column:1,line:1,offset:0,originalSource:content,source:content,inPre:!1,inVPre:!1,onWarn:options.onWarn}}function parseChildren(context,mode,ancestors){const parent=last(ancestors),ns=parent?parent.ns:0,nodes=[];for(;!isEnd(context,mode,ancestors);){const s=context.source;let node=void 0;if(0===mode||1===mode)if(!context.inVPre&&startsWith(s,context.options.delimiters[0]))node=parseInterpolation(context,mode);else if(0===mode&&"<"===s[0])if(1===s.length)emitError(context,5,1);else if("!"===s[1])startsWith(s,"<!--")?node=parseComment(context):startsWith(s,"<!DOCTYPE")?node=parseBogusComment(context):startsWith(s,"<![CDATA[")?0!==ns?node=parseCDATA(context,ancestors):(emitError(context,1),node=parseBogusComment(context)):(emitError(context,11),node=parseBogusComment(context));else if("/"===s[1])if(2===s.length)emitError(context,5,2);else{if(">"===s[2]){emitError(context,14,2),advanceBy(context,3);continue}if(/[a-z]/i.test(s[2])){emitError(context,23),parseTag(context,1,parent);continue}emitError(context,12,2),node=parseBogusComment(context)}else/[a-z]/i.test(s[1])?node=parseElement(context,ancestors):"?"===s[1]?(emitError(context,21,1),node=parseBogusComment(context)):emitError(context,12,1);if(node||(node=parseText(context,mode)),isArray(node))for(let i=0;i<node.length;i++)pushNode(nodes,node[i]);else pushNode(nodes,node)}let removedWhitespace=!1;if(2!==mode&&1!==mode){const shouldCondense="preserve"!==context.options.whitespace;for(let i=0;i<nodes.length;i++){const node=nodes[i];if(context.inPre||2!==node.type)3!==node.type||context.options.comments||(removedWhitespace=!0,nodes[i]=null);else if(/[^\t\r\n\f ]/.test(node.content))shouldCondense&&(node.content=node.content.replace(/[\t\r\n\f ]+/g," "));else{const prev=nodes[i-1],next=nodes[i+1];!prev||!next||shouldCondense&&(3===prev.type||3===next.type||1===prev.type&&1===next.type&&/[\r\n]/.test(node.content))?(removedWhitespace=!0,nodes[i]=null):node.content=" "}}if(context.inPre&&parent&&context.options.isPreTag(parent.tag)){const first=nodes[0];first&&2===first.type&&(first.content=first.content.replace(/^\r?\n/,""))}}return removedWhitespace?nodes.filter(Boolean):nodes}function pushNode(nodes,node){if(2===node.type){const prev=last(nodes);if(prev&&2===prev.type&&prev.loc.end.offset===node.loc.start.offset)return prev.content+=node.content,prev.loc.end=node.loc.end,void(prev.loc.source+=node.loc.source)}nodes.push(node)}function parseCDATA(context,ancestors){advanceBy(context,9);const nodes=parseChildren(context,3,ancestors);return 0===context.source.length?emitError(context,6):advanceBy(context,3),nodes}function parseComment(context){const start=getCursor(context);let content;const match=/--(\!)?>/.exec(context.source);if(match){match.index<=3&&emitError(context,0),match[1]&&emitError(context,10),content=context.source.slice(4,match.index);const s=context.source.slice(0,match.index);let prevIndex=1,nestedIndex=0;for(;-1!==(nestedIndex=s.indexOf("<!--",prevIndex));)advanceBy(context,nestedIndex-prevIndex+1),nestedIndex+4<s.length&&emitError(context,16),prevIndex=nestedIndex+1;advanceBy(context,match.index+match[0].length-prevIndex+1)}else content=context.source.slice(4),advanceBy(context,context.source.length),emitError(context,7);return{type:3,content:content,loc:getSelection(context,start)}}function parseBogusComment(context){const start=getCursor(context),contentStart="?"===context.source[1]?1:2;let content;const closeIndex=context.source.indexOf(">");return-1===closeIndex?(content=context.source.slice(contentStart),advanceBy(context,context.source.length)):(content=context.source.slice(contentStart,closeIndex),advanceBy(context,closeIndex+1)),{type:3,content:content,loc:getSelection(context,start)}}function parseElement(context,ancestors){const wasInPre=context.inPre,wasInVPre=context.inVPre,parent=last(ancestors),element=parseTag(context,0,parent),isPreBoundary=context.inPre&&!wasInPre,isVPreBoundary=context.inVPre&&!wasInVPre;if(element.isSelfClosing||context.options.isVoidTag(element.tag))return isPreBoundary&&(context.inPre=!1),isVPreBoundary&&(context.inVPre=!1),element;ancestors.push(element);const mode=context.options.getTextMode(element,parent),children=parseChildren(context,mode,ancestors);if(ancestors.pop(),element.children=children,startsWithEndTagOpen(context.source,element.tag))parseTag(context,1,parent);else if(emitError(context,24,0,element.loc.start),0===context.source.length&&"script"===element.tag.toLowerCase()){const first=children[0];first&&startsWith(first.loc.source,"<!--")&&emitError(context,8)}return element.loc=getSelection(context,element.loc.start),isPreBoundary&&(context.inPre=!1),isVPreBoundary&&(context.inVPre=!1),element}function parseTag(context,type,parent){const start=getCursor(context),match=/^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source),tag=match[1],ns=context.options.getNamespace(tag,parent);advanceBy(context,match[0].length),advanceSpaces(context);const cursor=getCursor(context),currentSource=context.source;context.options.isPreTag(tag)&&(context.inPre=!0);let props=parseAttributes(context,type);0===type&&!context.inVPre&&props.some(p=>7===p.type&&"pre"===p.name)&&(context.inVPre=!0,extend(context,cursor),context.source=currentSource,props=parseAttributes(context,type).filter(p=>"v-pre"!==p.name));let isSelfClosing=!1;if(0===context.source.length?emitError(context,9):(isSelfClosing=startsWith(context.source,"/>"),1===type&&isSelfClosing&&emitError(context,4),advanceBy(context,isSelfClosing?2:1)),1===type)return;let tagType=0;return context.inVPre||("slot"===tag?tagType=2:"template"===tag?props.some(p=>7===p.type&&isSpecialTemplateDirective(p.name))&&(tagType=3):isComponent(tag,props,context)&&(tagType=1)),{type:1,ns:ns,tag:tag,tagType:tagType,props:props,isSelfClosing:isSelfClosing,children:[],loc:getSelection(context,start),codegenNode:void 0}}function isComponent(tag,props,context){const options=context.options;if(options.isCustomElement(tag))return!1;if("component"===tag||/^[A-Z]/.test(tag)||isCoreComponent(tag)||options.isBuiltInComponent&&options.isBuiltInComponent(tag)||options.isNativeTag&&!options.isNativeTag(tag))return!0;for(let i=0;i<props.length;i++){const p=props[i];if(6===p.type){if("is"===p.name&&p.value&&p.value.content.startsWith("vue:"))return!0}else{if("is"===p.name)return!0;"bind"===p.name&&isStaticArgOf(p.arg,"is")}}}function parseAttributes(context,type){const props=[],attributeNames=new Set;for(;context.source.length>0&&!startsWith(context.source,">")&&!startsWith(context.source,"/>");){if(startsWith(context.source,"/")){emitError(context,22),advanceBy(context,1),advanceSpaces(context);continue}1===type&&emitError(context,3);const attr=parseAttribute(context,attributeNames);6===attr.type&&attr.value&&"class"===attr.name&&(attr.value.content=attr.value.content.replace(/\s+/g," ").trim()),0===type&&props.push(attr),/^[^\t\r\n\f />]/.test(context.source)&&emitError(context,15),advanceSpaces(context)}return props}function parseAttribute(context,nameSet){const start=getCursor(context),match=/^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source),name=match[0];nameSet.has(name)&&emitError(context,2),nameSet.add(name),"="===name[0]&&emitError(context,19);{const pattern=/["'<]/g;let m;for(;m=pattern.exec(name);)emitError(context,17,m.index)}advanceBy(context,name.length);let value=void 0;/^[\t\r\n\f ]*=/.test(context.source)&&(advanceSpaces(context),advanceBy(context,1),advanceSpaces(context),value=parseAttributeValue(context),value||emitError(context,13));const loc=getSelection(context,start);if(!context.inVPre&&/^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)){const match=/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);let arg,isPropShorthand=startsWith(name,"."),dirName=match[1]||(isPropShorthand||startsWith(name,":")?"bind":startsWith(name,"@")?"on":"slot");if(match[2]){const isSlot="slot"===dirName,startOffset=name.lastIndexOf(match[2]),loc=getSelection(context,getNewPosition(context,start,startOffset),getNewPosition(context,start,startOffset+match[2].length+(isSlot&&match[3]||"").length));let content=match[2],isStatic=!0;content.startsWith("[")?(isStatic=!1,content.endsWith("]")?content=content.slice(1,content.length-1):(emitError(context,27),content=content.slice(1))):isSlot&&(content+=match[3]||""),arg={type:4,content:content,isStatic:isStatic,constType:isStatic?3:0,loc:loc}}if(value&&value.isQuoted){const valueLoc=value.loc;valueLoc.start.offset++,valueLoc.start.column++,valueLoc.end=advancePositionWithClone(valueLoc.start,value.content),valueLoc.source=valueLoc.source.slice(1,-1)}const modifiers=match[3]?match[3].slice(1).split("."):[];return isPropShorthand&&modifiers.push("prop"),{type:7,name:dirName,exp:value&&{type:4,content:value.content,isStatic:!1,constType:0,loc:value.loc},arg:arg,modifiers:modifiers,loc:loc}}return!context.inVPre&&startsWith(name,"v-")&&emitError(context,26),{type:6,name:name,value:value&&{type:2,content:value.content,loc:value.loc},loc:loc}}function parseAttributeValue(context){const start=getCursor(context);let content;const quote=context.source[0],isQuoted='"'===quote||"'"===quote;if(isQuoted){advanceBy(context,1);const endIndex=context.source.indexOf(quote);-1===endIndex?content=parseTextData(context,context.source.length,4):(content=parseTextData(context,endIndex,4),advanceBy(context,1))}else{const match=/^[^\t\r\n\f >]+/.exec(context.source);if(!match)return;const unexpectedChars=/["'<=`]/g;let m;for(;m=unexpectedChars.exec(match[0]);)emitError(context,18,m.index);content=parseTextData(context,match[0].length,4)}return{content:content,isQuoted:isQuoted,loc:getSelection(context,start)}}function parseInterpolation(context,mode){const[open,close]=context.options.delimiters,closeIndex=context.source.indexOf(close,open.length);if(-1===closeIndex)return void emitError(context,25);const start=getCursor(context);advanceBy(context,open.length);const innerStart=getCursor(context),innerEnd=getCursor(context),rawContentLength=closeIndex-open.length,rawContent=context.source.slice(0,rawContentLength),preTrimContent=parseTextData(context,rawContentLength,mode),content=preTrimContent.trim(),startOffset=preTrimContent.indexOf(content);startOffset>0&&advancePositionWithMutation(innerStart,rawContent,startOffset);const endOffset=rawContentLength-(preTrimContent.length-content.length-startOffset);return advancePositionWithMutation(innerEnd,rawContent,endOffset),advanceBy(context,close.length),{type:5,content:{type:4,isStatic:!1,constType:0,content:content,loc:getSelection(context,innerStart,innerEnd)},loc:getSelection(context,start)}}function parseText(context,mode){const endTokens=3===mode?["]]>"]:["<",context.options.delimiters[0]];let endIndex=context.source.length;for(let i=0;i<endTokens.length;i++){const index=context.source.indexOf(endTokens[i],1);-1!==index&&endIndex>index&&(endIndex=index)}const start=getCursor(context),content=parseTextData(context,endIndex,mode);return{type:2,content:content,loc:getSelection(context,start)}}function parseTextData(context,length,mode){const rawText=context.source.slice(0,length);return advanceBy(context,length),2!==mode&&3!==mode&&rawText.includes("&")?context.options.decodeEntities(rawText,4===mode):rawText}function getCursor(context){const{column:column,line:line,offset:offset}=context;return{column:column,line:line,offset:offset}}function getSelection(context,start,end){return end=end||getCursor(context),{start:start,end:end,source:context.originalSource.slice(start.offset,end.offset)}}function last(xs){return xs[xs.length-1]}function startsWith(source,searchString){return source.startsWith(searchString)}function advanceBy(context,numberOfCharacters){const{source:source}=context;advancePositionWithMutation(context,source,numberOfCharacters),context.source=source.slice(numberOfCharacters)}function advanceSpaces(context){const match=/^[\t\r\n\f ]+/.exec(context.source);match&&advanceBy(context,match[0].length)}function getNewPosition(context,start,numberOfCharacters){return advancePositionWithClone(start,context.originalSource.slice(start.offset,numberOfCharacters),numberOfCharacters)}function emitError(context,code,offset,loc=getCursor(context)){offset&&(loc.offset+=offset,loc.column+=offset),context.options.onError(createCompilerError(code,{start:loc,end:loc,source:""}))}function isEnd(context,mode,ancestors){const s=context.source;switch(mode){case 0:if(startsWith(s,"</"))for(let i=ancestors.length-1;i>=0;--i)if(startsWithEndTagOpen(s,ancestors[i].tag))return!0;break;case 1:case 2:{const parent=last(ancestors);if(parent&&startsWithEndTagOpen(s,parent.tag))return!0;break}case 3:if(startsWith(s,"]]>"))return!0}return!s}function startsWithEndTagOpen(source,tag){return startsWith(source,"</")&&source.slice(2,2+tag.length).toLowerCase()===tag.toLowerCase()&&/[\t\r\n\f />]/.test(source[2+tag.length]||">")}function hoistStatic(root,context){walk(root,context,isSingleElementRoot(root,root.children[0]))}function isSingleElementRoot(root,child){const{children:children}=root;return 1===children.length&&1===child.type&&!isSlotOutlet(child)}function walk(node,context,doNotHoistNode=!1){const{children:children}=node,originalCount=children.length;let hoistedCount=0;for(let i=0;i<children.length;i++){const child=children[i];if(1===child.type&&0===child.tagType){const constantType=doNotHoistNode?0:getConstantType(child,context);if(constantType>0){if(constantType>=2){child.codegenNode.patchFlag="-1 /* HOISTED */",child.codegenNode=context.hoist(child.codegenNode),hoistedCount++;continue}}else{const codegenNode=child.codegenNode;if(13===codegenNode.type){const flag=getPatchFlag(codegenNode);if((!flag||512===flag||1===flag)&&getGeneratedPropsConstantType(child,context)>=2){const props=getNodeProps(child);props&&(codegenNode.props=context.hoist(props))}codegenNode.dynamicProps&&(codegenNode.dynamicProps=context.hoist(codegenNode.dynamicProps))}}}else 12===child.type&&getConstantType(child.content,context)>=2&&(child.codegenNode=context.hoist(child.codegenNode),hoistedCount++);if(1===child.type){const isComponent=1===child.tagType;isComponent&&context.scopes.vSlot++,walk(child,context),isComponent&&context.scopes.vSlot--}else if(11===child.type)walk(child,context,1===child.children.length);else if(9===child.type)for(let i=0;i<child.branches.length;i++)walk(child.branches[i],context,1===child.branches[i].children.length)}hoistedCount&&context.transformHoist&&context.transformHoist(children,context,node),hoistedCount&&hoistedCount===originalCount&&1===node.type&&0===node.tagType&&node.codegenNode&&13===node.codegenNode.type&&isArray(node.codegenNode.children)&&(node.codegenNode.children=context.hoist(createArrayExpression(node.codegenNode.children)))}function getConstantType(node,context){const{constantCache:constantCache}=context;switch(node.type){case 1:if(0!==node.tagType)return 0;const cached=constantCache.get(node);if(void 0!==cached)return cached;const codegenNode=node.codegenNode;if(13!==codegenNode.type)return 0;if(codegenNode.isBlock&&"svg"!==node.tag&&"foreignObject"!==node.tag)return 0;const flag=getPatchFlag(codegenNode);if(flag)return constantCache.set(node,0),0;{let returnType=3;const generatedPropsType=getGeneratedPropsConstantType(node,context);if(0===generatedPropsType)return constantCache.set(node,0),0;generatedPropsType<returnType&&(returnType=generatedPropsType);for(let i=0;i<node.children.length;i++){const childType=getConstantType(node.children[i],context);if(0===childType)return constantCache.set(node,0),0;childType<returnType&&(returnType=childType)}if(returnType>1)for(let i=0;i<node.props.length;i++){const p=node.props[i];if(7===p.type&&"bind"===p.name&&p.exp){const expType=getConstantType(p.exp,context);if(0===expType)return constantCache.set(node,0),0;expType<returnType&&(returnType=expType)}}return codegenNode.isBlock&&(context.removeHelper(OPEN_BLOCK),context.removeHelper(getVNodeBlockHelper(context.inSSR,codegenNode.isComponent)),codegenNode.isBlock=!1,context.helper(getVNodeHelper(context.inSSR,codegenNode.isComponent))),constantCache.set(node,returnType),returnType}case 2:case 3:return 3;case 9:case 11:case 10:return 0;case 5:case 12:return getConstantType(node.content,context);case 4:return node.constType;case 8:let returnType=3;for(let i=0;i<node.children.length;i++){const child=node.children[i];if(isString(child)||isSymbol(child))continue;const childType=getConstantType(child,context);if(0===childType)return 0;childType<returnType&&(returnType=childType)}return returnType;default:return 0}}function getConstantTypeOfHelperCall(value,context){if(14===value.type&&!isString(value.callee)&&allowHoistedHelperSet.has(value.callee)){const arg=value.arguments[0];if(4===arg.type)return getConstantType(arg,context);if(14===arg.type)return getConstantTypeOfHelperCall(arg,context)}return 0}function getGeneratedPropsConstantType(node,context){let returnType=3;const props=getNodeProps(node);if(props&&15===props.type){const{properties:properties}=props;for(let i=0;i<properties.length;i++){const{key:key,value:value}=properties[i],keyType=getConstantType(key,context);if(0===keyType)return keyType;let valueType;if(keyType<returnType&&(returnType=keyType),valueType=4===value.type?getConstantType(value,context):14===value.type?getConstantTypeOfHelperCall(value,context):0,0===valueType)return valueType;valueType<returnType&&(returnType=valueType)}}return returnType}function getNodeProps(node){const codegenNode=node.codegenNode;if(13===codegenNode.type)return codegenNode.props}function getPatchFlag(node){const flag=node.patchFlag;return flag?parseInt(flag,10):void 0}function createTransformContext(root,{filename:filename="",prefixIdentifiers:prefixIdentifiers=!1,hoistStatic:hoistStatic=!1,cacheHandlers:cacheHandlers=!1,nodeTransforms:nodeTransforms=[],directiveTransforms:directiveTransforms={},transformHoist:transformHoist=null,isBuiltInComponent:isBuiltInComponent=NOOP,isCustomElement:isCustomElement=NOOP,expressionPlugins:expressionPlugins=[],scopeId:scopeId=null,slotted:slotted=!0,ssr:ssr=!1,inSSR:inSSR=!1,ssrCssVars:ssrCssVars="",bindingMetadata:bindingMetadata=EMPTY_OBJ,inline:inline=!1,isTS:isTS=!1,onError:onError=defaultOnError,onWarn:onWarn=defaultOnWarn,compatConfig:compatConfig}){const nameMatch=filename.replace(/\?.*$/,"").match(/([^/\\]+)\.\w+$/),context={selfName:nameMatch&&capitalize(camelize(nameMatch[1])),prefixIdentifiers:prefixIdentifiers,hoistStatic:hoistStatic,cacheHandlers:cacheHandlers,nodeTransforms:nodeTransforms,directiveTransforms:directiveTransforms,transformHoist:transformHoist,isBuiltInComponent:isBuiltInComponent,isCustomElement:isCustomElement,expressionPlugins:expressionPlugins,scopeId:scopeId,slotted:slotted,ssr:ssr,inSSR:inSSR,ssrCssVars:ssrCssVars,bindingMetadata:bindingMetadata,inline:inline,isTS:isTS,onError:onError,onWarn:onWarn,compatConfig:compatConfig,root:root,helpers:new Map,components:new Set,directives:new Set,hoists:[],imports:[],constantCache:new Map,temps:0,cached:0,identifiers:Object.create(null),scopes:{vFor:0,vSlot:0,vPre:0,vOnce:0},parent:null,currentNode:root,childIndex:0,inVOnce:!1,helper(name){const count=context.helpers.get(name)||0;return context.helpers.set(name,count+1),name},removeHelper(name){const count=context.helpers.get(name);if(count){const currentCount=count-1;currentCount?context.helpers.set(name,currentCount):context.helpers.delete(name)}},helperString:name=>`_${helperNameMap[context.helper(name)]}`,replaceNode(node){if(!context.currentNode)throw new Error("Node being replaced is already removed.");if(!context.parent)throw new Error("Cannot replace root node.");context.parent.children[context.childIndex]=context.currentNode=node},removeNode(node){if(!context.parent)throw new Error("Cannot remove root node.");const list=context.parent.children,removalIndex=node?list.indexOf(node):context.currentNode?context.childIndex:-1;if(removalIndex<0)throw new Error("node being removed is not a child of current parent");node&&node!==context.currentNode?context.childIndex>removalIndex&&(context.childIndex--,context.onNodeRemoved()):(context.currentNode=null,context.onNodeRemoved()),context.parent.children.splice(removalIndex,1)},onNodeRemoved:()=>{},addIdentifiers(exp){},removeIdentifiers(exp){},hoist(exp){isString(exp)&&(exp=createSimpleExpression(exp)),context.hoists.push(exp);const identifier=createSimpleExpression(`_hoisted_${context.hoists.length}`,!1,exp.loc,2);return identifier.hoisted=exp,identifier},cache:(exp,isVNode=!1)=>createCacheExpression(context.cached++,exp,isVNode)};return context}function transform(root,options){const context=createTransformContext(root,options);traverseNode(root,context),options.hoistStatic&&hoistStatic(root,context),options.ssr||createRootCodegen(root,context),root.helpers=[...context.helpers.keys()],root.components=[...context.components],root.directives=[...context.directives],root.imports=context.imports,root.hoists=context.hoists,root.temps=context.temps,root.cached=context.cached}function createRootCodegen(root,context){const{helper:helper}=context,{children:children}=root;if(1===children.length){const child=children[0];if(isSingleElementRoot(root,child)&&child.codegenNode){const codegenNode=child.codegenNode;13===codegenNode.type&&makeBlock(codegenNode,context),root.codegenNode=codegenNode}else root.codegenNode=child}else if(children.length>1){let patchFlag=64,patchFlagText=PatchFlagNames[64];1===children.filter(c=>3!==c.type).length&&(patchFlag|=2048,patchFlagText+=`, ${PatchFlagNames[2048]}`),root.codegenNode=createVNodeCall(context,helper(FRAGMENT),void 0,root.children,patchFlag+` /* ${patchFlagText} */`,void 0,void 0,!0,void 0,!1)}}function traverseChildren(parent,context){let i=0;const nodeRemoved=()=>{i--};for(;i<parent.children.length;i++){const child=parent.children[i];isString(child)||(context.parent=parent,context.childIndex=i,context.onNodeRemoved=nodeRemoved,traverseNode(child,context))}}function traverseNode(node,context){context.currentNode=node;const{nodeTransforms:nodeTransforms}=context,exitFns=[];for(let i=0;i<nodeTransforms.length;i++){const onExit=nodeTransforms[i](node,context);if(onExit&&(isArray(onExit)?exitFns.push(...onExit):exitFns.push(onExit)),!context.currentNode)return;node=context.currentNode}switch(node.type){case 3:context.ssr||context.helper(CREATE_COMMENT);break;case 5:context.ssr||context.helper(TO_DISPLAY_STRING);break;case 9:for(let i=0;i<node.branches.length;i++)traverseNode(node.branches[i],context);break;case 10:case 11:case 1:case 0:traverseChildren(node,context)}context.currentNode=node;let i=exitFns.length;for(;i--;)exitFns[i]()}function createStructuralDirectiveTransform(name,fn){const matches=isString(name)?n=>n===name:n=>name.test(n);return(node,context)=>{if(1===node.type){const{props:props}=node;if(3===node.tagType&&props.some(isVSlot))return;const exitFns=[];for(let i=0;i<props.length;i++){const prop=props[i];if(7===prop.type&&matches(prop.name)){props.splice(i,1),i--;const onExit=fn(node,prop,context);onExit&&exitFns.push(onExit)}}return exitFns}}}function createCodegenContext(ast,{mode:mode="function",prefixIdentifiers:prefixIdentifiers="module"===mode,sourceMap:sourceMap=!1,filename:filename="template.vue.html",scopeId:scopeId=null,optimizeImports:optimizeImports=!1,runtimeGlobalName:runtimeGlobalName="Vue",runtimeModuleName:runtimeModuleName="vue",ssrRuntimeModuleName:ssrRuntimeModuleName="vue/server-renderer",ssr:ssr=!1,isTS:isTS=!1,inSSR:inSSR=!1}){function newline(n){context.push("\n"+"  ".repeat(n))}const context={mode:mode,prefixIdentifiers:prefixIdentifiers,sourceMap:sourceMap,filename:filename,scopeId:scopeId,optimizeImports:optimizeImports,runtimeGlobalName:runtimeGlobalName,runtimeModuleName:runtimeModuleName,ssrRuntimeModuleName:ssrRuntimeModuleName,ssr:ssr,isTS:isTS,inSSR:inSSR,source:ast.loc.source,code:"",column:1,line:1,offset:0,indentLevel:0,pure:!1,map:void 0,helper:key=>`_${helperNameMap[key]}`,push(code,node){context.code+=code},indent(){newline(++context.indentLevel)},deindent(withoutNewLine=!1){withoutNewLine?--context.indentLevel:newline(--context.indentLevel)},newline(){newline(context.indentLevel)}};return context}function generate(ast,options={}){const context=createCodegenContext(ast,options);options.onContextCreated&&options.onContextCreated(context);const{mode:mode,push:push,prefixIdentifiers:prefixIdentifiers,indent:indent,deindent:deindent,newline:newline,scopeId:scopeId,ssr:ssr}=context,hasHelpers=ast.helpers.length>0,useWithBlock=!prefixIdentifiers&&"module"!==mode,preambleContext=context;genFunctionPreamble(ast,preambleContext);const functionName=ssr?"ssrRender":"render",args=ssr?["_ctx","_push","_parent","_attrs"]:["_ctx","_cache"],signature=args.join(", ");if(push(`function ${functionName}(${signature}) {`),indent(),useWithBlock&&(push("with (_ctx) {"),indent(),hasHelpers&&(push(`const { ${ast.helpers.map(s=>`${helperNameMap[s]}: _${helperNameMap[s]}`).join(", ")} } = _Vue`),push("\n"),newline())),ast.components.length&&(genAssets(ast.components,"component",context),(ast.directives.length||ast.temps>0)&&newline()),ast.directives.length&&(genAssets(ast.directives,"directive",context),ast.temps>0&&newline()),ast.temps>0){push("let ");for(let i=0;i<ast.temps;i++)push(`${i>0?", ":""}_temp${i}`)}return(ast.components.length||ast.directives.length||ast.temps)&&(push("\n"),newline()),ssr||push("return "),ast.codegenNode?genNode(ast.codegenNode,context):push("null"),useWithBlock&&(deindent(),push("}")),deindent(),push("}"),{ast:ast,code:context.code,preamble:"",map:context.map?context.map.toJSON():void 0}}function genFunctionPreamble(ast,context){const{ssr:ssr,prefixIdentifiers:prefixIdentifiers,push:push,newline:newline,runtimeModuleName:runtimeModuleName,runtimeGlobalName:runtimeGlobalName,ssrRuntimeModuleName:ssrRuntimeModuleName}=context,VueBinding=runtimeGlobalName,aliasHelper=s=>`${helperNameMap[s]}: _${helperNameMap[s]}`;if(ast.helpers.length>0&&(push(`const _Vue = ${VueBinding}\n`),ast.hoists.length)){const staticHelpers=[CREATE_VNODE,CREATE_ELEMENT_VNODE,CREATE_COMMENT,CREATE_TEXT,CREATE_STATIC].filter(helper=>ast.helpers.includes(helper)).map(aliasHelper).join(", ");push(`const { ${staticHelpers} } = _Vue\n`)}genHoists(ast.hoists,context),newline(),push("return ")}function genAssets(assets,type,{helper:helper,push:push,newline:newline,isTS:isTS}){const resolver=helper("component"===type?RESOLVE_COMPONENT:RESOLVE_DIRECTIVE);for(let i=0;i<assets.length;i++){let id=assets[i];const maybeSelfReference=id.endsWith("__self");maybeSelfReference&&(id=id.slice(0,-6)),push(`const ${toValidAssetId(id,type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference?", true":""})${isTS?"!":""}`),i<assets.length-1&&newline()}}function genHoists(hoists,context){if(!hoists.length)return;context.pure=!0;const{push:push,newline:newline,helper:helper,scopeId:scopeId,mode:mode}=context;newline();for(let i=0;i<hoists.length;i++){const exp=hoists[i];exp&&(push(`const _hoisted_${i+1} = `),genNode(exp,context),newline())}context.pure=!1}function isText$1(n){return isString(n)||4===n.type||2===n.type||5===n.type||8===n.type}function genNodeListAsArray(nodes,context){const multilines=nodes.length>3||nodes.some(n=>isArray(n)||!isText$1(n));context.push("["),multilines&&context.indent(),genNodeList(nodes,context,multilines),multilines&&context.deindent(),context.push("]")}function genNodeList(nodes,context,multilines=!1,comma=!0){const{push:push,newline:newline}=context;for(let i=0;i<nodes.length;i++){const node=nodes[i];isString(node)?push(node):isArray(node)?genNodeListAsArray(node,context):genNode(node,context),i<nodes.length-1&&(multilines?(comma&&push(","),newline()):comma&&push(", "))}}function genNode(node,context){if(isString(node))context.push(node);else if(isSymbol(node))context.push(context.helper(node));else switch(node.type){case 1:case 9:case 11:assert(null!=node.codegenNode,"Codegen node is missing for element/if/for node. Apply appropriate transforms first."),genNode(node.codegenNode,context);break;case 2:genText(node,context);break;case 4:genExpression(node,context);break;case 5:genInterpolation(node,context);break;case 12:genNode(node.codegenNode,context);break;case 8:genCompoundExpression(node,context);break;case 3:genComment(node,context);break;case 13:genVNodeCall(node,context);break;case 14:genCallExpression(node,context);break;case 15:genObjectExpression(node,context);break;case 17:genArrayExpression(node,context);break;case 18:genFunctionExpression(node,context);break;case 19:genConditionalExpression(node,context);break;case 20:genCacheExpression(node,context);break;case 21:genNodeList(node.body,context,!0,!1);break;case 22:case 23:case 24:case 25:case 26:case 10:break;default:{assert(!1,`unhandled codegen node type: ${node.type}`);const exhaustiveCheck=node;return exhaustiveCheck}}}function genText(node,context){context.push(JSON.stringify(node.content),node)}function genExpression(node,context){const{content:content,isStatic:isStatic}=node;context.push(isStatic?JSON.stringify(content):content,node)}function genInterpolation(node,context){const{push:push,helper:helper,pure:pure}=context;pure&&push(PURE_ANNOTATION),push(`${helper(TO_DISPLAY_STRING)}(`),genNode(node.content,context),push(")")}function genCompoundExpression(node,context){for(let i=0;i<node.children.length;i++){const child=node.children[i];isString(child)?context.push(child):genNode(child,context)}}function genExpressionAsPropertyKey(node,context){const{push:push}=context;if(8===node.type)push("["),genCompoundExpression(node,context),push("]");else if(node.isStatic){const text=isSimpleIdentifier(node.content)?node.content:JSON.stringify(node.content);push(text,node)}else push(`[${node.content}]`,node)}function genComment(node,context){const{push:push,helper:helper,pure:pure}=context;pure&&push(PURE_ANNOTATION),push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,node)}function genVNodeCall(node,context){const{push:push,helper:helper,pure:pure}=context,{tag:tag,props:props,children:children,patchFlag:patchFlag,dynamicProps:dynamicProps,directives:directives,isBlock:isBlock,disableTracking:disableTracking,isComponent:isComponent}=node;directives&&push(helper(WITH_DIRECTIVES)+"("),isBlock&&push(`(${helper(OPEN_BLOCK)}(${disableTracking?"true":""}), `),pure&&push(PURE_ANNOTATION);const callHelper=isBlock?getVNodeBlockHelper(context.inSSR,isComponent):getVNodeHelper(context.inSSR,isComponent);push(helper(callHelper)+"(",node),genNodeList(genNullableArgs([tag,props,children,patchFlag,dynamicProps]),context),push(")"),isBlock&&push(")"),directives&&(push(", "),genNode(directives,context),push(")"))}function genNullableArgs(args){let i=args.length;for(;i--&&null==args[i];);return args.slice(0,i+1).map(arg=>arg||"null")}function genCallExpression(node,context){const{push:push,helper:helper,pure:pure}=context,callee=isString(node.callee)?node.callee:helper(node.callee);pure&&push(PURE_ANNOTATION),push(callee+"(",node),genNodeList(node.arguments,context),push(")")}function genObjectExpression(node,context){const{push:push,indent:indent,deindent:deindent,newline:newline}=context,{properties:properties}=node;if(!properties.length)return void push("{}",node);const multilines=properties.length>1||properties.some(p=>4!==p.value.type);push(multilines?"{":"{ "),multilines&&indent();for(let i=0;i<properties.length;i++){const{key:key,value:value}=properties[i];genExpressionAsPropertyKey(key,context),push(": "),genNode(value,context),i<properties.length-1&&(push(","),newline())}multilines&&deindent(),push(multilines?"}":" }")}function genArrayExpression(node,context){genNodeListAsArray(node.elements,context)}function genFunctionExpression(node,context){
const{push:push,indent:indent,deindent:deindent}=context,{params:params,returns:returns,body:body,newline:newline,isSlot:isSlot}=node;isSlot&&push(`_${helperNameMap[WITH_CTX]}(`),push("(",node),isArray(params)?genNodeList(params,context):params&&genNode(params,context),push(") => "),(newline||body)&&(push("{"),indent()),returns?(newline&&push("return "),isArray(returns)?genNodeListAsArray(returns,context):genNode(returns,context)):body&&genNode(body,context),(newline||body)&&(deindent(),push("}")),isSlot&&push(")")}function genConditionalExpression(node,context){const{test:test,consequent:consequent,alternate:alternate,newline:needNewline}=node,{push:push,indent:indent,deindent:deindent,newline:newline}=context;if(4===test.type){const needsParens=!isSimpleIdentifier(test.content);needsParens&&push("("),genExpression(test,context),needsParens&&push(")")}else push("("),genNode(test,context),push(")");needNewline&&indent(),context.indentLevel++,needNewline||push(" "),push("? "),genNode(consequent,context),context.indentLevel--,needNewline&&newline(),needNewline||push(" "),push(": ");const isNested=19===alternate.type;isNested||context.indentLevel++,genNode(alternate,context),isNested||context.indentLevel--,needNewline&&deindent(!0)}function genCacheExpression(node,context){const{push:push,helper:helper,indent:indent,deindent:deindent,newline:newline}=context;push(`_cache[${node.index}] || (`),node.isVNode&&(indent(),push(`${helper(SET_BLOCK_TRACKING)}(-1),`),newline()),push(`_cache[${node.index}] = `),genNode(node.value,context),node.isVNode&&(push(","),newline(),push(`${helper(SET_BLOCK_TRACKING)}(1),`),newline(),push(`_cache[${node.index}]`),deindent()),push(")")}function validateBrowserExpression(node,context,asParams=!1,asRawStatements=!1){const exp=node.content;if(exp.trim())try{new Function(asRawStatements?` ${exp} `:`return ${asParams?`(${exp}) => {}`:`(${exp})`}`)}catch(e){let message=e.message;const keywordMatch=exp.replace(stripStringRE,"").match(prohibitedKeywordRE);keywordMatch&&(message=`avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`),context.onError(createCompilerError(44,node.loc,void 0,message))}}function processExpression(node,context,asParams=!1,asRawStatements=!1,localVars=Object.create(context.identifiers)){return validateBrowserExpression(node,context,asParams,asRawStatements),node}function processIf(node,dir,context,processCodegen){if(!("else"===dir.name||dir.exp&&dir.exp.content.trim())){const loc=dir.exp?dir.exp.loc:node.loc;context.onError(createCompilerError(28,dir.loc)),dir.exp=createSimpleExpression("true",!1,loc)}if(dir.exp&&validateBrowserExpression(dir.exp,context),"if"===dir.name){const branch=createIfBranch(node,dir),ifNode={type:9,loc:node.loc,branches:[branch]};if(context.replaceNode(ifNode),processCodegen)return processCodegen(ifNode,branch,!0)}else{const siblings=context.parent.children,comments=[];let i=siblings.indexOf(node);for(;i-- >=-1;){const sibling=siblings[i];if(sibling&&3===sibling.type)context.removeNode(sibling),comments.unshift(sibling);else{if(!sibling||2!==sibling.type||sibling.content.trim().length){if(sibling&&9===sibling.type){"else-if"===dir.name&&void 0===sibling.branches[sibling.branches.length-1].condition&&context.onError(createCompilerError(30,node.loc)),context.removeNode();const branch=createIfBranch(node,dir);!comments.length||context.parent&&1===context.parent.type&&isBuiltInType(context.parent.tag,"transition")||(branch.children=[...comments,...branch.children]);{const key=branch.userKey;key&&sibling.branches.forEach(({userKey:userKey})=>{isSameKey(userKey,key)&&context.onError(createCompilerError(29,branch.userKey.loc))})}sibling.branches.push(branch);const onExit=processCodegen&&processCodegen(sibling,branch,!1);traverseNode(branch,context),onExit&&onExit(),context.currentNode=null}else context.onError(createCompilerError(30,node.loc));break}context.removeNode(sibling)}}}}function createIfBranch(node,dir){return{type:10,loc:node.loc,condition:"else"===dir.name?void 0:dir.exp,children:3!==node.tagType||findDir(node,"for")?[node]:node.children,userKey:findProp(node,"key")}}function createCodegenNodeForBranch(branch,keyIndex,context){return branch.condition?createConditionalExpression(branch.condition,createChildrenCodegenNode(branch,keyIndex,context),createCallExpression(context.helper(CREATE_COMMENT),['"v-if"',"true"])):createChildrenCodegenNode(branch,keyIndex,context)}function createChildrenCodegenNode(branch,keyIndex,context){const{helper:helper}=context,keyProperty=createObjectProperty("key",createSimpleExpression(`${keyIndex}`,!1,locStub,2)),{children:children}=branch,firstChild=children[0],needFragmentWrapper=1!==children.length||1!==firstChild.type;if(needFragmentWrapper){if(1===children.length&&11===firstChild.type){const vnodeCall=firstChild.codegenNode;return injectProp(vnodeCall,keyProperty,context),vnodeCall}{let patchFlag=64,patchFlagText=PatchFlagNames[64];return 1===children.filter(c=>3!==c.type).length&&(patchFlag|=2048,patchFlagText+=`, ${PatchFlagNames[2048]}`),createVNodeCall(context,helper(FRAGMENT),createObjectExpression([keyProperty]),children,patchFlag+` /* ${patchFlagText} */`,void 0,void 0,!0,!1,!1,branch.loc)}}{const ret=firstChild.codegenNode,vnodeCall=getMemoedVNodeCall(ret);return 13===vnodeCall.type&&makeBlock(vnodeCall,context),injectProp(vnodeCall,keyProperty,context),ret}}function isSameKey(a,b){if(!a||a.type!==b.type)return!1;if(6===a.type){if(a.value.content!==b.value.content)return!1}else{const exp=a.exp,branchExp=b.exp;if(exp.type!==branchExp.type)return!1;if(4!==exp.type||exp.isStatic!==branchExp.isStatic||exp.content!==branchExp.content)return!1}return!0}function getParentCondition(node){for(;;)if(19===node.type){if(19!==node.alternate.type)return node;node=node.alternate}else 20===node.type&&(node=node.value)}function processFor(node,dir,context,processCodegen){if(!dir.exp)return void context.onError(createCompilerError(31,dir.loc));const parseResult=parseForExpression(dir.exp,context);if(!parseResult)return void context.onError(createCompilerError(32,dir.loc));const{addIdentifiers:addIdentifiers,removeIdentifiers:removeIdentifiers,scopes:scopes}=context,{source:source,value:value,key:key,index:index}=parseResult,forNode={type:11,loc:dir.loc,source:source,valueAlias:value,keyAlias:key,objectIndexAlias:index,parseResult:parseResult,children:isTemplateNode(node)?node.children:[node]};context.replaceNode(forNode),scopes.vFor++;const onExit=processCodegen&&processCodegen(forNode);return()=>{scopes.vFor--,onExit&&onExit()}}function parseForExpression(input,context){const loc=input.loc,exp=input.content,inMatch=exp.match(forAliasRE);if(!inMatch)return;const[,LHS,RHS]=inMatch,result={source:createAliasExpression(loc,RHS.trim(),exp.indexOf(RHS,LHS.length)),value:void 0,key:void 0,index:void 0};validateBrowserExpression(result.source,context);let valueContent=LHS.trim().replace(stripParensRE,"").trim();const trimmedOffset=LHS.indexOf(valueContent),iteratorMatch=valueContent.match(forIteratorRE);if(iteratorMatch){valueContent=valueContent.replace(forIteratorRE,"").trim();const keyContent=iteratorMatch[1].trim();let keyOffset;if(keyContent&&(keyOffset=exp.indexOf(keyContent,trimmedOffset+valueContent.length),result.key=createAliasExpression(loc,keyContent,keyOffset),validateBrowserExpression(result.key,context,!0)),iteratorMatch[2]){const indexContent=iteratorMatch[2].trim();indexContent&&(result.index=createAliasExpression(loc,indexContent,exp.indexOf(indexContent,result.key?keyOffset+keyContent.length:trimmedOffset+valueContent.length)),validateBrowserExpression(result.index,context,!0))}}return valueContent&&(result.value=createAliasExpression(loc,valueContent,trimmedOffset),validateBrowserExpression(result.value,context,!0)),result}function createAliasExpression(range,content,offset){return createSimpleExpression(content,!1,getInnerRange(range,offset,content.length))}function createForLoopParams({value:value,key:key,index:index},memoArgs=[]){return createParamsList([value,key,index,...memoArgs])}function createParamsList(args){let i=args.length;for(;i--&&!args[i];);return args.slice(0,i+1).map((arg,i)=>arg||createSimpleExpression("_".repeat(i+1),!1))}function buildSlots(node,context,buildSlotFn=buildClientSlotFn){context.helper(WITH_CTX);const{children:children,loc:loc}=node,slotsProperties=[],dynamicSlots=[];let hasDynamicSlots=context.scopes.vSlot>0||context.scopes.vFor>0;const onComponentSlot=findDir(node,"slot",!0);if(onComponentSlot){const{arg:arg,exp:exp}=onComponentSlot;arg&&!isStaticExp(arg)&&(hasDynamicSlots=!0),slotsProperties.push(createObjectProperty(arg||createSimpleExpression("default",!0),buildSlotFn(exp,children,loc)))}let hasTemplateSlots=!1,hasNamedDefaultSlot=!1;const implicitDefaultChildren=[],seenSlotNames=new Set;for(let i=0;i<children.length;i++){const slotElement=children[i];let slotDir;if(!isTemplateNode(slotElement)||!(slotDir=findDir(slotElement,"slot",!0))){3!==slotElement.type&&implicitDefaultChildren.push(slotElement);continue}if(onComponentSlot){context.onError(createCompilerError(37,slotDir.loc));break}hasTemplateSlots=!0;const{children:slotChildren,loc:slotLoc}=slotElement,{arg:slotName=createSimpleExpression("default",!0),exp:slotProps,loc:dirLoc}=slotDir;let staticSlotName;isStaticExp(slotName)?staticSlotName=slotName?slotName.content:"default":hasDynamicSlots=!0;const slotFunction=buildSlotFn(slotProps,slotChildren,slotLoc);let vIf,vElse,vFor;if(vIf=findDir(slotElement,"if"))hasDynamicSlots=!0,dynamicSlots.push(createConditionalExpression(vIf.exp,buildDynamicSlot(slotName,slotFunction),defaultFallback));else if(vElse=findDir(slotElement,/^else(-if)?$/,!0)){let prev,j=i;for(;j--&&(prev=children[j],3===prev.type););if(prev&&isTemplateNode(prev)&&findDir(prev,"if")){children.splice(i,1),i--;let conditional=dynamicSlots[dynamicSlots.length-1];for(;19===conditional.alternate.type;)conditional=conditional.alternate;conditional.alternate=vElse.exp?createConditionalExpression(vElse.exp,buildDynamicSlot(slotName,slotFunction),defaultFallback):buildDynamicSlot(slotName,slotFunction)}else context.onError(createCompilerError(30,vElse.loc))}else if(vFor=findDir(slotElement,"for")){hasDynamicSlots=!0;const parseResult=vFor.parseResult||parseForExpression(vFor.exp,context);parseResult?dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST),[parseResult.source,createFunctionExpression(createForLoopParams(parseResult),buildDynamicSlot(slotName,slotFunction),!0)])):context.onError(createCompilerError(32,vFor.loc))}else{if(staticSlotName){if(seenSlotNames.has(staticSlotName)){context.onError(createCompilerError(38,dirLoc));continue}seenSlotNames.add(staticSlotName),"default"===staticSlotName&&(hasNamedDefaultSlot=!0)}slotsProperties.push(createObjectProperty(slotName,slotFunction))}}if(!onComponentSlot){const buildDefaultSlotProperty=(props,children)=>{const fn=buildSlotFn(props,children,loc);return createObjectProperty("default",fn)};hasTemplateSlots?implicitDefaultChildren.length&&implicitDefaultChildren.some(node=>isNonWhitespaceContent(node))&&(hasNamedDefaultSlot?context.onError(createCompilerError(39,implicitDefaultChildren[0].loc)):slotsProperties.push(buildDefaultSlotProperty(void 0,implicitDefaultChildren))):slotsProperties.push(buildDefaultSlotProperty(void 0,children))}const slotFlag=hasDynamicSlots?2:hasForwardedSlots(node.children)?3:1;let slots=createObjectExpression(slotsProperties.concat(createObjectProperty("_",createSimpleExpression(slotFlag+` /* ${slotFlagsText[slotFlag]} */`,!1))),loc);return dynamicSlots.length&&(slots=createCallExpression(context.helper(CREATE_SLOTS),[slots,createArrayExpression(dynamicSlots)])),{slots:slots,hasDynamicSlots:hasDynamicSlots}}function buildDynamicSlot(name,fn){return createObjectExpression([createObjectProperty("name",name),createObjectProperty("fn",fn)])}function hasForwardedSlots(children){for(let i=0;i<children.length;i++){const child=children[i];switch(child.type){case 1:if(2===child.tagType||hasForwardedSlots(child.children))return!0;break;case 9:if(hasForwardedSlots(child.branches))return!0;break;case 10:case 11:if(hasForwardedSlots(child.children))return!0}}return!1}function isNonWhitespaceContent(node){return 2!==node.type&&12!==node.type||(2===node.type?!!node.content.trim():isNonWhitespaceContent(node.content))}function resolveComponentType(node,context,ssr=!1){let{tag:tag}=node;const isExplicitDynamic=isComponentTag(tag),isProp=findProp(node,"is");if(isProp)if(isExplicitDynamic){const exp=6===isProp.type?isProp.value&&createSimpleExpression(isProp.value.content,!0):isProp.exp;if(exp)return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT),[exp])}else 6===isProp.type&&isProp.value.content.startsWith("vue:")&&(tag=isProp.value.content.slice(4));const isDir=!isExplicitDynamic&&findDir(node,"is");if(isDir&&isDir.exp)return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT),[isDir.exp]);const builtIn=isCoreComponent(tag)||context.isBuiltInComponent(tag);return builtIn?(ssr||context.helper(builtIn),builtIn):(context.helper(RESOLVE_COMPONENT),context.components.add(tag),toValidAssetId(tag,"component"))}function buildProps(node,context,props=node.props,ssr=!1){const{tag:tag,loc:elementLoc,children:children}=node,isComponent=1===node.tagType;let properties=[];const mergeArgs=[],runtimeDirectives=[],hasChildren=children.length>0;let shouldUseBlock=!1,patchFlag=0,hasRef=!1,hasClassBinding=!1,hasStyleBinding=!1,hasHydrationEventBinding=!1,hasDynamicKeys=!1,hasVnodeHook=!1;const dynamicPropNames=[],analyzePatchFlag=({key:key,value:value})=>{if(isStaticExp(key)){const name=key.content,isEventHandler=isOn(name);if(isComponent||!isEventHandler||"onclick"===name.toLowerCase()||"onUpdate:modelValue"===name||isReservedProp(name)||(hasHydrationEventBinding=!0),isEventHandler&&isReservedProp(name)&&(hasVnodeHook=!0),20===value.type||(4===value.type||8===value.type)&&getConstantType(value,context)>0)return;"ref"===name?hasRef=!0:"class"===name?hasClassBinding=!0:"style"===name?hasStyleBinding=!0:"key"===name||dynamicPropNames.includes(name)||dynamicPropNames.push(name),!isComponent||"class"!==name&&"style"!==name||dynamicPropNames.includes(name)||dynamicPropNames.push(name)}else hasDynamicKeys=!0};for(let i=0;i<props.length;i++){const prop=props[i];if(6===prop.type){const{loc:loc,name:name,value:value}=prop;let isStatic=!0;if("ref"===name&&(hasRef=!0,context.scopes.vFor>0&&properties.push(createObjectProperty(createSimpleExpression("ref_for",!0),createSimpleExpression("true")))),"is"===name&&(isComponentTag(tag)||value&&value.content.startsWith("vue:")))continue;properties.push(createObjectProperty(createSimpleExpression(name,!0,getInnerRange(loc,0,name.length)),createSimpleExpression(value?value.content:"",isStatic,value?value.loc:loc)))}else{const{name:name,arg:arg,exp:exp,loc:loc}=prop,isVBind="bind"===name,isVOn="on"===name;if("slot"===name){isComponent||context.onError(createCompilerError(40,loc));continue}if("once"===name||"memo"===name)continue;if("is"===name||isVBind&&isStaticArgOf(arg,"is")&&isComponentTag(tag))continue;if(isVOn&&ssr)continue;if((isVBind&&isStaticArgOf(arg,"key")||isVOn&&hasChildren&&isStaticArgOf(arg,"vue:before-update"))&&(shouldUseBlock=!0),isVBind&&isStaticArgOf(arg,"ref")&&context.scopes.vFor>0&&properties.push(createObjectProperty(createSimpleExpression("ref_for",!0),createSimpleExpression("true"))),!arg&&(isVBind||isVOn)){hasDynamicKeys=!0,exp?(properties.length&&(mergeArgs.push(createObjectExpression(dedupeProperties(properties),elementLoc)),properties=[]),isVBind?mergeArgs.push(exp):mergeArgs.push({type:14,loc:loc,callee:context.helper(TO_HANDLERS),arguments:[exp]})):context.onError(createCompilerError(isVBind?34:35,loc));continue}const directiveTransform=context.directiveTransforms[name];if(directiveTransform){const{props:props,needRuntime:needRuntime}=directiveTransform(prop,node,context);!ssr&&props.forEach(analyzePatchFlag),properties.push(...props),needRuntime&&(runtimeDirectives.push(prop),isSymbol(needRuntime)&&directiveImportMap.set(prop,needRuntime))}else isBuiltInDirective(name)||(runtimeDirectives.push(prop),hasChildren&&(shouldUseBlock=!0))}}let propsExpression=void 0;if(mergeArgs.length?(properties.length&&mergeArgs.push(createObjectExpression(dedupeProperties(properties),elementLoc)),propsExpression=mergeArgs.length>1?createCallExpression(context.helper(MERGE_PROPS),mergeArgs,elementLoc):mergeArgs[0]):properties.length&&(propsExpression=createObjectExpression(dedupeProperties(properties),elementLoc)),hasDynamicKeys?patchFlag|=16:(hasClassBinding&&!isComponent&&(patchFlag|=2),hasStyleBinding&&!isComponent&&(patchFlag|=4),dynamicPropNames.length&&(patchFlag|=8),hasHydrationEventBinding&&(patchFlag|=32)),shouldUseBlock||0!==patchFlag&&32!==patchFlag||!(hasRef||hasVnodeHook||runtimeDirectives.length>0)||(patchFlag|=512),!context.inSSR&&propsExpression)switch(propsExpression.type){case 15:let classKeyIndex=-1,styleKeyIndex=-1,hasDynamicKey=!1;for(let i=0;i<propsExpression.properties.length;i++){const key=propsExpression.properties[i].key;isStaticExp(key)?"class"===key.content?classKeyIndex=i:"style"===key.content&&(styleKeyIndex=i):key.isHandlerKey||(hasDynamicKey=!0)}const classProp=propsExpression.properties[classKeyIndex],styleProp=propsExpression.properties[styleKeyIndex];hasDynamicKey?propsExpression=createCallExpression(context.helper(NORMALIZE_PROPS),[propsExpression]):(classProp&&!isStaticExp(classProp.value)&&(classProp.value=createCallExpression(context.helper(NORMALIZE_CLASS),[classProp.value])),!styleProp||isStaticExp(styleProp.value)||!hasStyleBinding&&17!==styleProp.value.type||(styleProp.value=createCallExpression(context.helper(NORMALIZE_STYLE),[styleProp.value])));break;case 14:break;default:propsExpression=createCallExpression(context.helper(NORMALIZE_PROPS),[createCallExpression(context.helper(GUARD_REACTIVE_PROPS),[propsExpression])])}return{props:propsExpression,directives:runtimeDirectives,patchFlag:patchFlag,dynamicPropNames:dynamicPropNames,shouldUseBlock:shouldUseBlock}}function dedupeProperties(properties){const knownProps=new Map,deduped=[];for(let i=0;i<properties.length;i++){const prop=properties[i];if(8===prop.key.type||!prop.key.isStatic){deduped.push(prop);continue}const name=prop.key.content,existing=knownProps.get(name);existing?("style"===name||"class"===name||isOn(name))&&mergeAsArray$1(existing,prop):(knownProps.set(name,prop),deduped.push(prop))}return deduped}function mergeAsArray$1(existing,incoming){17===existing.value.type?existing.value.elements.push(incoming.value):existing.value=createArrayExpression([existing.value,incoming.value],existing.loc)}function buildDirectiveArgs(dir,context){const dirArgs=[],runtime=directiveImportMap.get(dir);runtime?dirArgs.push(context.helperString(runtime)):(context.helper(RESOLVE_DIRECTIVE),context.directives.add(dir.name),dirArgs.push(toValidAssetId(dir.name,"directive")));const{loc:loc}=dir;if(dir.exp&&dirArgs.push(dir.exp),dir.arg&&(dir.exp||dirArgs.push("void 0"),dirArgs.push(dir.arg)),Object.keys(dir.modifiers).length){dir.arg||(dir.exp||dirArgs.push("void 0"),dirArgs.push("void 0"));const trueExpression=createSimpleExpression("true",!1,loc);dirArgs.push(createObjectExpression(dir.modifiers.map(modifier=>createObjectProperty(modifier,trueExpression)),loc))}return createArrayExpression(dirArgs,dir.loc)}function stringifyDynamicPropNames(props){let propsNamesString="[";for(let i=0,l=props.length;i<l;i++)propsNamesString+=JSON.stringify(props[i]),i<l-1&&(propsNamesString+=", ");return propsNamesString+"]"}function isComponentTag(tag){return"component"===tag||"Component"===tag}function processSlotOutlet(node,context){let slotName='"default"',slotProps=void 0;const nonNameProps=[];for(let i=0;i<node.props.length;i++){const p=node.props[i];6===p.type?p.value&&("name"===p.name?slotName=JSON.stringify(p.value.content):(p.name=camelize(p.name),nonNameProps.push(p))):"bind"===p.name&&isStaticArgOf(p.arg,"name")?p.exp&&(slotName=p.exp):("bind"===p.name&&p.arg&&isStaticExp(p.arg)&&(p.arg.content=camelize(p.arg.content)),nonNameProps.push(p))}if(nonNameProps.length>0){const{props:props,directives:directives}=buildProps(node,context,nonNameProps);slotProps=props,directives.length&&context.onError(createCompilerError(36,directives[0].loc))}return{slotName:slotName,slotProps:slotProps}}function createTransformProps(props=[]){return{props:props}}function getBaseTransformPreset(prefixIdentifiers){return[[transformOnce,transformIf,transformMemo,transformFor,transformExpression,transformSlotOutlet,transformElement,trackSlotScopes,transformText],{on:transformOn,bind:transformBind,model:transformModel}]}function baseCompile(template,options={}){const onError=options.onError||defaultOnError,isModuleMode="module"===options.mode;!0===options.prefixIdentifiers?onError(createCompilerError(46)):isModuleMode&&onError(createCompilerError(47));const prefixIdentifiers=!1;options.cacheHandlers&&onError(createCompilerError(48)),options.scopeId&&!isModuleMode&&onError(createCompilerError(49));const ast=isString(template)?baseParse(template,options):template,[nodeTransforms,directiveTransforms]=getBaseTransformPreset();return transform(ast,extend({},options,{prefixIdentifiers:prefixIdentifiers,nodeTransforms:[...nodeTransforms,...options.nodeTransforms||[]],directiveTransforms:extend({},directiveTransforms,options.directiveTransforms||{})})),generate(ast,extend({},options,{prefixIdentifiers:prefixIdentifiers}))}function decodeHtmlBrowser(raw,asAttr=!1){return decoder||(decoder=document.createElement("div")),asAttr?(decoder.innerHTML=`<div foo="${raw.replace(/"/g,"&quot;")}">`,decoder.children[0].getAttribute("foo")):(decoder.innerHTML=raw,decoder.textContent)}function createDOMCompilerError(code,loc){return createCompilerError(code,loc,DOMErrorMessages)}function hasMultipleChildren(node){const children=node.children=node.children.filter(c=>3!==c.type&&!(2===c.type&&!c.content.trim())),child=children[0];return 1!==children.length||11===child.type||9===child.type&&child.branches.some(hasMultipleChildren)}function compile$1(template,options={}){return baseCompile(template,extend({},parserOptions,options,{nodeTransforms:[ignoreSideEffectTags,...DOMNodeTransforms,...options.nodeTransforms||[]],directiveTransforms:extend({},DOMDirectiveTransforms,options.directiveTransforms||{}),transformHoist:null}))}function compileToFunction(template,options){function onError(err,asWarning=!1){const message=asWarning?err.message:`Template compilation error: ${err.message}`,codeFrame=err.loc&&generateCodeFrame(template,err.loc.start.offset,err.loc.end.offset);warn$1(codeFrame?`${message}\n${codeFrame}`:message)}if(!isString(template)){if(!template.nodeType)return warn$1("invalid template option: ",template),NOOP;template=template.innerHTML}const key=template,cached=compileCache[key];if(cached)return cached;if("#"===template[0]){const el=document.querySelector(template);el||warn$1(`Template element not found or is empty: ${template}`),template=el?el.innerHTML:""}const{code:code}=compile$1(template,extend({hoistStatic:!0,onError:onError,onWarn:e=>onError(e,!0)},options)),render=new Function(code)();return render._rc=!0,compileCache[key]=render}const PatchFlagNames={1:"TEXT",2:"CLASS",4:"STYLE",8:"PROPS",16:"FULL_PROPS",32:"HYDRATE_EVENTS",64:"STABLE_FRAGMENT",128:"KEYED_FRAGMENT",256:"UNKEYED_FRAGMENT",512:"NEED_PATCH",1024:"DYNAMIC_SLOTS",2048:"DEV_ROOT_FRAGMENT",[-1]:"HOISTED",[-2]:"BAIL"},slotFlagsText={1:"STABLE",2:"DYNAMIC",3:"FORWARDED"},GLOBALS_WHITE_LISTED="Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt",isGloballyWhitelisted=makeMap(GLOBALS_WHITE_LISTED),range=2,specialBooleanAttrs="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",isSpecialBooleanAttr=makeMap(specialBooleanAttrs),listDelimiterRE=/;(?![^(]*\))/g,propertyDelimiterRE=/:(.+)/,HTML_TAGS="html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot",SVG_TAGS="svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view",VOID_TAGS="area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr",isHTMLTag=makeMap(HTML_TAGS),isSVGTag=makeMap(SVG_TAGS),isVoidTag=makeMap(VOID_TAGS),toDisplayString=val=>isString(val)?val:null==val?"":isArray(val)||isObject(val)&&(val.toString===objectToString||!isFunction(val.toString))?JSON.stringify(val,replacer,2):String(val),replacer=(_key,val)=>val&&val.__v_isRef?replacer(_key,val.value):isMap(val)?{[`Map(${val.size})`]:[...val.entries()].reduce((entries,[key,val])=>(entries[`${key} =>`]=val,entries),{})}:isSet(val)?{[`Set(${val.size})`]:[...val.values()]}:!isObject(val)||isArray(val)||isPlainObject(val)?val:String(val),EMPTY_OBJ=Object.freeze({}),EMPTY_ARR=Object.freeze([]),NOOP=()=>{},NO=()=>!1,onRE=/^on[^a-z]/,isOn=key=>onRE.test(key),isModelListener=key=>key.startsWith("onUpdate:"),extend=Object.assign,remove=(arr,el)=>{const i=arr.indexOf(el);i>-1&&arr.splice(i,1)},hasOwnProperty=Object.prototype.hasOwnProperty,hasOwn=(val,key)=>hasOwnProperty.call(val,key),isArray=Array.isArray,isMap=val=>"[object Map]"===toTypeString(val),isSet=val=>"[object Set]"===toTypeString(val),isDate=val=>val instanceof Date,isFunction=val=>"function"==typeof val,isString=val=>"string"==typeof val,isSymbol=val=>"symbol"==typeof val,isObject=val=>null!==val&&"object"==typeof val,isPromise=val=>isObject(val)&&isFunction(val.then)&&isFunction(val.catch),objectToString=Object.prototype.toString,toTypeString=value=>objectToString.call(value),toRawType=value=>toTypeString(value).slice(8,-1),isPlainObject=val=>"[object Object]"===toTypeString(val),isIntegerKey=key=>isString(key)&&"NaN"!==key&&"-"!==key[0]&&""+parseInt(key,10)===key,isReservedProp=makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),isBuiltInDirective=makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"),cacheStringFunction=fn=>{const cache=Object.create(null);return str=>{const hit=cache[str];return hit||(cache[str]=fn(str))}},camelizeRE=/-(\w)/g,camelize=cacheStringFunction(str=>str.replace(camelizeRE,(_,c)=>c?c.toUpperCase():"")),hyphenateRE=/\B([A-Z])/g,hyphenate=cacheStringFunction(str=>str.replace(hyphenateRE,"-$1").toLowerCase()),capitalize=cacheStringFunction(str=>str.charAt(0).toUpperCase()+str.slice(1)),toHandlerKey=cacheStringFunction(str=>str?`on${capitalize(str)}`:""),hasChanged=(value,oldValue)=>!Object.is(value,oldValue),invokeArrayFns=(fns,arg)=>{for(let i=0;i<fns.length;i++)fns[i](arg)},def=(obj,key,value)=>{Object.defineProperty(obj,key,{configurable:!0,enumerable:!1,value:value})},toNumber=val=>{const n=parseFloat(val);return isNaN(n)?val:n};let _globalThis;const getGlobalThis=()=>_globalThis||(_globalThis="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{});let activeEffectScope;class EffectScope{constructor(detached=!1){this.active=!0,this.effects=[],this.cleanups=[],!detached&&activeEffectScope&&(this.parent=activeEffectScope,this.index=(activeEffectScope.scopes||(activeEffectScope.scopes=[])).push(this)-1)}run(fn){if(this.active){const currentEffectScope=activeEffectScope;try{return activeEffectScope=this,fn()}finally{activeEffectScope=currentEffectScope}}else warn("cannot run an inactive effect scope.")}on(){activeEffectScope=this}off(){activeEffectScope=this.parent}stop(fromParent){if(this.active){let i,l;for(i=0,l=this.effects.length;i<l;i++)this.effects[i].stop();for(i=0,l=this.cleanups.length;i<l;i++)this.cleanups[i]();if(this.scopes)for(i=0,l=this.scopes.length;i<l;i++)this.scopes[i].stop(!0);if(this.parent&&!fromParent){const last=this.parent.scopes.pop();last&&last!==this&&(this.parent.scopes[this.index]=last,last.index=this.index)}this.active=!1}}}const createDep=effects=>{const dep=new Set(effects);return dep.w=0,dep.n=0,dep},wasTracked=dep=>(dep.w&trackOpBit)>0,newTracked=dep=>(dep.n&trackOpBit)>0,initDepMarkers=({deps:deps})=>{if(deps.length)for(let i=0;i<deps.length;i++)deps[i].w|=trackOpBit},finalizeDepMarkers=effect=>{const{deps:deps}=effect;if(deps.length){let ptr=0;for(let i=0;i<deps.length;i++){const dep=deps[i];wasTracked(dep)&&!newTracked(dep)?dep.delete(effect):deps[ptr++]=dep,dep.w&=~trackOpBit,dep.n&=~trackOpBit}deps.length=ptr}},targetMap=new WeakMap;let effectTrackDepth=0,trackOpBit=1;const maxMarkerBits=30;let activeEffect;const ITERATE_KEY=Symbol("iterate"),MAP_KEY_ITERATE_KEY=Symbol("Map key iterate");class ReactiveEffect{constructor(fn,scheduler=null,scope){this.fn=fn,this.scheduler=scheduler,this.active=!0,this.deps=[],this.parent=void 0,recordEffectScope(this,scope)}run(){if(!this.active)return this.fn();let parent=activeEffect,lastShouldTrack=shouldTrack;for(;parent;){if(parent===this)return;parent=parent.parent}try{return this.parent=activeEffect,activeEffect=this,shouldTrack=!0,trackOpBit=1<<++effectTrackDepth,effectTrackDepth<=maxMarkerBits?initDepMarkers(this):cleanupEffect(this),this.fn()}finally{effectTrackDepth<=maxMarkerBits&&finalizeDepMarkers(this),trackOpBit=1<<--effectTrackDepth,activeEffect=this.parent,shouldTrack=lastShouldTrack,this.parent=void 0,this.deferStop&&this.stop()}}stop(){activeEffect===this?this.deferStop=!0:this.active&&(cleanupEffect(this),this.onStop&&this.onStop(),this.active=!1)}}let shouldTrack=!0;const trackStack=[],isNonTrackableKeys=makeMap("__proto__,__v_isRef,__isVue"),builtInSymbols=new Set(Object.getOwnPropertyNames(Symbol).map(key=>Symbol[key]).filter(isSymbol)),get=createGetter(),shallowGet=createGetter(!1,!0),readonlyGet=createGetter(!0),shallowReadonlyGet=createGetter(!0,!0),arrayInstrumentations=createArrayInstrumentations(),set=createSetter(),shallowSet=createSetter(!0),mutableHandlers={get:get,set:set,deleteProperty:deleteProperty,has:has,ownKeys:ownKeys},readonlyHandlers={get:readonlyGet,set:(target,key)=>(warn(`Set operation on key "${String(key)}" failed: target is readonly.`,target),!0),deleteProperty:(target,key)=>(warn(`Delete operation on key "${String(key)}" failed: target is readonly.`,target),!0)},shallowReactiveHandlers=extend({},mutableHandlers,{get:shallowGet,set:shallowSet}),shallowReadonlyHandlers=extend({},readonlyHandlers,{get:shallowReadonlyGet}),toShallow=value=>value,getProto=v=>Reflect.getPrototypeOf(v),[mutableInstrumentations,readonlyInstrumentations,shallowInstrumentations,shallowReadonlyInstrumentations]=createInstrumentations(),mutableCollectionHandlers={get:createInstrumentationGetter(!1,!1)},shallowCollectionHandlers={get:createInstrumentationGetter(!1,!0)},readonlyCollectionHandlers={get:createInstrumentationGetter(!0,!1)
},shallowReadonlyCollectionHandlers={get:createInstrumentationGetter(!0,!0)},reactiveMap=new WeakMap,shallowReactiveMap=new WeakMap,readonlyMap=new WeakMap,shallowReadonlyMap=new WeakMap,toReactive=value=>isObject(value)?reactive(value):value,toReadonly=value=>isObject(value)?readonly(value):value;class RefImpl{constructor(value,__v_isShallow){this.__v_isShallow=__v_isShallow,this.dep=void 0,this.__v_isRef=!0,this._rawValue=__v_isShallow?value:toRaw(value),this._value=__v_isShallow?value:toReactive(value)}get value(){return trackRefValue(this),this._value}set value(newVal){newVal=this.__v_isShallow?newVal:toRaw(newVal),hasChanged(newVal,this._rawValue)&&(this._rawValue=newVal,this._value=this.__v_isShallow?newVal:toReactive(newVal),triggerRefValue(this,newVal))}}const shallowUnwrapHandlers={get:(target,key,receiver)=>unref(Reflect.get(target,key,receiver)),set:(target,key,value,receiver)=>{const oldValue=target[key];return isRef(oldValue)&&!isRef(value)?(oldValue.value=value,!0):Reflect.set(target,key,value,receiver)}};class CustomRefImpl{constructor(factory){this.dep=void 0,this.__v_isRef=!0;const{get:get,set:set}=factory(()=>trackRefValue(this),()=>triggerRefValue(this));this._get=get,this._set=set}get value(){return this._get()}set value(newVal){this._set(newVal)}}class ObjectRefImpl{constructor(_object,_key,_defaultValue){this._object=_object,this._key=_key,this._defaultValue=_defaultValue,this.__v_isRef=!0}get value(){const val=this._object[this._key];return void 0===val?this._defaultValue:val}set value(newVal){this._object[this._key]=newVal}}class ComputedRefImpl{constructor(getter,_setter,isReadonly,isSSR){this._setter=_setter,this.dep=void 0,this.__v_isRef=!0,this._dirty=!0,this.effect=new ReactiveEffect(getter,()=>{this._dirty||(this._dirty=!0,triggerRefValue(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!isSSR,this.__v_isReadonly=isReadonly}get value(){const self=toRaw(this);return trackRefValue(self),!self._dirty&&self._cacheable||(self._dirty=!1,self._value=self.effect.run()),self._value}set value(newValue){this._setter(newValue)}}const stack=[],ErrorTypeStrings={sp:"serverPrefetch hook",bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"};let isFlushing=!1,isFlushPending=!1;const queue=[];let flushIndex=0;const pendingPreFlushCbs=[];let activePreFlushCbs=null,preFlushIndex=0;const pendingPostFlushCbs=[];let activePostFlushCbs=null,postFlushIndex=0;const resolvedPromise=Promise.resolve();let currentFlushPromise=null,currentPreFlushParentJob=null;const RECURSION_LIMIT=100,getId=job=>null==job.id?1/0:job.id;let isHmrUpdating=!1;const hmrDirtyComponents=new Set;getGlobalThis().__VUE_HMR_RUNTIME__={createRecord:tryWrap(createRecord),rerender:tryWrap(rerender),reload:tryWrap(reload)};const map=new Map;let buffer=[],devtoolsNotInstalled=!1;const devtoolsComponentAdded=createDevtoolsComponentHook("component:added"),devtoolsComponentUpdated=createDevtoolsComponentHook("component:updated"),devtoolsComponentRemoved=createDevtoolsComponentHook("component:removed"),devtoolsPerfStart=createDevtoolsPerformanceHook("perf:start"),devtoolsPerfEnd=createDevtoolsPerformanceHook("perf:end");let currentRenderingInstance=null,currentScopeId=null;const withScopeId=_id=>withCtx;let accessedAttrs=!1;const getChildRoot=vnode=>{const rawChildren=vnode.children,dynamicChildren=vnode.dynamicChildren,childRoot=filterSingleRoot(rawChildren);if(!childRoot)return[vnode,void 0];const index=rawChildren.indexOf(childRoot),dynamicIndex=dynamicChildren?dynamicChildren.indexOf(childRoot):-1,setRoot=updatedRoot=>{rawChildren[index]=updatedRoot,dynamicChildren&&(dynamicIndex>-1?dynamicChildren[dynamicIndex]=updatedRoot:updatedRoot.patchFlag>0&&(vnode.dynamicChildren=[...dynamicChildren,updatedRoot]))};return[normalizeVNode(childRoot),setRoot]},getFunctionalFallthrough=attrs=>{let res;for(const key in attrs)("class"===key||"style"===key||isOn(key))&&((res||(res={}))[key]=attrs[key]);return res},filterModelListeners=(attrs,props)=>{const res={};for(const key in attrs)isModelListener(key)&&key.slice(9)in props||(res[key]=attrs[key]);return res},isElementRoot=vnode=>7&vnode.shapeFlag||vnode.type===Comment,isSuspense=type=>type.__isSuspense,SuspenseImpl={name:"Suspense",__isSuspense:!0,process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,rendererInternals){null==n1?mountSuspense(n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,rendererInternals):patchSuspense(n1,n2,container,anchor,parentComponent,isSVG,slotScopeIds,optimized,rendererInternals)},hydrate:hydrateSuspense,create:createSuspenseBoundary,normalize:normalizeSuspenseChildren},Suspense=SuspenseImpl;let hasWarned=!1;const INITIAL_WATCHER_VALUE={},TransitionHookValidator=[Function,Array],BaseTransitionImpl={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:TransitionHookValidator,onEnter:TransitionHookValidator,onAfterEnter:TransitionHookValidator,onEnterCancelled:TransitionHookValidator,onBeforeLeave:TransitionHookValidator,onLeave:TransitionHookValidator,onAfterLeave:TransitionHookValidator,onLeaveCancelled:TransitionHookValidator,onBeforeAppear:TransitionHookValidator,onAppear:TransitionHookValidator,onAfterAppear:TransitionHookValidator,onAppearCancelled:TransitionHookValidator},setup(props,{slots:slots}){const instance=getCurrentInstance(),state=useTransitionState();let prevTransitionKey;return()=>{const children=slots.default&&getTransitionRawChildren(slots.default(),!0);if(!children||!children.length)return;let child=children[0];if(children.length>1){let hasFound=!1;for(const c of children)if(c.type!==Comment){if(hasFound){warn$1("<transition> can only be used on a single element or component. Use <transition-group> for lists.");break}child=c,hasFound=!0}}const rawProps=toRaw(props),{mode:mode}=rawProps;if(mode&&"in-out"!==mode&&"out-in"!==mode&&"default"!==mode&&warn$1(`invalid <transition> mode: ${mode}`),state.isLeaving)return emptyPlaceholder(child);const innerChild=getKeepAliveChild(child);if(!innerChild)return emptyPlaceholder(child);const enterHooks=resolveTransitionHooks(innerChild,rawProps,state,instance);setTransitionHooks(innerChild,enterHooks);const oldChild=instance.subTree,oldInnerChild=oldChild&&getKeepAliveChild(oldChild);let transitionKeyChanged=!1;const{getTransitionKey:getTransitionKey}=innerChild.type;if(getTransitionKey){const key=getTransitionKey();void 0===prevTransitionKey?prevTransitionKey=key:key!==prevTransitionKey&&(prevTransitionKey=key,transitionKeyChanged=!0)}if(oldInnerChild&&oldInnerChild.type!==Comment&&(!isSameVNodeType(innerChild,oldInnerChild)||transitionKeyChanged)){const leavingHooks=resolveTransitionHooks(oldInnerChild,rawProps,state,instance);if(setTransitionHooks(oldInnerChild,leavingHooks),"out-in"===mode)return state.isLeaving=!0,leavingHooks.afterLeave=(()=>{state.isLeaving=!1,instance.update()}),emptyPlaceholder(child);"in-out"===mode&&innerChild.type!==Comment&&(leavingHooks.delayLeave=((el,earlyRemove,delayedLeave)=>{const leavingVNodesCache=getLeavingNodesForType(state,oldInnerChild);leavingVNodesCache[String(oldInnerChild.key)]=oldInnerChild,el._leaveCb=(()=>{earlyRemove(),el._leaveCb=void 0,delete enterHooks.delayedLeave}),enterHooks.delayedLeave=delayedLeave}))}return child}}},BaseTransition=BaseTransitionImpl,isAsyncWrapper=i=>!!i.type.__asyncLoader,isKeepAlive=vnode=>vnode.type.__isKeepAlive,KeepAliveImpl={name:"KeepAlive",__isKeepAlive:!0,props:{include:[String,RegExp,Array],exclude:[String,RegExp,Array],max:[String,Number]},setup(props,{slots:slots}){function unmount(vnode){resetShapeFlag(vnode),_unmount(vnode,instance,parentSuspense,!0)}function pruneCache(filter){cache.forEach((vnode,key)=>{const name=getComponentName(vnode.type);!name||filter&&filter(name)||pruneCacheEntry(key)})}function pruneCacheEntry(key){const cached=cache.get(key);current&&cached.type===current.type?current&&resetShapeFlag(current):unmount(cached),cache.delete(key),keys.delete(key)}const instance=getCurrentInstance(),sharedContext=instance.ctx;if(!sharedContext.renderer)return slots.default;const cache=new Map,keys=new Set;let current=null;instance.__v_cache=cache;const parentSuspense=instance.suspense,{renderer:{p:patch,m:move,um:_unmount,o:{createElement:createElement}}}=sharedContext,storageContainer=createElement("div");sharedContext.activate=((vnode,container,anchor,isSVG,optimized)=>{const instance=vnode.component;move(vnode,container,anchor,0,parentSuspense),patch(instance.vnode,vnode,container,anchor,instance,parentSuspense,isSVG,vnode.slotScopeIds,optimized),queuePostRenderEffect(()=>{instance.isDeactivated=!1,instance.a&&invokeArrayFns(instance.a);const vnodeHook=vnode.props&&vnode.props.onVnodeMounted;vnodeHook&&invokeVNodeHook(vnodeHook,instance.parent,vnode)},parentSuspense),devtoolsComponentAdded(instance)}),sharedContext.deactivate=(vnode=>{const instance=vnode.component;move(vnode,storageContainer,null,1,parentSuspense),queuePostRenderEffect(()=>{instance.da&&invokeArrayFns(instance.da);const vnodeHook=vnode.props&&vnode.props.onVnodeUnmounted;vnodeHook&&invokeVNodeHook(vnodeHook,instance.parent,vnode),instance.isDeactivated=!0},parentSuspense),devtoolsComponentAdded(instance)}),watch(()=>[props.include,props.exclude],([include,exclude])=>{include&&pruneCache(name=>matches(include,name)),exclude&&pruneCache(name=>!matches(exclude,name))},{flush:"post",deep:!0});let pendingCacheKey=null;const cacheSubtree=()=>{null!=pendingCacheKey&&cache.set(pendingCacheKey,getInnerChild(instance.subTree))};return onMounted(cacheSubtree),onUpdated(cacheSubtree),onBeforeUnmount(()=>{cache.forEach(cached=>{const{subTree:subTree,suspense:suspense}=instance,vnode=getInnerChild(subTree);if(cached.type!==vnode.type)unmount(cached);else{resetShapeFlag(vnode);const da=vnode.component.da;da&&queuePostRenderEffect(da,suspense)}})}),()=>{if(pendingCacheKey=null,!slots.default)return null;const children=slots.default(),rawVNode=children[0];if(children.length>1)return warn$1("KeepAlive should contain exactly one component child."),current=null,children;if(!(isVNode(rawVNode)&&(4&rawVNode.shapeFlag||128&rawVNode.shapeFlag)))return current=null,rawVNode;let vnode=getInnerChild(rawVNode);const comp=vnode.type,name=getComponentName(isAsyncWrapper(vnode)?vnode.type.__asyncResolved||{}:comp),{include:include,exclude:exclude,max:max}=props;if(include&&(!name||!matches(include,name))||exclude&&name&&matches(exclude,name))return current=vnode,rawVNode;const key=null==vnode.key?comp:vnode.key,cachedVNode=cache.get(key);return vnode.el&&(vnode=cloneVNode(vnode),128&rawVNode.shapeFlag&&(rawVNode.ssContent=vnode)),pendingCacheKey=key,cachedVNode?(vnode.el=cachedVNode.el,vnode.component=cachedVNode.component,vnode.transition&&setTransitionHooks(vnode,vnode.transition),vnode.shapeFlag|=512,keys.delete(key),keys.add(key)):(keys.add(key),max&&keys.size>parseInt(max,10)&&pruneCacheEntry(keys.values().next().value)),vnode.shapeFlag|=256,current=vnode,rawVNode}}},KeepAlive=KeepAliveImpl,createHook=lifecycle=>(hook,target=currentInstance)=>(!isInSSRComponentSetup||"sp"===lifecycle)&&injectHook(lifecycle,hook,target),onBeforeMount=createHook("bm"),onMounted=createHook("m"),onBeforeUpdate=createHook("bu"),onUpdated=createHook("u"),onBeforeUnmount=createHook("bum"),onUnmounted=createHook("um"),onServerPrefetch=createHook("sp"),onRenderTriggered=createHook("rtg"),onRenderTracked=createHook("rtc");let shouldCacheAccess=!0;const internalOptionMergeStrats={data:mergeDataFn,props:mergeObjectOptions,emits:mergeObjectOptions,methods:mergeObjectOptions,computed:mergeObjectOptions,beforeCreate:mergeAsArray,created:mergeAsArray,beforeMount:mergeAsArray,mounted:mergeAsArray,beforeUpdate:mergeAsArray,updated:mergeAsArray,beforeDestroy:mergeAsArray,beforeUnmount:mergeAsArray,destroyed:mergeAsArray,unmounted:mergeAsArray,activated:mergeAsArray,deactivated:mergeAsArray,errorCaptured:mergeAsArray,serverPrefetch:mergeAsArray,components:mergeObjectOptions,directives:mergeObjectOptions,watch:mergeWatchOptions,provide:mergeDataFn,inject:mergeInject},isSimpleType=makeMap("String,Number,Boolean,Function,Symbol,BigInt"),isInternalKey=key=>"_"===key[0]||"$stable"===key,normalizeSlotValue=value=>isArray(value)?value.map(normalizeVNode):[normalizeVNode(value)],normalizeSlot=(key,rawSlot,ctx)=>{const normalized=withCtx((...args)=>(currentInstance&&warn$1(`Slot "${key}" invoked outside of the render function: `+"this will not track dependencies used in the slot. Invoke the slot function inside the render function instead."),normalizeSlotValue(rawSlot(...args))),ctx);return normalized._c=!1,normalized},normalizeObjectSlots=(rawSlots,slots,instance)=>{const ctx=rawSlots._ctx;for(const key in rawSlots){if(isInternalKey(key))continue;const value=rawSlots[key];if(isFunction(value))slots[key]=normalizeSlot(key,value,ctx);else if(null!=value){warn$1(`Non-function value encountered for slot "${key}". `+"Prefer function slots for better performance.");const normalized=normalizeSlotValue(value);slots[key]=(()=>normalized)}}},normalizeVNodeSlots=(instance,children)=>{isKeepAlive(instance.vnode)||warn$1("Non-function value encountered for default slot. Prefer function slots for better performance.");const normalized=normalizeSlotValue(children);instance.slots.default=(()=>normalized)},initSlots=(instance,children)=>{if(32&instance.vnode.shapeFlag){const type=children._;type?(instance.slots=toRaw(children),def(children,"_",type)):normalizeObjectSlots(children,instance.slots={})}else instance.slots={},children&&normalizeVNodeSlots(instance,children);def(instance.slots,InternalObjectKey,1)},updateSlots=(instance,children,optimized)=>{const{vnode:vnode,slots:slots}=instance;let needDeletionCheck=!0,deletionComparisonTarget=EMPTY_OBJ;if(32&vnode.shapeFlag){const type=children._;type?isHmrUpdating?extend(slots,children):optimized&&1===type?needDeletionCheck=!1:(extend(slots,children),optimized||1!==type||delete slots._):(needDeletionCheck=!children.$stable,normalizeObjectSlots(children,slots)),deletionComparisonTarget=children}else children&&(normalizeVNodeSlots(instance,children),deletionComparisonTarget={default:1});if(needDeletionCheck)for(const key in slots)isInternalKey(key)||key in deletionComparisonTarget||delete slots[key]};let uid=0,hasMismatch=!1;const isSVGContainer=container=>/svg/.test(container.namespaceURI)&&"foreignObject"!==container.tagName,isComment=node=>8===node.nodeType;let supported,perf;const queuePostRenderEffect=queueEffectWithSuspense,isTeleport=type=>type.__isTeleport,isTeleportDisabled=props=>props&&(props.disabled||""===props.disabled),isTargetSVG=target=>"undefined"!=typeof SVGElement&&target instanceof SVGElement,resolveTarget=(props,select)=>{const targetSelector=props&&props.to;if(isString(targetSelector)){if(select){const target=select(targetSelector);return target||warn$1(`Failed to locate Teleport target with selector "${targetSelector}". `+"Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree."),target}return warn$1("Current renderer does not support string target for Teleports. (missing querySelector renderer option)"),null}return targetSelector||isTeleportDisabled(props)||warn$1(`Invalid Teleport target: ${targetSelector}`),targetSelector},TeleportImpl={__isTeleport:!0,process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,internals){const{mc:mountChildren,pc:patchChildren,pbc:patchBlockChildren,o:{insert:insert,querySelector:querySelector,createText:createText,createComment:createComment}}=internals,disabled=isTeleportDisabled(n2.props);let{shapeFlag:shapeFlag,children:children,dynamicChildren:dynamicChildren}=n2;if(isHmrUpdating&&(optimized=!1,dynamicChildren=null),null==n1){const placeholder=n2.el=createComment("teleport start"),mainAnchor=n2.anchor=createComment("teleport end");insert(placeholder,container,anchor),insert(mainAnchor,container,anchor);const target=n2.target=resolveTarget(n2.props,querySelector),targetAnchor=n2.targetAnchor=createText("");target?(insert(targetAnchor,target),isSVG=isSVG||isTargetSVG(target)):disabled||warn$1("Invalid Teleport target on mount:",target,`(${typeof target})`);const mount=(container,anchor)=>{16&shapeFlag&&mountChildren(children,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)};disabled?mount(container,mainAnchor):target&&mount(target,targetAnchor)}else{n2.el=n1.el;const mainAnchor=n2.anchor=n1.anchor,target=n2.target=n1.target,targetAnchor=n2.targetAnchor=n1.targetAnchor,wasDisabled=isTeleportDisabled(n1.props),currentContainer=wasDisabled?container:target,currentAnchor=wasDisabled?mainAnchor:targetAnchor;if(isSVG=isSVG||isTargetSVG(target),dynamicChildren?(patchBlockChildren(n1.dynamicChildren,dynamicChildren,currentContainer,parentComponent,parentSuspense,isSVG,slotScopeIds),traverseStaticChildren(n1,n2,!0)):optimized||patchChildren(n1,n2,currentContainer,currentAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,!1),disabled)wasDisabled||moveTeleport(n2,container,mainAnchor,internals,1);else if((n2.props&&n2.props.to)!==(n1.props&&n1.props.to)){const nextTarget=n2.target=resolveTarget(n2.props,querySelector);nextTarget?moveTeleport(n2,nextTarget,null,internals,0):warn$1("Invalid Teleport target on update:",target,`(${typeof target})`)}else wasDisabled&&moveTeleport(n2,target,targetAnchor,internals,1)}},remove(vnode,parentComponent,parentSuspense,optimized,{um:unmount,o:{remove:hostRemove}},doRemove){const{shapeFlag:shapeFlag,children:children,anchor:anchor,targetAnchor:targetAnchor,target:target,props:props}=vnode;if(target&&hostRemove(targetAnchor),(doRemove||!isTeleportDisabled(props))&&(hostRemove(anchor),16&shapeFlag))for(let i=0;i<children.length;i++){const child=children[i];unmount(child,parentComponent,parentSuspense,!0,!!child.dynamicChildren)}},move:moveTeleport,hydrate:hydrateTeleport},Teleport=TeleportImpl,COMPONENTS="components",DIRECTIVES="directives",NULL_DYNAMIC_COMPONENT=Symbol(),Fragment=Symbol("Fragment"),Text=Symbol("Text"),Comment=Symbol("Comment"),Static=Symbol("Static"),blockStack=[];let vnodeArgsTransformer,currentBlock=null,isBlockTreeEnabled=1;const createVNodeWithArgsTransform=(...args)=>_createVNode(...vnodeArgsTransformer?vnodeArgsTransformer(args,currentRenderingInstance):args),InternalObjectKey="__vInternal",normalizeKey=({key:key})=>null!=key?key:null,normalizeRef=({ref:ref,ref_key:ref_key,ref_for:ref_for})=>null!=ref?isString(ref)||isRef(ref)||isFunction(ref)?{i:currentRenderingInstance,r:ref,k:ref_key,f:!!ref_for}:ref:null,createVNode=createVNodeWithArgsTransform,getPublicInstance=i=>i?isStatefulComponent(i)?getExposeProxy(i)||i.proxy:getPublicInstance(i.parent):null,publicPropertiesMap=extend(Object.create(null),{$:i=>i,$el:i=>i.vnode.el,$data:i=>i.data,$props:i=>shallowReadonly(i.props),$attrs:i=>shallowReadonly(i.attrs),$slots:i=>shallowReadonly(i.slots),$refs:i=>shallowReadonly(i.refs),$parent:i=>getPublicInstance(i.parent),$root:i=>getPublicInstance(i.root),$emit:i=>i.emit,$options:i=>resolveMergedOptions(i),$forceUpdate:i=>()=>queueJob(i.update),$nextTick:i=>nextTick.bind(i.proxy),$watch:i=>instanceWatch.bind(i)}),PublicInstanceProxyHandlers={get({_:instance},key){const{ctx:ctx,setupState:setupState,data:data,props:props,accessCache:accessCache,type:type,appContext:appContext}=instance;if("__isVue"===key)return!0;if(setupState!==EMPTY_OBJ&&setupState.__isScriptSetup&&hasOwn(setupState,key))return setupState[key];let normalizedProps;if("$"!==key[0]){const n=accessCache[key];if(void 0!==n)switch(n){case 1:return setupState[key];case 2:return data[key];case 4:return ctx[key];case 3:return props[key]}else{if(setupState!==EMPTY_OBJ&&hasOwn(setupState,key))return accessCache[key]=1,setupState[key];if(data!==EMPTY_OBJ&&hasOwn(data,key))return accessCache[key]=2,data[key];if((normalizedProps=instance.propsOptions[0])&&hasOwn(normalizedProps,key))return accessCache[key]=3,props[key];if(ctx!==EMPTY_OBJ&&hasOwn(ctx,key))return accessCache[key]=4,ctx[key];shouldCacheAccess&&(accessCache[key]=0)}}const publicGetter=publicPropertiesMap[key];let cssModule,globalProperties;return publicGetter?("$attrs"===key&&(track(instance,"get",key),markAttrsAccessed()),publicGetter(instance)):(cssModule=type.__cssModules)&&(cssModule=cssModule[key])?cssModule:ctx!==EMPTY_OBJ&&hasOwn(ctx,key)?(accessCache[key]=4,ctx[key]):(globalProperties=appContext.config.globalProperties,hasOwn(globalProperties,key)?globalProperties[key]:void(!currentRenderingInstance||isString(key)&&0===key.indexOf("__v")||(data===EMPTY_OBJ||"$"!==key[0]&&"_"!==key[0]||!hasOwn(data,key)?instance===currentRenderingInstance&&warn$1(`Property ${JSON.stringify(key)} was accessed during render `+"but is not defined on instance."):warn$1(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved `+'character ("$" or "_") and is not proxied on the render context.'))))},set({_:instance},key,value){const{data:data,setupState:setupState,ctx:ctx}=instance;return setupState!==EMPTY_OBJ&&hasOwn(setupState,key)?(setupState[key]=value,!0):data!==EMPTY_OBJ&&hasOwn(data,key)?(data[key]=value,!0):hasOwn(instance.props,key)?(warn$1(`Attempting to mutate prop "${key}". Props are readonly.`,instance),!1):"$"===key[0]&&key.slice(1)in instance?(warn$1(`Attempting to mutate public property "${key}". `+"Properties starting with $ are reserved and readonly.",instance),!1):(key in instance.appContext.config.globalProperties?Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,value:value}):ctx[key]=value,!0)},has({_:{data:data,setupState:setupState,accessCache:accessCache,ctx:ctx,appContext:appContext,propsOptions:propsOptions}},key){let normalizedProps;return!!accessCache[key]||data!==EMPTY_OBJ&&hasOwn(data,key)||setupState!==EMPTY_OBJ&&hasOwn(setupState,key)||(normalizedProps=propsOptions[0])&&hasOwn(normalizedProps,key)||hasOwn(ctx,key)||hasOwn(publicPropertiesMap,key)||hasOwn(appContext.config.globalProperties,key)},defineProperty(target,key,descriptor){return null!=descriptor.get?target._.accessCache[key]=0:hasOwn(descriptor,"value")&&this.set(target,key,descriptor.value,null),Reflect.defineProperty(target,key,descriptor)},ownKeys:target=>(warn$1("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."),Reflect.ownKeys(target))},RuntimeCompiledPublicInstanceProxyHandlers=extend({},PublicInstanceProxyHandlers,{get(target,key){if(key!==Symbol.unscopables)return PublicInstanceProxyHandlers.get(target,key,target)},has(_,key){const has="_"!==key[0]&&!isGloballyWhitelisted(key);return!has&&PublicInstanceProxyHandlers.has(_,key)&&warn$1(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`),has}}),emptyAppContext=createAppContext();let uid$1=0,currentInstance=null;const getCurrentInstance=()=>currentInstance||currentRenderingInstance,setCurrentInstance=instance=>{currentInstance=instance,instance.scope.on()},unsetCurrentInstance=()=>{currentInstance&&currentInstance.scope.off(),currentInstance=null},isBuiltInTag=makeMap("slot,component");let compile,installWithProxy,isInSSRComponentSetup=!1;const isRuntimeOnly=()=>!compile,classifyRE=/(?:^|[-_])(\w)/g,classify=str=>str.replace(classifyRE,c=>c.toUpperCase()).replace(/[-_]/g,""),computed$1=(getterOrOptions,debugOptions)=>computed(getterOrOptions,debugOptions,isInSSRComponentSetup),warnRuntimeUsage=method=>warn$1(`${method}() is a compiler-hint helper that is only usable inside `+"<script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect."),ssrContextKey=Symbol("ssrContext"),useSSRContext=()=>{warn$1("useSSRContext() is not supported in the global build.")},version="3.2.33",ssrUtils=null,resolveFilter=null,compatUtils=null,svgNS="http://www.w3.org/2000/svg",doc="undefined"!=typeof document?document:null,templateContainer=doc&&doc.createElement("template"),nodeOps={insert:(child,parent,anchor)=>{parent.insertBefore(child,anchor||null)},remove:child=>{const parent=child.parentNode;parent&&parent.removeChild(child)},createElement:(tag,isSVG,is,props)=>{const el=isSVG?doc.createElementNS(svgNS,tag):doc.createElement(tag,is?{is:is}:void 0);return"select"===tag&&props&&null!=props.multiple&&el.setAttribute("multiple",props.multiple),el},createText:text=>doc.createTextNode(text),createComment:text=>doc.createComment(text),setText:(node,text)=>{node.nodeValue=text},setElementText:(el,text)=>{el.textContent=text},parentNode:node=>node.parentNode,nextSibling:node=>node.nextSibling,querySelector:selector=>doc.querySelector(selector),setScopeId(el,id){el.setAttribute(id,"")},cloneNode(el){const cloned=el.cloneNode(!0);return"_value"in el&&(cloned._value=el._value),cloned},insertStaticContent(content,parent,anchor,isSVG,start,end){const before=anchor?anchor.previousSibling:parent.lastChild;if(start&&(start===end||start.nextSibling))for(;parent.insertBefore(start.cloneNode(!0),anchor),start!==end&&(start=start.nextSibling););else{templateContainer.innerHTML=isSVG?`<svg>${content}</svg>`:content;const template=templateContainer.content;if(isSVG){const wrapper=template.firstChild;for(;wrapper.firstChild;)template.appendChild(wrapper.firstChild);template.removeChild(wrapper)}parent.insertBefore(template,anchor)}return[before?before.nextSibling:parent.firstChild,anchor?anchor.previousSibling:parent.lastChild]}},importantRE=/\s*!important$/,prefixes=["Webkit","Moz","ms"],prefixCache={},xlinkNS="http://www.w3.org/1999/xlink",[_getNow,skipTimestampCheck]=(()=>{let _getNow=Date.now,skipTimestampCheck=!1;if("undefined"!=typeof window){Date.now()>document.createEvent("Event").timeStamp&&(_getNow=(()=>performance.now()));const ffMatch=navigator.userAgent.match(/firefox\/(\d+)/i);skipTimestampCheck=!!(ffMatch&&Number(ffMatch[1])<=53)}return[_getNow,skipTimestampCheck]})();let cachedNow=0;const p=Promise.resolve(),reset=()=>{cachedNow=0},getNow=()=>cachedNow||(p.then(reset),cachedNow=_getNow()),optionsModifierRE=/(?:Once|Passive|Capture)$/,nativeOnRE=/^on[a-z]/,patchProp=(el,key,prevValue,nextValue,isSVG=!1,prevChildren,parentComponent,parentSuspense,unmountChildren)=>{"class"===key?patchClass(el,nextValue,isSVG):"style"===key?patchStyle(el,prevValue,nextValue):isOn(key)?isModelListener(key)||patchEvent(el,key,prevValue,nextValue,parentComponent):("."===key[0]?(key=key.slice(1),1):"^"===key[0]?(key=key.slice(1),0):shouldSetAsProp(el,key,nextValue,isSVG))?patchDOMProp(el,key,nextValue,prevChildren,parentComponent,parentSuspense,unmountChildren):("true-value"===key?el._trueValue=nextValue:"false-value"===key&&(el._falseValue=nextValue),patchAttr(el,key,nextValue,isSVG))},defineSSRCustomElement=options=>defineCustomElement(options,hydrate),BaseClass="undefined"!=typeof HTMLElement?HTMLElement:class{};class VueElement extends BaseClass{constructor(_def,_props={},hydrate){super(),this._def=_def,this._props=_props,this._instance=null,this._connected=!1,this._resolved=!1,this._numberProps=null,this.shadowRoot&&hydrate?hydrate(this._createVNode(),this.shadowRoot):(this.shadowRoot&&warn$1("Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."),this.attachShadow({mode:"open"}))}connectedCallback(){this._connected=!0,this._instance||this._resolveDef()}disconnectedCallback(){this._connected=!1,nextTick(()=>{this._connected||(render(null,this.shadowRoot),this._instance=null)})}_resolveDef(){if(this._resolved)return;this._resolved=!0;for(let i=0;i<this.attributes.length;i++)this._setAttr(this.attributes[i].name);new MutationObserver(mutations=>{for(const m of mutations)this._setAttr(m.attributeName)}).observe(this,{attributes:!0});const resolve=def=>{const{props:props,styles:styles}=def,hasOptions=!isArray(props),rawKeys=props?hasOptions?Object.keys(props):props:[];let numberProps;if(hasOptions)for(const key in this._props){const opt=props[key];(opt===Number||opt&&opt.type===Number)&&(this._props[key]=toNumber(this._props[key]),(numberProps||(numberProps=Object.create(null)))[key]=!0)}this._numberProps=numberProps;for(const key of Object.keys(this))"_"!==key[0]&&this._setProp(key,this[key],!0,!1);for(const key of rawKeys.map(camelize))Object.defineProperty(this,key,{get(){return this._getProp(key)},set(val){this._setProp(key,val)}});this._applyStyles(styles),this._update()},asyncDef=this._def.__asyncLoader;asyncDef?asyncDef().then(resolve):resolve(this._def)}_setAttr(key){let value=this.getAttribute(key);this._numberProps&&this._numberProps[key]&&(value=toNumber(value)),this._setProp(camelize(key),value,!1)}_getProp(key){return this._props[key]}_setProp(key,val,shouldReflect=!0,shouldUpdate=!0){val!==this._props[key]&&(this._props[key]=val,shouldUpdate&&this._instance&&this._update(),shouldReflect&&(!0===val?this.setAttribute(hyphenate(key),""):"string"==typeof val||"number"==typeof val?this.setAttribute(hyphenate(key),val+""):val||this.removeAttribute(hyphenate(key))))}_update(){render(this._createVNode(),this.shadowRoot)}_createVNode(){const vnode=createVNode(this._def,extend({},this._props));return this._instance||(vnode.ce=(instance=>{this._instance=instance,instance.isCE=!0,instance.ceReload=(newStyles=>{this._styles&&(this._styles.forEach(s=>this.shadowRoot.removeChild(s)),this._styles.length=0),this._applyStyles(newStyles),this._def.__asyncLoader||(this._instance=null,this._update())}),instance.emit=((event,...args)=>{this.dispatchEvent(new CustomEvent(event,{detail:args}))});let parent=this;for(;parent=parent&&(parent.parentNode||parent.host);)if(parent instanceof VueElement){instance.parent=parent._instance;break}})),vnode}_applyStyles(styles){styles&&styles.forEach(css=>{const s=document.createElement("style");s.textContent=css,this.shadowRoot.appendChild(s),(this._styles||(this._styles=[])).push(s)})}}const TRANSITION="transition",ANIMATION="animation",Transition=(props,{slots:slots})=>h(BaseTransition,resolveTransitionProps(props),slots);Transition.displayName="Transition";const DOMTransitionPropsValidators={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},TransitionPropsValidators=Transition.props=extend({},BaseTransition.props,DOMTransitionPropsValidators),callHook$1=(hook,args=[])=>{isArray(hook)?hook.forEach(h=>h(...args)):hook&&hook(...args)},hasExplicitCallback=hook=>!!hook&&(isArray(hook)?hook.some(h=>h.length>1):hook.length>1);let endId=0;const positionMap=new WeakMap,newPositionMap=new WeakMap,TransitionGroupImpl={name:"TransitionGroup",props:extend({},TransitionPropsValidators,{tag:String,moveClass:String}),setup(props,{slots:slots}){const instance=getCurrentInstance(),state=useTransitionState();let prevChildren,children;return onUpdated(()=>{if(!prevChildren.length)return;const moveClass=props.moveClass||`${props.name||"v"}-move`;if(!hasCSSTransform(prevChildren[0].el,instance.vnode.el,moveClass))return
;prevChildren.forEach(callPendingCbs),prevChildren.forEach(recordPosition);const movedChildren=prevChildren.filter(applyTranslation);forceReflow(),movedChildren.forEach(c=>{const el=c.el,style=el.style;addTransitionClass(el,moveClass),style.transform=style.webkitTransform=style.transitionDuration="";const cb=el._moveCb=(e=>{e&&e.target!==el||e&&!/transform$/.test(e.propertyName)||(el.removeEventListener("transitionend",cb),el._moveCb=null,removeTransitionClass(el,moveClass))});el.addEventListener("transitionend",cb)})}),()=>{const rawProps=toRaw(props),cssTransitionProps=resolveTransitionProps(rawProps);let tag=rawProps.tag||Fragment;prevChildren=children,children=slots.default?getTransitionRawChildren(slots.default()):[];for(let i=0;i<children.length;i++){const child=children[i];null!=child.key?setTransitionHooks(child,resolveTransitionHooks(child,cssTransitionProps,state,instance)):warn$1("<TransitionGroup> children must be keyed.")}if(prevChildren)for(let i=0;i<prevChildren.length;i++){const child=prevChildren[i];setTransitionHooks(child,resolveTransitionHooks(child,cssTransitionProps,state,instance)),positionMap.set(child,child.el.getBoundingClientRect())}return createVNode(tag,null,children)}}},TransitionGroup=TransitionGroupImpl,getModelAssigner=vnode=>{const fn=vnode.props["onUpdate:modelValue"];return isArray(fn)?value=>invokeArrayFns(fn,value):fn},vModelText={created(el,{modifiers:{lazy:lazy,trim:trim,number:number}},vnode){el._assign=getModelAssigner(vnode);const castToNumber=number||vnode.props&&"number"===vnode.props.type;addEventListener(el,lazy?"change":"input",e=>{if(e.target.composing)return;let domValue=el.value;trim?domValue=domValue.trim():castToNumber&&(domValue=toNumber(domValue)),el._assign(domValue)}),trim&&addEventListener(el,"change",()=>{el.value=el.value.trim()}),lazy||(addEventListener(el,"compositionstart",onCompositionStart),addEventListener(el,"compositionend",onCompositionEnd),addEventListener(el,"change",onCompositionEnd))},mounted(el,{value:value}){el.value=null==value?"":value},beforeUpdate(el,{value:value,modifiers:{lazy:lazy,trim:trim,number:number}},vnode){if(el._assign=getModelAssigner(vnode),el.composing)return;if(document.activeElement===el){if(lazy)return;if(trim&&el.value.trim()===value)return;if((number||"number"===el.type)&&toNumber(el.value)===value)return}const newValue=null==value?"":value;el.value!==newValue&&(el.value=newValue)}},vModelCheckbox={deep:!0,created(el,_,vnode){el._assign=getModelAssigner(vnode),addEventListener(el,"change",()=>{const modelValue=el._modelValue,elementValue=getValue(el),checked=el.checked,assign=el._assign;if(isArray(modelValue)){const index=looseIndexOf(modelValue,elementValue),found=-1!==index;if(checked&&!found)assign(modelValue.concat(elementValue));else if(!checked&&found){const filtered=[...modelValue];filtered.splice(index,1),assign(filtered)}}else if(isSet(modelValue)){const cloned=new Set(modelValue);checked?cloned.add(elementValue):cloned.delete(elementValue),assign(cloned)}else assign(getCheckboxValue(el,checked))})},mounted:setChecked,beforeUpdate(el,binding,vnode){el._assign=getModelAssigner(vnode),setChecked(el,binding,vnode)}},vModelRadio={created(el,{value:value},vnode){el.checked=looseEqual(value,vnode.props.value),el._assign=getModelAssigner(vnode),addEventListener(el,"change",()=>{el._assign(getValue(el))})},beforeUpdate(el,{value:value,oldValue:oldValue},vnode){el._assign=getModelAssigner(vnode),value!==oldValue&&(el.checked=looseEqual(value,vnode.props.value))}},vModelSelect={deep:!0,created(el,{value:value,modifiers:{number:number}},vnode){const isSetModel=isSet(value);addEventListener(el,"change",()=>{const selectedVal=Array.prototype.filter.call(el.options,o=>o.selected).map(o=>number?toNumber(getValue(o)):getValue(o));el._assign(el.multiple?isSetModel?new Set(selectedVal):selectedVal:selectedVal[0])}),el._assign=getModelAssigner(vnode)},mounted(el,{value:value}){setSelected(el,value)},beforeUpdate(el,_binding,vnode){el._assign=getModelAssigner(vnode)},updated(el,{value:value}){setSelected(el,value)}},vModelDynamic={created(el,binding,vnode){callModelHook(el,binding,vnode,null,"created")},mounted(el,binding,vnode){callModelHook(el,binding,vnode,null,"mounted")},beforeUpdate(el,binding,vnode,prevVNode){callModelHook(el,binding,vnode,prevVNode,"beforeUpdate")},updated(el,binding,vnode,prevVNode){callModelHook(el,binding,vnode,prevVNode,"updated")}},systemModifiers=["ctrl","shift","alt","meta"],modifierGuards={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&0!==e.button,middle:e=>"button"in e&&1!==e.button,right:e=>"button"in e&&2!==e.button,exact:(e,modifiers)=>systemModifiers.some(m=>e[`${m}Key`]&&!modifiers.includes(m))},withModifiers=(fn,modifiers)=>(event,...args)=>{for(let i=0;i<modifiers.length;i++){const guard=modifierGuards[modifiers[i]];if(guard&&guard(event,modifiers))return}return fn(event,...args)},keyNames={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},withKeys=(fn,modifiers)=>event=>{if(!("key"in event))return;const eventKey=hyphenate(event.key);return modifiers.some(k=>k===eventKey||keyNames[k]===eventKey)?fn(event):void 0},vShow={beforeMount(el,{value:value},{transition:transition}){el._vod="none"===el.style.display?"":el.style.display,transition&&value?transition.beforeEnter(el):setDisplay(el,value)},mounted(el,{value:value},{transition:transition}){transition&&value&&transition.enter(el)},updated(el,{value:value,oldValue:oldValue},{transition:transition}){!value!=!oldValue&&(transition?value?(transition.beforeEnter(el),setDisplay(el,!0),transition.enter(el)):transition.leave(el,()=>{setDisplay(el,!1)}):setDisplay(el,value))},beforeUnmount(el,{value:value}){setDisplay(el,value)}},rendererOptions=extend({patchProp:patchProp},nodeOps);let renderer,enabledHydration=!1;const render=(...args)=>{ensureRenderer().render(...args)},hydrate=(...args)=>{ensureHydrationRenderer().hydrate(...args)},createApp=(...args)=>{const app=ensureRenderer().createApp(...args);injectNativeTagCheck(app),injectCompilerOptionsCheck(app);const{mount:mount}=app;return app.mount=(containerOrSelector=>{const container=normalizeContainer(containerOrSelector);if(!container)return;const component=app._component;isFunction(component)||component.render||component.template||(component.template=container.innerHTML),container.innerHTML="";const proxy=mount(container,!1,container instanceof SVGElement);return container instanceof Element&&(container.removeAttribute("v-cloak"),container.setAttribute("data-v-app","")),proxy}),app},createSSRApp=(...args)=>{const app=ensureHydrationRenderer().createApp(...args);injectNativeTagCheck(app),injectCompilerOptionsCheck(app);const{mount:mount}=app;return app.mount=(containerOrSelector=>{const container=normalizeContainer(containerOrSelector);if(container)return mount(container,!0,container instanceof SVGElement)}),app},initDirectivesForSSR=NOOP,errorMessages={0:"Illegal comment.",1:"CDATA section is allowed only in XML context.",2:"Duplicate attribute.",3:"End tag cannot have attributes.",4:"Illegal '/' in tags.",5:"Unexpected EOF in tag.",6:"Unexpected EOF in CDATA section.",7:"Unexpected EOF in comment.",8:"Unexpected EOF in script.",9:"Unexpected EOF in tag.",10:"Incorrectly closed comment.",11:"Incorrectly opened comment.",12:"Illegal tag name. Use '&lt;' to print '<'.",13:"Attribute value was expected.",14:"End tag name was expected.",15:"Whitespace was expected.",16:"Unexpected '<!--' in comment.",17:"Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<).",18:"Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",19:"Attribute name cannot start with '='.",21:"'<?' is allowed only in XML context.",20:"Unexpected null character.",22:"Illegal '/' in tags.",23:"Invalid end tag.",24:"Element is missing end tag.",25:"Interpolation end sign was not found.",27:"End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",26:"Legal directive name was expected.",28:"v-if/v-else-if is missing expression.",29:"v-if/else branches must use unique keys.",30:"v-else/v-else-if has no adjacent v-if or v-else-if.",31:"v-for is missing expression.",32:"v-for has invalid expression.",33:"<template v-for> key should be placed on the <template> tag.",34:"v-bind is missing expression.",35:"v-on is missing expression.",36:"Unexpected custom directive on <slot> outlet.",37:"Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",38:"Duplicate slot names found. ",39:"Extraneous children found when component already has explicitly named default slot. These children will be ignored.",40:"v-slot can only be used on components or <template> tags.",41:"v-model is missing expression.",42:"v-model value must be a valid JavaScript member expression.",43:"v-model cannot be used on v-for or v-slot scope variables because they are not writable.",44:"Error parsing JavaScript expression: ",45:"<KeepAlive> expects exactly one child component.",46:'"prefixIdentifiers" option is not supported in this build of compiler.',47:"ES module mode is not supported in this build of compiler.",48:'"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',49:'"scopeId" option is only supported in module mode.',50:""},FRAGMENT=Symbol("Fragment"),TELEPORT=Symbol("Teleport"),SUSPENSE=Symbol("Suspense"),KEEP_ALIVE=Symbol("KeepAlive"),BASE_TRANSITION=Symbol("BaseTransition"),OPEN_BLOCK=Symbol("openBlock"),CREATE_BLOCK=Symbol("createBlock"),CREATE_ELEMENT_BLOCK=Symbol("createElementBlock"),CREATE_VNODE=Symbol("createVNode"),CREATE_ELEMENT_VNODE=Symbol("createElementVNode"),CREATE_COMMENT=Symbol("createCommentVNode"),CREATE_TEXT=Symbol("createTextVNode"),CREATE_STATIC=Symbol("createStaticVNode"),RESOLVE_COMPONENT=Symbol("resolveComponent"),RESOLVE_DYNAMIC_COMPONENT=Symbol("resolveDynamicComponent"),RESOLVE_DIRECTIVE=Symbol("resolveDirective"),RESOLVE_FILTER=Symbol("resolveFilter"),WITH_DIRECTIVES=Symbol("withDirectives"),RENDER_LIST=Symbol("renderList"),RENDER_SLOT=Symbol("renderSlot"),CREATE_SLOTS=Symbol("createSlots"),TO_DISPLAY_STRING=Symbol("toDisplayString"),MERGE_PROPS=Symbol("mergeProps"),NORMALIZE_CLASS=Symbol("normalizeClass"),NORMALIZE_STYLE=Symbol("normalizeStyle"),NORMALIZE_PROPS=Symbol("normalizeProps"),GUARD_REACTIVE_PROPS=Symbol("guardReactiveProps"),TO_HANDLERS=Symbol("toHandlers"),CAMELIZE=Symbol("camelize"),CAPITALIZE=Symbol("capitalize"),TO_HANDLER_KEY=Symbol("toHandlerKey"),SET_BLOCK_TRACKING=Symbol("setBlockTracking"),PUSH_SCOPE_ID=Symbol("pushScopeId"),POP_SCOPE_ID=Symbol("popScopeId"),WITH_CTX=Symbol("withCtx"),UNREF=Symbol("unref"),IS_REF=Symbol("isRef"),WITH_MEMO=Symbol("withMemo"),IS_MEMO_SAME=Symbol("isMemoSame"),helperNameMap={[FRAGMENT]:"Fragment",[TELEPORT]:"Teleport",[SUSPENSE]:"Suspense",[KEEP_ALIVE]:"KeepAlive",[BASE_TRANSITION]:"BaseTransition",[OPEN_BLOCK]:"openBlock",[CREATE_BLOCK]:"createBlock",[CREATE_ELEMENT_BLOCK]:"createElementBlock",[CREATE_VNODE]:"createVNode",[CREATE_ELEMENT_VNODE]:"createElementVNode",[CREATE_COMMENT]:"createCommentVNode",[CREATE_TEXT]:"createTextVNode",[CREATE_STATIC]:"createStaticVNode",[RESOLVE_COMPONENT]:"resolveComponent",[RESOLVE_DYNAMIC_COMPONENT]:"resolveDynamicComponent",[RESOLVE_DIRECTIVE]:"resolveDirective",[RESOLVE_FILTER]:"resolveFilter",[WITH_DIRECTIVES]:"withDirectives",[RENDER_LIST]:"renderList",[RENDER_SLOT]:"renderSlot",[CREATE_SLOTS]:"createSlots",[TO_DISPLAY_STRING]:"toDisplayString",[MERGE_PROPS]:"mergeProps",[NORMALIZE_CLASS]:"normalizeClass",[NORMALIZE_STYLE]:"normalizeStyle",[NORMALIZE_PROPS]:"normalizeProps",[GUARD_REACTIVE_PROPS]:"guardReactiveProps",[TO_HANDLERS]:"toHandlers",[CAMELIZE]:"camelize",[CAPITALIZE]:"capitalize",[TO_HANDLER_KEY]:"toHandlerKey",[SET_BLOCK_TRACKING]:"setBlockTracking",[PUSH_SCOPE_ID]:"pushScopeId",[POP_SCOPE_ID]:"popScopeId",[WITH_CTX]:"withCtx",[UNREF]:"unref",[IS_REF]:"isRef",[WITH_MEMO]:"withMemo",[IS_MEMO_SAME]:"isMemoSame"},locStub={source:"",start:{line:1,column:1,offset:0},end:{line:1,column:1,offset:0}},isStaticExp=p=>4===p.type&&p.isStatic,isBuiltInType=(tag,expected)=>tag===expected||tag===hyphenate(expected),nonIdentifierRE=/^\d|[^\$\w]/,isSimpleIdentifier=name=>!nonIdentifierRE.test(name),validFirstIdentCharRE=/[A-Za-z_$\xA0-\uFFFF]/,validIdentCharRE=/[\.\?\w$\xA0-\uFFFF]/,whitespaceRE=/\s+[.[]\s*|\s*[.[]\s+/g,isMemberExpressionBrowser=path=>{path=path.trim().replace(whitespaceRE,s=>s.trim());let state=0,stateStack=[],currentOpenBracketCount=0,currentOpenParensCount=0,currentStringType=null;for(let i=0;i<path.length;i++){const char=path.charAt(i);switch(state){case 0:if("["===char)stateStack.push(state),state=1,currentOpenBracketCount++;else if("("===char)stateStack.push(state),state=2,currentOpenParensCount++;else if(!(0===i?validFirstIdentCharRE:validIdentCharRE).test(char))return!1;break;case 1:"'"===char||'"'===char||"`"===char?(stateStack.push(state),state=3,currentStringType=char):"["===char?currentOpenBracketCount++:"]"===char&&(--currentOpenBracketCount||(state=stateStack.pop()));break;case 2:if("'"===char||'"'===char||"`"===char)stateStack.push(state),state=3,currentStringType=char;else if("("===char)currentOpenParensCount++;else if(")"===char){if(i===path.length-1)return!1;--currentOpenParensCount||(state=stateStack.pop())}break;case 3:char===currentStringType&&(state=stateStack.pop(),currentStringType=null)}}return!currentOpenBracketCount&&!currentOpenParensCount},isMemberExpression=isMemberExpressionBrowser,propsHelperSet=new Set([NORMALIZE_PROPS,GUARD_REACTIVE_PROPS]),decodeRE=/&(gt|lt|amp|apos|quot);/g,decodeMap={gt:">",lt:"<",amp:"&",apos:"'",quot:'"'},defaultParserOptions={delimiters:["{{","}}"],getNamespace:()=>0,getTextMode:()=>0,isVoidTag:NO,isPreTag:NO,isCustomElement:NO,decodeEntities:rawText=>rawText.replace(decodeRE,(_,p1)=>decodeMap[p1]),onError:defaultOnError,onWarn:defaultOnWarn,comments:!0},isSpecialTemplateDirective=makeMap("if,else,else-if,for,slot"),allowHoistedHelperSet=new Set([NORMALIZE_CLASS,NORMALIZE_STYLE,NORMALIZE_PROPS,GUARD_REACTIVE_PROPS]),PURE_ANNOTATION="/*#__PURE__*/",prohibitedKeywordRE=new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b")+"\\b"),stripStringRE=/'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g,transformExpression=(node,context)=>{if(5===node.type)node.content=processExpression(node.content,context);else if(1===node.type)for(let i=0;i<node.props.length;i++){const dir=node.props[i];if(7===dir.type&&"for"!==dir.name){const exp=dir.exp,arg=dir.arg;!exp||4!==exp.type||"on"===dir.name&&arg||(dir.exp=processExpression(exp,context,"slot"===dir.name)),arg&&4===arg.type&&!arg.isStatic&&(dir.arg=processExpression(arg,context))}}},transformIf=createStructuralDirectiveTransform(/^(if|else|else-if)$/,(node,dir,context)=>processIf(node,dir,context,(ifNode,branch,isRoot)=>{const siblings=context.parent.children;let i=siblings.indexOf(ifNode),key=0;for(;i-- >=0;){const sibling=siblings[i];sibling&&9===sibling.type&&(key+=sibling.branches.length)}return()=>{if(isRoot)ifNode.codegenNode=createCodegenNodeForBranch(branch,key,context);else{const parentCondition=getParentCondition(ifNode.codegenNode);parentCondition.alternate=createCodegenNodeForBranch(branch,key+ifNode.branches.length-1,context)}}})),transformFor=createStructuralDirectiveTransform("for",(node,dir,context)=>{const{helper:helper,removeHelper:removeHelper}=context;return processFor(node,dir,context,forNode=>{const renderExp=createCallExpression(helper(RENDER_LIST),[forNode.source]),isTemplate=isTemplateNode(node),memo=findDir(node,"memo"),keyProp=findProp(node,"key"),keyExp=keyProp&&(6===keyProp.type?createSimpleExpression(keyProp.value.content,!0):keyProp.exp),keyProperty=keyProp?createObjectProperty("key",keyExp):null,isStableFragment=4===forNode.source.type&&forNode.source.constType>0,fragmentFlag=isStableFragment?64:keyProp?128:256;return forNode.codegenNode=createVNodeCall(context,helper(FRAGMENT),void 0,renderExp,fragmentFlag+` /* ${PatchFlagNames[fragmentFlag]} */`,void 0,void 0,!0,!isStableFragment,!1,node.loc),()=>{let childBlock;const{children:children}=forNode;isTemplate&&node.children.some(c=>{if(1===c.type){const key=findProp(c,"key");if(key)return context.onError(createCompilerError(33,key.loc)),!0}});const needFragmentWrapper=1!==children.length||1!==children[0].type,slotOutlet=isSlotOutlet(node)?node:isTemplate&&1===node.children.length&&isSlotOutlet(node.children[0])?node.children[0]:null;if(slotOutlet?(childBlock=slotOutlet.codegenNode,isTemplate&&keyProperty&&injectProp(childBlock,keyProperty,context)):needFragmentWrapper?childBlock=createVNodeCall(context,helper(FRAGMENT),keyProperty?createObjectExpression([keyProperty]):void 0,node.children,64+` /* ${PatchFlagNames[64]} */`,void 0,void 0,!0,void 0,!1):(childBlock=children[0].codegenNode,isTemplate&&keyProperty&&injectProp(childBlock,keyProperty,context),childBlock.isBlock!==!isStableFragment&&(childBlock.isBlock?(removeHelper(OPEN_BLOCK),removeHelper(getVNodeBlockHelper(context.inSSR,childBlock.isComponent))):removeHelper(getVNodeHelper(context.inSSR,childBlock.isComponent))),childBlock.isBlock=!isStableFragment,childBlock.isBlock?(helper(OPEN_BLOCK),helper(getVNodeBlockHelper(context.inSSR,childBlock.isComponent))):helper(getVNodeHelper(context.inSSR,childBlock.isComponent))),memo){const loop=createFunctionExpression(createForLoopParams(forNode.parseResult,[createSimpleExpression("_cached")]));loop.body=createBlockStatement([createCompoundExpression(["const _memo = (",memo.exp,")"]),createCompoundExpression(["if (_cached",...keyExp?[" && _cached.key === ",keyExp]:[],` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`]),createCompoundExpression(["const _item = ",childBlock]),createSimpleExpression("_item.memo = _memo"),createSimpleExpression("return _item")]),renderExp.arguments.push(loop,createSimpleExpression("_cache"),createSimpleExpression(String(context.cached++)))}else renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult),childBlock,!0))}})}),forAliasRE=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,forIteratorRE=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,stripParensRE=/^\(|\)$/g,defaultFallback=createSimpleExpression("undefined",!1),trackSlotScopes=(node,context)=>{if(1===node.type&&(1===node.tagType||3===node.tagType)){const vSlot=findDir(node,"slot");if(vSlot)return vSlot.exp,context.scopes.vSlot++,()=>{context.scopes.vSlot--}}},buildClientSlotFn=(props,children,loc)=>createFunctionExpression(props,children,!1,!0,children.length?children[0].loc:loc),directiveImportMap=new WeakMap,transformElement=(node,context)=>(function(){if(node=context.currentNode,1!==node.type||0!==node.tagType&&1!==node.tagType)return;const{tag:tag,props:props}=node,isComponent=1===node.tagType;let vnodeTag=isComponent?resolveComponentType(node,context):`"${tag}"`;const isDynamicComponent=isObject(vnodeTag)&&vnodeTag.callee===RESOLVE_DYNAMIC_COMPONENT;let vnodeProps,vnodeChildren,vnodePatchFlag,vnodeDynamicProps,dynamicPropNames,vnodeDirectives,patchFlag=0,shouldUseBlock=isDynamicComponent||vnodeTag===TELEPORT||vnodeTag===SUSPENSE||!isComponent&&("svg"===tag||"foreignObject"===tag);if(props.length>0){const propsBuildResult=buildProps(node,context);vnodeProps=propsBuildResult.props,patchFlag=propsBuildResult.patchFlag,dynamicPropNames=propsBuildResult.dynamicPropNames;const directives=propsBuildResult.directives;vnodeDirectives=directives&&directives.length?createArrayExpression(directives.map(dir=>buildDirectiveArgs(dir,context))):void 0,propsBuildResult.shouldUseBlock&&(shouldUseBlock=!0)}if(node.children.length>0){vnodeTag===KEEP_ALIVE&&(shouldUseBlock=!0,patchFlag|=1024,node.children.length>1&&context.onError(createCompilerError(45,{start:node.children[0].loc.start,end:node.children[node.children.length-1].loc.end,source:""})));const shouldBuildAsSlots=isComponent&&vnodeTag!==TELEPORT&&vnodeTag!==KEEP_ALIVE;if(shouldBuildAsSlots){const{slots:slots,hasDynamicSlots:hasDynamicSlots}=buildSlots(node,context);vnodeChildren=slots,hasDynamicSlots&&(patchFlag|=1024)}else if(1===node.children.length&&vnodeTag!==TELEPORT){const child=node.children[0],type=child.type,hasDynamicTextChild=5===type||8===type;hasDynamicTextChild&&0===getConstantType(child,context)&&(patchFlag|=1),vnodeChildren=hasDynamicTextChild||2===type?child:node.children}else vnodeChildren=node.children}if(0!==patchFlag){if(patchFlag<0)vnodePatchFlag=patchFlag+` /* ${PatchFlagNames[patchFlag]} */`;else{const flagNames=Object.keys(PatchFlagNames).map(Number).filter(n=>n>0&&patchFlag&n).map(n=>PatchFlagNames[n]).join(", ");vnodePatchFlag=patchFlag+` /* ${flagNames} */`}dynamicPropNames&&dynamicPropNames.length&&(vnodeDynamicProps=stringifyDynamicPropNames(dynamicPropNames))}node.codegenNode=createVNodeCall(context,vnodeTag,vnodeProps,vnodeChildren,vnodePatchFlag,vnodeDynamicProps,vnodeDirectives,!!shouldUseBlock,!1,isComponent,node.loc)}),transformSlotOutlet=(node,context)=>{if(isSlotOutlet(node)){const{children:children,loc:loc}=node,{slotName:slotName,slotProps:slotProps}=processSlotOutlet(node,context),slotArgs=[context.prefixIdentifiers?"_ctx.$slots":"$slots",slotName,"{}","undefined","true"];let expectedLen=2;slotProps&&(slotArgs[2]=slotProps,expectedLen=3),children.length&&(slotArgs[3]=createFunctionExpression([],children,!1,!1,loc),expectedLen=4),context.scopeId&&!context.slotted&&(expectedLen=5),slotArgs.splice(expectedLen),node.codegenNode=createCallExpression(context.helper(RENDER_SLOT),slotArgs,loc)}},fnExpRE=/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/,transformOn=(dir,node,context,augmentor)=>{const{loc:loc,modifiers:modifiers,arg:arg}=dir;let eventName;if(dir.exp||modifiers.length||context.onError(createCompilerError(35,loc)),4===arg.type)if(arg.isStatic){let rawName=arg.content;rawName.startsWith("vue:")&&(rawName=`vnode-${rawName.slice(4)}`),eventName=createSimpleExpression(toHandlerKey(camelize(rawName)),!0,arg.loc)}else eventName=createCompoundExpression([`${context.helperString(TO_HANDLER_KEY)}(`,arg,")"]);else eventName=arg,eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`),eventName.children.push(")");let exp=dir.exp;exp&&!exp.content.trim()&&(exp=void 0);let shouldCache=context.cacheHandlers&&!exp&&!context.inVOnce;if(exp){const isMemberExp=isMemberExpression(exp.content),isInlineStatement=!(isMemberExp||fnExpRE.test(exp.content)),hasMultipleStatements=exp.content.includes(";");validateBrowserExpression(exp,context,!1,hasMultipleStatements),(isInlineStatement||shouldCache&&isMemberExp)&&(exp=createCompoundExpression([`${isInlineStatement?"$event":"(...args)"} => ${hasMultipleStatements?"{":"("}`,exp,hasMultipleStatements?"}":")"]))}let ret={props:[createObjectProperty(eventName,exp||createSimpleExpression("() => {}",!1,loc))]};return augmentor&&(ret=augmentor(ret)),shouldCache&&(ret.props[0].value=context.cache(ret.props[0].value)),ret.props.forEach(p=>p.key.isHandlerKey=!0),ret},transformBind=(dir,_node,context)=>{const{exp:exp,modifiers:modifiers,loc:loc}=dir,arg=dir.arg;return 4!==arg.type?(arg.children.unshift("("),arg.children.push(') || ""')):arg.isStatic||(arg.content=`${arg.content} || ""`),modifiers.includes("camel")&&(4===arg.type?arg.isStatic?arg.content=camelize(arg.content):arg.content=`${context.helperString(CAMELIZE)}(${arg.content})`:(arg.children.unshift(`${context.helperString(CAMELIZE)}(`),arg.children.push(")"))),context.inSSR||(modifiers.includes("prop")&&injectPrefix(arg,"."),modifiers.includes("attr")&&injectPrefix(arg,"^")),!exp||4===exp.type&&!exp.content.trim()?(context.onError(createCompilerError(34,loc)),{props:[createObjectProperty(arg,createSimpleExpression("",!0,loc))]}):{props:[createObjectProperty(arg,exp)]}},injectPrefix=(arg,prefix)=>{4===arg.type?arg.isStatic?arg.content=prefix+arg.content:arg.content=`\`${prefix}\${${arg.content}}\``:(arg.children.unshift(`'${prefix}' + (`),arg.children.push(")"))},transformText=(node,context)=>{if(0===node.type||1===node.type||11===node.type||10===node.type)return()=>{const children=node.children;let currentContainer=void 0,hasText=!1;for(let i=0;i<children.length;i++){const child=children[i];if(isText(child)){hasText=!0;for(let j=i+1;j<children.length;j++){const next=children[j];if(!isText(next)){currentContainer=void 0;break}currentContainer||(currentContainer=children[i]={type:8,loc:child.loc,children:[child]}),currentContainer.children.push(" + ",next),children.splice(j,1),j--}}}if(hasText&&(1!==children.length||0!==node.type&&(1!==node.type||0!==node.tagType||node.props.find(p=>7===p.type&&!context.directiveTransforms[p.name]))))for(let i=0;i<children.length;i++){const child=children[i];if(isText(child)||8===child.type){const callArgs=[];2===child.type&&" "===child.content||callArgs.push(child),context.ssr||0!==getConstantType(child,context)||callArgs.push(1+` /* ${PatchFlagNames[1]} */`),children[i]={type:12,content:child,loc:child.loc,codegenNode:createCallExpression(context.helper(CREATE_TEXT),callArgs)}}}}},seen=new WeakSet,transformOnce=(node,context)=>{if(1===node.type&&findDir(node,"once",!0)){if(seen.has(node)||context.inVOnce)return;return seen.add(node),context.inVOnce=!0,context.helper(SET_BLOCK_TRACKING),()=>{context.inVOnce=!1;const cur=context.currentNode;cur.codegenNode&&(cur.codegenNode=context.cache(cur.codegenNode,!0))}}},transformModel=(dir,node,context)=>{const{exp:exp,arg:arg}=dir;if(!exp)return context.onError(createCompilerError(41,dir.loc)),createTransformProps();const rawExp=exp.loc.source,expString=4===exp.type?exp.content:rawExp;context.bindingMetadata[rawExp];const maybeRef=!1;if(!expString.trim()||!isMemberExpression(expString)&&!maybeRef)return context.onError(createCompilerError(42,exp.loc)),createTransformProps();const propName=arg||createSimpleExpression("modelValue",!0),eventName=arg?isStaticExp(arg)?`onUpdate:${arg.content}`:createCompoundExpression(['"onUpdate:" + ',arg]):"onUpdate:modelValue";let assignmentExp;const eventArg=context.isTS?"($event: any)":"$event";assignmentExp=createCompoundExpression([`${eventArg} => ((`,exp,") = $event)"]);const props=[createObjectProperty(propName,dir.exp),createObjectProperty(eventName,assignmentExp)];if(dir.modifiers.length&&1===node.tagType){const modifiers=dir.modifiers.map(m=>(isSimpleIdentifier(m)?m:JSON.stringify(m))+": true").join(", "),modifiersKey=arg?isStaticExp(arg)?`${arg.content}Modifiers`:createCompoundExpression([arg,' + "Modifiers"']):"modelModifiers";props.push(createObjectProperty(modifiersKey,createSimpleExpression(`{ ${modifiers} }`,!1,dir.loc,2)))}return createTransformProps(props)},seen$1=new WeakSet,transformMemo=(node,context)=>{if(1===node.type){const dir=findDir(node,"memo");if(!dir||seen$1.has(node))return;return seen$1.add(node),()=>{const codegenNode=node.codegenNode||context.currentNode.codegenNode;codegenNode&&13===codegenNode.type&&(1!==node.tagType&&makeBlock(codegenNode,context),node.codegenNode=createCallExpression(context.helper(WITH_MEMO),[dir.exp,createFunctionExpression(void 0,codegenNode),"_cache",String(context.cached++)]))}}},noopDirectiveTransform=()=>({props:[]}),V_MODEL_RADIO=Symbol("vModelRadio"),V_MODEL_CHECKBOX=Symbol("vModelCheckbox"),V_MODEL_TEXT=Symbol("vModelText"),V_MODEL_SELECT=Symbol("vModelSelect"),V_MODEL_DYNAMIC=Symbol("vModelDynamic"),V_ON_WITH_MODIFIERS=Symbol("vOnModifiersGuard"),V_ON_WITH_KEYS=Symbol("vOnKeysGuard"),V_SHOW=Symbol("vShow"),TRANSITION$1=Symbol("Transition"),TRANSITION_GROUP=Symbol("TransitionGroup");let decoder;registerRuntimeHelpers({[V_MODEL_RADIO]:"vModelRadio",[V_MODEL_CHECKBOX]:"vModelCheckbox",[V_MODEL_TEXT]:"vModelText",[V_MODEL_SELECT]:"vModelSelect",[V_MODEL_DYNAMIC]:"vModelDynamic",[V_ON_WITH_MODIFIERS]:"withModifiers",[V_ON_WITH_KEYS]:"withKeys",[V_SHOW]:"vShow",[TRANSITION$1]:"Transition",[TRANSITION_GROUP]:"TransitionGroup"});const isRawTextContainer=makeMap("style,iframe,script,noscript",!0),parserOptions={isVoidTag:isVoidTag,isNativeTag:tag=>isHTMLTag(tag)||isSVGTag(tag),isPreTag:tag=>"pre"===tag,decodeEntities:decodeHtmlBrowser,isBuiltInComponent:tag=>isBuiltInType(tag,"Transition")?TRANSITION$1:isBuiltInType(tag,"TransitionGroup")?TRANSITION_GROUP:void 0,getNamespace(tag,parent){let ns=parent?parent.ns:0;if(parent&&2===ns)if("annotation-xml"===parent.tag){if("svg"===tag)return 1;parent.props.some(a=>6===a.type&&"encoding"===a.name&&null!=a.value&&("text/html"===a.value.content||"application/xhtml+xml"===a.value.content))&&(ns=0)}else/^m(?:[ions]|text)$/.test(parent.tag)&&"mglyph"!==tag&&"malignmark"!==tag&&(ns=0);else parent&&1===ns&&("foreignObject"!==parent.tag&&"desc"!==parent.tag&&"title"!==parent.tag||(ns=0));if(0===ns){if("svg"===tag)return 1;if("math"===tag)return 2}return ns},getTextMode({tag:tag,ns:ns}){if(0===ns){if("textarea"===tag||"title"===tag)return 1;if(isRawTextContainer(tag))return 2}return 0}},transformStyle=node=>{1===node.type&&node.props.forEach((p,i)=>{6===p.type&&"style"===p.name&&p.value&&(node.props[i]={type:7,name:"bind",arg:createSimpleExpression("style",!0,p.loc),exp:parseInlineCSS(p.value.content,p.loc),modifiers:[],loc:p.loc})})},parseInlineCSS=(cssText,loc)=>{const normalized=parseStringStyle(cssText);return createSimpleExpression(JSON.stringify(normalized),!1,loc,3)},DOMErrorMessages={50:"v-html is missing expression.",51:"v-html will override element children.",52:"v-text is missing expression.",53:"v-text will override element children.",54:"v-model can only be used on <input>, <textarea> and <select> elements.",55:"v-model argument is not supported on plain elements.",56:"v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",57:"Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",58:"v-show is missing expression.",59:"<Transition> expects exactly one child element or component.",60:"Tags with side effect (<script> and <style>) are ignored in client component templates."},transformVHtml=(dir,node,context)=>{const{exp:exp,loc:loc}=dir;return exp||context.onError(createDOMCompilerError(50,loc)),node.children.length&&(context.onError(createDOMCompilerError(51,loc)),node.children.length=0),{props:[createObjectProperty(createSimpleExpression("innerHTML",!0,loc),exp||createSimpleExpression("",!0))]}},transformVText=(dir,node,context)=>{const{exp:exp,loc:loc}=dir;return exp||context.onError(createDOMCompilerError(52,loc)),node.children.length&&(context.onError(createDOMCompilerError(53,loc)),node.children.length=0),{props:[createObjectProperty(createSimpleExpression("textContent",!0),exp?createCallExpression(context.helperString(TO_DISPLAY_STRING),[exp],loc):createSimpleExpression("",!0))]}},transformModel$1=(dir,node,context)=>{function checkDuplicatedValue(){const value=findProp(node,"value");value&&context.onError(createDOMCompilerError(57,value.loc))}const baseResult=transformModel(dir,node,context);if(!baseResult.props.length||1===node.tagType)return baseResult;dir.arg&&context.onError(createDOMCompilerError(55,dir.arg.loc));const{tag:tag}=node,isCustomElement=context.isCustomElement(tag);if("input"===tag||"textarea"===tag||"select"===tag||isCustomElement){let directiveToUse=V_MODEL_TEXT,isInvalidType=!1;if("input"===tag||isCustomElement){const type=findProp(node,"type");if(type){if(7===type.type)directiveToUse=V_MODEL_DYNAMIC;else if(type.value)switch(type.value.content){case"radio":
directiveToUse=V_MODEL_RADIO;break;case"checkbox":directiveToUse=V_MODEL_CHECKBOX;break;case"file":isInvalidType=!0,context.onError(createDOMCompilerError(56,dir.loc));break;default:checkDuplicatedValue()}}else hasDynamicKeyVBind(node)?directiveToUse=V_MODEL_DYNAMIC:checkDuplicatedValue()}else"select"===tag?directiveToUse=V_MODEL_SELECT:checkDuplicatedValue();isInvalidType||(baseResult.needRuntime=context.helper(directiveToUse))}else context.onError(createDOMCompilerError(54,dir.loc));return baseResult.props=baseResult.props.filter(p=>!(4===p.key.type&&"modelValue"===p.key.content)),baseResult},isEventOptionModifier=makeMap("passive,once,capture"),isNonKeyModifier=makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"),maybeKeyModifier=makeMap("left,right"),isKeyboardEvent=makeMap("onkeyup,onkeydown,onkeypress",!0),resolveModifiers=(key,modifiers,context,loc)=>{const keyModifiers=[],nonKeyModifiers=[],eventOptionModifiers=[];for(let i=0;i<modifiers.length;i++){const modifier=modifiers[i];isEventOptionModifier(modifier)?eventOptionModifiers.push(modifier):maybeKeyModifier(modifier)?isStaticExp(key)?isKeyboardEvent(key.content)?keyModifiers.push(modifier):nonKeyModifiers.push(modifier):(keyModifiers.push(modifier),nonKeyModifiers.push(modifier)):isNonKeyModifier(modifier)?nonKeyModifiers.push(modifier):keyModifiers.push(modifier)}return{keyModifiers:keyModifiers,nonKeyModifiers:nonKeyModifiers,eventOptionModifiers:eventOptionModifiers}},transformClick=(key,event)=>{const isStaticClick=isStaticExp(key)&&"onclick"===key.content.toLowerCase();return isStaticClick?createSimpleExpression(event,!0):4!==key.type?createCompoundExpression(["(",key,`) === "onClick" ? "${event}" : (`,key,")"]):key},transformOn$1=(dir,node,context)=>transformOn(dir,node,context,baseResult=>{const{modifiers:modifiers}=dir;if(!modifiers.length)return baseResult;let{key:key,value:handlerExp}=baseResult.props[0];const{keyModifiers:keyModifiers,nonKeyModifiers:nonKeyModifiers,eventOptionModifiers:eventOptionModifiers}=resolveModifiers(key,modifiers,context,dir.loc);if(nonKeyModifiers.includes("right")&&(key=transformClick(key,"onContextmenu")),nonKeyModifiers.includes("middle")&&(key=transformClick(key,"onMouseup")),nonKeyModifiers.length&&(handlerExp=createCallExpression(context.helper(V_ON_WITH_MODIFIERS),[handlerExp,JSON.stringify(nonKeyModifiers)])),!keyModifiers.length||isStaticExp(key)&&!isKeyboardEvent(key.content)||(handlerExp=createCallExpression(context.helper(V_ON_WITH_KEYS),[handlerExp,JSON.stringify(keyModifiers)])),eventOptionModifiers.length){const modifierPostfix=eventOptionModifiers.map(capitalize).join("");key=isStaticExp(key)?createSimpleExpression(`${key.content}${modifierPostfix}`,!0):createCompoundExpression(["(",key,`) + "${modifierPostfix}"`])}return{props:[createObjectProperty(key,handlerExp)]}}),transformShow=(dir,node,context)=>{const{exp:exp,loc:loc}=dir;return exp||context.onError(createDOMCompilerError(58,loc)),{props:[],needRuntime:context.helper(V_SHOW)}},warnTransitionChildren=(node,context)=>{if(1===node.type&&1===node.tagType){const component=context.isBuiltInComponent(node.tag);if(component===TRANSITION$1)return()=>{node.children.length&&hasMultipleChildren(node)&&context.onError(createDOMCompilerError(59,{start:node.children[0].loc.start,end:node.children[node.children.length-1].loc.end,source:""}))}}},ignoreSideEffectTags=(node,context)=>{1!==node.type||0!==node.tagType||"script"!==node.tag&&"style"!==node.tag||(context.onError(createDOMCompilerError(60,node.loc)),context.removeNode())},DOMNodeTransforms=[transformStyle,warnTransitionChildren],DOMDirectiveTransforms={cloak:noopDirectiveTransform,html:transformVHtml,text:transformVText,model:transformModel$1,on:transformOn$1,show:transformShow};initDev();const compileCache=Object.create(null);return registerRuntimeCompiler(compileToFunction),exports.BaseTransition=BaseTransition,exports.Comment=Comment,exports.EffectScope=EffectScope,exports.Fragment=Fragment,exports.KeepAlive=KeepAlive,exports.ReactiveEffect=ReactiveEffect,exports.Static=Static,exports.Suspense=Suspense,exports.Teleport=Teleport,exports.Text=Text,exports.Transition=Transition,exports.TransitionGroup=TransitionGroup,exports.VueElement=VueElement,exports.callWithAsyncErrorHandling=callWithAsyncErrorHandling,exports.callWithErrorHandling=callWithErrorHandling,exports.camelize=camelize,exports.capitalize=capitalize,exports.cloneVNode=cloneVNode,exports.compatUtils=compatUtils,exports.compile=compileToFunction,exports.computed=computed$1,exports.createApp=createApp,exports.createBlock=createBlock,exports.createCommentVNode=createCommentVNode,exports.createElementBlock=createElementBlock,exports.createElementVNode=createBaseVNode,exports.createHydrationRenderer=createHydrationRenderer,exports.createPropsRestProxy=createPropsRestProxy,exports.createRenderer=createRenderer,exports.createSSRApp=createSSRApp,exports.createSlots=createSlots,exports.createStaticVNode=createStaticVNode,exports.createTextVNode=createTextVNode,exports.createVNode=createVNode,exports.customRef=customRef,exports.defineAsyncComponent=defineAsyncComponent,exports.defineComponent=defineComponent,exports.defineCustomElement=defineCustomElement,exports.defineEmits=defineEmits,exports.defineExpose=defineExpose,exports.defineProps=defineProps,exports.defineSSRCustomElement=defineSSRCustomElement,exports.effect=effect,exports.effectScope=effectScope,exports.getCurrentInstance=getCurrentInstance,exports.getCurrentScope=getCurrentScope,exports.getTransitionRawChildren=getTransitionRawChildren,exports.guardReactiveProps=guardReactiveProps,exports.h=h,exports.handleError=handleError,exports.hydrate=hydrate,exports.initCustomFormatter=initCustomFormatter,exports.initDirectivesForSSR=initDirectivesForSSR,exports.inject=inject,exports.isMemoSame=isMemoSame,exports.isProxy=isProxy,exports.isReactive=isReactive,exports.isReadonly=isReadonly,exports.isRef=isRef,exports.isRuntimeOnly=isRuntimeOnly,exports.isShallow=isShallow,exports.isVNode=isVNode,exports.markRaw=markRaw,exports.mergeDefaults=mergeDefaults,exports.mergeProps=mergeProps,exports.nextTick=nextTick,exports.normalizeClass=normalizeClass,exports.normalizeProps=normalizeProps,exports.normalizeStyle=normalizeStyle,exports.onActivated=onActivated,exports.onBeforeMount=onBeforeMount,exports.onBeforeUnmount=onBeforeUnmount,exports.onBeforeUpdate=onBeforeUpdate,exports.onDeactivated=onDeactivated,exports.onErrorCaptured=onErrorCaptured,exports.onMounted=onMounted,exports.onRenderTracked=onRenderTracked,exports.onRenderTriggered=onRenderTriggered,exports.onScopeDispose=onScopeDispose,exports.onServerPrefetch=onServerPrefetch,exports.onUnmounted=onUnmounted,exports.onUpdated=onUpdated,exports.openBlock=openBlock,exports.popScopeId=popScopeId,exports.provide=provide,exports.proxyRefs=proxyRefs,exports.pushScopeId=pushScopeId,exports.queuePostFlushCb=queuePostFlushCb,exports.reactive=reactive,exports.readonly=readonly,exports.ref=ref,exports.registerRuntimeCompiler=registerRuntimeCompiler,exports.render=render,exports.renderList=renderList,exports.renderSlot=renderSlot,exports.resolveComponent=resolveComponent,exports.resolveDirective=resolveDirective,exports.resolveDynamicComponent=resolveDynamicComponent,exports.resolveFilter=resolveFilter,exports.resolveTransitionHooks=resolveTransitionHooks,exports.setBlockTracking=setBlockTracking,exports.setDevtoolsHook=setDevtoolsHook,exports.setTransitionHooks=setTransitionHooks,exports.shallowReactive=shallowReactive,exports.shallowReadonly=shallowReadonly,exports.shallowRef=shallowRef,exports.ssrContextKey=ssrContextKey,exports.ssrUtils=ssrUtils,exports.stop=stop,exports.toDisplayString=toDisplayString,exports.toHandlerKey=toHandlerKey,exports.toHandlers=toHandlers,exports.toRaw=toRaw,exports.toRef=toRef,exports.toRefs=toRefs,exports.transformVNodeArgs=transformVNodeArgs,exports.triggerRef=triggerRef,exports.unref=unref,exports.useAttrs=useAttrs,exports.useCssModule=useCssModule,exports.useCssVars=useCssVars,exports.useSSRContext=useSSRContext,exports.useSlots=useSlots,exports.useTransitionState=useTransitionState,exports.vModelCheckbox=vModelCheckbox,exports.vModelDynamic=vModelDynamic,exports.vModelRadio=vModelRadio,exports.vModelSelect=vModelSelect,exports.vModelText=vModelText,exports.vShow=vShow,exports.version=version,exports.warn=warn$1,exports.watch=watch,exports.watchEffect=watchEffect,exports.watchPostEffect=watchPostEffect,exports.watchSyncEffect=watchSyncEffect,exports.withAsyncContext=withAsyncContext,exports.withCtx=withCtx,exports.withDefaults=withDefaults,exports.withDirectives=withDirectives,exports.withKeys=withKeys,exports.withMemo=withMemo,exports.withModifiers=withModifiers,exports.withScopeId=withScopeId,Object.defineProperty(exports,"__esModule",{value:!0}),exports}({});